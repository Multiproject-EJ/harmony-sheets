var X9 = Object.defineProperty;
var Q9 = (e, t, n) => t in e ? X9(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Nn = (e, t, n) => Q9(e, typeof t != "symbol" ? t + "" : t, n);
function J9(e, t) {
var El = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function vI(e) {
function Z9(e) {
var XP = { exports: {} }, Lw = {}, QP = { exports: {} }, Hn = {};
var GL;
function eK() {
  if (GL) return Hn;
  GL = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), h = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), v = Symbol.iterator;
  function w(V) {
    return V === null || typeof V != "object" ? null : (V = v && V[v] || V["@@iterator"], typeof V == "function" ? V : null);
  function O(V, ie, de) {
    this.props = V, this.context = ie, this.refs = E, this.updater = de || C;
  }
  O.prototype.isReactComponent = {}, O.prototype.setState = function(V, ie) {
    if (typeof V != "object" && typeof V != "function" && V != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, V, ie, "setState");
  }, O.prototype.forceUpdate = function(V) {
    this.updater.enqueueForceUpdate(this, V, "forceUpdate");
  function P() {
  P.prototype = O.prototype;
  function I(V, ie, de) {
    this.props = V, this.context = ie, this.refs = E, this.updater = de || C;
  var M = I.prototype = new P();
  var A = Array.isArray, k = Object.prototype.hasOwnProperty, j = { current: null }, B = { key: !0, ref: !0, __self: !0, __source: !0 };
  function H(V, ie, de) {
    if (ie != null) for (ue in ie.ref !== void 0 && (fe = ie.ref), ie.key !== void 0 && (ge = "" + ie.key), ie) k.call(ie, ue) && !B.hasOwnProperty(ue) && (he[ue] = ie[ue]);
    if (V && V.defaultProps) for (ue in pe = V.defaultProps, pe) he[ue] === void 0 && (he[ue] = pe[ue]);
    return { $$typeof: e, type: V, key: ge, ref: fe, props: he, _owner: j.current };
  function F(V, ie) {
    return { $$typeof: e, type: V.type, key: ie, ref: V.ref, props: V.props, _owner: V._owner };
  function D(V) {
    return typeof V == "object" && V !== null && V.$$typeof === e;
  function q(V) {
    return "$" + V.replace(/[=:]/g, function(de) {
  var U = /\/+/g;
  function K(V, ie) {
    return typeof V == "object" && V !== null && V.key != null ? q("" + V.key) : ie.toString(36);
  function ee(V, ie, de, ue, he) {
    var ge = typeof V;
    (ge === "undefined" || ge === "boolean") && (V = null);
    if (V === null) fe = !0;
        switch (V.$$typeof) {
    if (fe) return fe = V, he = he(fe), V = ue === "" ? "." + K(fe, 0) : ue, A(he) ? (de = "", V != null && (de = V.replace(U, "$&/") + "/"), ee(he, ie, de, "", function(we) {
    })) : he != null && (D(he) && (he = F(he, de + (!he.key || fe && fe.key === he.key ? "" : ("" + he.key).replace(U, "$&/") + "/") + V)), ie.push(he)), 1;
    if (fe = 0, ue = ue === "" ? "." : ue + ":", A(V)) for (var pe = 0; pe < V.length; pe++) {
      ge = V[pe];
      var be = ue + K(ge, pe);
    else if (be = w(V), typeof be == "function") for (V = be.call(V), pe = 0; !(ge = V.next()).done; ) ge = ge.value, be = ue + K(ge, pe++), fe += ee(ge, ie, de, be, he);
    else if (ge === "object") throw ie = String(V), Error("Objects are not valid as a React child (found: " + (ie === "[object Object]" ? "object with keys {" + Object.keys(V).join(", ") + "}" : ie) + "). If you meant to render a collection of children, use an array instead.");
  function G(V, ie, de) {
    if (V == null) return V;
    return ee(V, ue, "", "", function(ge) {
  function Y(V) {
    if (V._status === -1) {
      var ie = V._result;
        (V._status === 0 || V._status === -1) && (V._status = 1, V._result = de);
        (V._status === 0 || V._status === -1) && (V._status = 2, V._result = de);
      }), V._status === -1 && (V._status = 0, V._result = ie);
    if (V._status === 1) return V._result.default;
    throw V._result;
  var X = { current: null }, te = { transition: null }, re = { ReactCurrentDispatcher: X, ReactCurrentBatchConfig: te, ReactCurrentOwner: j };
  return Hn.Children = { map: G, forEach: function(V, ie, de) {
    G(V, function() {
  }, count: function(V) {
    return G(V, function() {
  }, toArray: function(V) {
    return G(V, function(ie) {
  }, only: function(V) {
    if (!D(V)) throw Error("React.Children.only expected to receive a single React element child.");
    return V;
  } }, Hn.Component = O, Hn.Fragment = n, Hn.Profiler = o, Hn.PureComponent = I, Hn.StrictMode = r, Hn.Suspense = f, Hn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = re, Hn.act = Q, Hn.cloneElement = function(V, ie, de) {
    if (V == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + V + ".");
    var ue = T({}, V.props), he = V.key, ge = V.ref, fe = V._owner;
      if (ie.ref !== void 0 && (ge = ie.ref, fe = j.current), ie.key !== void 0 && (he = "" + ie.key), V.type && V.type.defaultProps) var pe = V.type.defaultProps;
      for (be in ie) k.call(ie, be) && !B.hasOwnProperty(be) && (ue[be] = ie[be] === void 0 && pe !== void 0 ? pe[be] : ie[be]);
    return { $$typeof: e, type: V.type, key: he, ref: ge, props: ue, _owner: fe };
  }, Hn.createContext = function(V) {
    return V = { $$typeof: a, _currentValue: V, _currentValue2: V, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, V.Provider = { $$typeof: s, _context: V }, V.Consumer = V;
  }, Hn.createElement = H, Hn.createFactory = function(V) {
    var ie = H.bind(null, V);
    return ie.type = V, ie;
  }, Hn.createRef = function() {
  }, Hn.forwardRef = function(V) {
    return { $$typeof: c, render: V };
  }, Hn.isValidElement = D, Hn.lazy = function(V) {
    return { $$typeof: g, _payload: { _status: -1, _result: V }, _init: Y };
  }, Hn.memo = function(V, ie) {
    return { $$typeof: h, type: V, compare: ie === void 0 ? null : ie };
  }, Hn.startTransition = function(V) {
      V();
  }, Hn.unstable_act = Q, Hn.useCallback = function(V, ie) {
    return X.current.useCallback(V, ie);
  }, Hn.useContext = function(V) {
    return X.current.useContext(V);
  }, Hn.useDebugValue = function() {
  }, Hn.useDeferredValue = function(V) {
    return X.current.useDeferredValue(V);
  }, Hn.useEffect = function(V, ie) {
    return X.current.useEffect(V, ie);
  }, Hn.useId = function() {
  }, Hn.useImperativeHandle = function(V, ie, de) {
    return X.current.useImperativeHandle(V, ie, de);
  }, Hn.useInsertionEffect = function(V, ie) {
    return X.current.useInsertionEffect(V, ie);
  }, Hn.useLayoutEffect = function(V, ie) {
    return X.current.useLayoutEffect(V, ie);
  }, Hn.useMemo = function(V, ie) {
    return X.current.useMemo(V, ie);
  }, Hn.useReducer = function(V, ie, de) {
    return X.current.useReducer(V, ie, de);
  }, Hn.useRef = function(V) {
    return X.current.useRef(V);
  }, Hn.useState = function(V) {
    return X.current.useState(V);
  }, Hn.useSyncExternalStore = function(V, ie, de) {
    return X.current.useSyncExternalStore(V, ie, de);
  }, Hn.useTransition = function() {
  }, Hn.version = "18.3.1", Hn;
var oS = { exports: {} };
oS.exports;
var qL;
function tK() {
  return qL || (qL = 1, function(e, t) {
      var n = "18.3.1", r = Symbol.for("react.element"), o = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), h = Symbol.for("react.context"), g = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), w = Symbol.for("react.suspense_list"), C = Symbol.for("react.memo"), T = Symbol.for("react.lazy"), E = Symbol.for("react.offscreen"), O = Symbol.iterator, P = "@@iterator";
        var ve = O && ne[O] || ne[P];
      }, A = {
      }, k = {
      }, j = {
      }, B = {}, H = null;
      function F(ne) {
        H = ne;
      B.setExtraStackFrame = function(ne) {
        H = ne;
      }, B.getCurrentStack = null, B.getStackAddendum = function() {
        H && (ne += H);
        var ve = B.getCurrentStack;
      var D = !1, q = !1, U = !1, K = !1, ee = !1, G = {
        ReactCurrentBatchConfig: A,
        ReactCurrentOwner: j
      G.ReactDebugCurrentFrame = B, G.ReactCurrentActQueue = k;
      function Y(ne) {
      var V = {
        this.props = ne, this.context = ve, this.refs = de, this.updater = je || V;
              Y("%s(...) is deprecated in plain JavaScript React classes. %s", ve[0], ve[1]);
        this.props = ne, this.context = ve, this.refs = de, this.updater = je || V;
      function Le(ne) {
          case v:
            case h:
        if (typeof ne.ref == "string" && j.current && ne.__self && j.current.stateNode !== ne.__self) {
          var ve = wt(j.current.type);
        var sn = {
        return sn._store = {}, Object.defineProperty(sn._store, "validated", {
        }), Object.defineProperty(sn, "_self", {
        }), Object.defineProperty(sn, "_source", {
        }), Object.freeze && (Object.freeze(sn.props), Object.freeze(sn)), sn;
        var Ve, ht = {}, tn = null, _t = null, sn = null, An = null;
          Tt(ve) && (_t = ve.ref, Oe(ve)), At(ve) && (Le(ve.key), tn = "" + ve.key), sn = ve.__self === void 0 ? null : ve.__self, An = ve.__source === void 0 ? null : ve.__source;
        var Xn = arguments.length - 2;
        if (Xn === 1)
        else if (Xn > 1) {
          for (var Dr = Array(Xn), yr = 0; yr < Xn; yr++)
            Dr[yr] = arguments[yr + 2];
          Object.freeze && Object.freeze(Dr), ht.children = Dr;
          var Pn = ne.defaultProps;
          for (Ve in Pn)
            ht[Ve] === void 0 && (ht[Ve] = Pn[Ve]);
          var br = typeof ne == "function" ? ne.displayName || ne.name || "Unknown" : ne;
          tn && vt(ht, br), _t && Xe(ht, br);
        return Ie(ne, tn, _t, sn, An, j.current, ht);
        var Ve, ht = ie({}, ne.props), tn = ne.key, _t = ne.ref, sn = ne._self, An = ne._source, Xn = ne._owner;
          Tt(ve) && (_t = ve.ref, Xn = j.current), At(ve) && (Le(ve.key), tn = "" + ve.key);
          var Dr;
          ne.type && ne.type.defaultProps && (Dr = ne.type.defaultProps);
            gt.call(ve, Ve) && !nt.hasOwnProperty(Ve) && (ve[Ve] === void 0 && Dr !== void 0 ? ht[Ve] = Dr[Ve] : ht[Ve] = ve[Ve]);
        var yr = arguments.length - 2;
        if (yr === 1)
        else if (yr > 1) {
          for (var Pn = Array(yr), br = 0; br < yr; br++)
            Pn[br] = arguments[br + 2];
          ht.children = Pn;
        return Ie(ne.type, tn, _t, sn, An, Xn, ht);
      function Lt(ne) {
      var Cn = !1, pn = /\/+/g;
      function Or(ne) {
        return ne.replace(pn, "$&/");
      function lr(ne, ve) {
        return typeof ne == "object" && ne !== null && ne.key != null ? (Le(ne.key), Lt("" + ne.key)) : ve.toString(36);
      function Fr(ne, ve, je, Ve, ht) {
          var sn = ne, An = ht(sn), Xn = Ve === "" ? We + lr(sn, 0) : Ve;
          if (Ce(An)) {
            var Dr = "";
            Xn != null && (Dr = Or(Xn) + "/"), Fr(An, ve, Dr, "", function(Ny) {
              return Ny;
          } else An != null && (bt(An) && (An.key && (!sn || sn.key !== An.key) && Le(An.key), An = yt(
            An,
            (An.key && (!sn || sn.key !== An.key) ? (
              Or("" + An.key) + "/"
            ) : "") + Xn
          )), ve.push(An));
        var yr, Pn, br = 0, Xr = Ve === "" ? We : Ve + St;
          for (var Ru = 0; Ru < ne.length; Ru++)
            yr = ne[Ru], Pn = Xr + lr(yr, Ru), br += Fr(yr, ve, je, Pn, ht);
          var bp = I(ne);
          if (typeof bp == "function") {
            var $l = ne;
            bp === $l.entries && (Cn || Y("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Cn = !0);
            for (var wp = bp.call($l), Mc, Ay = 0; !(Mc = wp.next()).done; )
              yr = Mc.value, Pn = Xr + lr(yr, Ay++), br += Fr(yr, ve, je, Pn, ht);
            var Em = String(ne);
            throw new Error("Objects are not valid as a React child (found: " + (Em === "[object Object]" ? "object with keys {" + Object.keys(ne).join(", ") + "}" : Em) + "). If you meant to render a collection of children, use an array instead.");
        return br;
      function Rr(ne, ve, je) {
        return Fr(ne, Ve, "", "", function(tn) {
      function Qo(ne) {
        return Rr(ne, function() {
      function Jo(ne, ve, je) {
        Rr(ne, function() {
        return Rr(ne, function(ve) {
      function gr(ne) {
      function Zo(ne) {
          $$typeof: h,
            $$typeof: h,
                ht || (Y("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", _t), ht = !0);
      var Kr = -1, so = 0, Yr = 1, Yi = 2;
      function ki(ne) {
        if (ne._status === Kr) {
            if (ne._status === so || ne._status === Kr) {
              _t._status = Yr, _t._result = tn;
            if (ne._status === so || ne._status === Kr) {
              _t._status = Yi, _t._result = tn;
          }), ne._status === Kr) {
            Ve._status = so, Ve._result = je;
        if (ne._status === Yr) {
      function Xi(ne) {
          _status: Kr,
          _init: ki
      function Qi(ne) {
        return !!(typeof ne == "string" || typeof ne == "function" || ne === s || ne === c || ee || ne === a || ne === v || ne === w || K || ne === E || D || q || U || typeof ne == "object" && ne !== null && (ne.$$typeof === T || ne.$$typeof === C || ne.$$typeof === f || ne.$$typeof === h || ne.$$typeof === g || // This needs to include all possible module reference object
      function hn(ne) {
      function kr(ne, ve) {
      function ei(ne, ve, je) {
      function wn(ne, ve) {
      function xn() {
      function bi(ne) {
      function As() {
      function Dn(ne, ve, je) {
      var Io = 0, Pi, Ji, wi, mp, Mi, Cm, xm;
      function Nd() {
      Nd.__reactDisabledLog = !0;
      function xu() {
          if (Io === 0) {
            Pi = console.log, Ji = console.info, wi = console.warn, mp = console.error, Mi = console.group, Cm = console.groupCollapsed, xm = console.groupEnd;
              value: Nd,
          Io++;
      function bs() {
          if (Io--, Io === 0) {
                value: Pi
                value: Ji
                value: wi
                value: mp
                value: Mi
                value: Cm
                value: xm
          Io < 0 && X("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      var ha = G.ReactCurrentDispatcher, ma;
      function $d(ne, ve, je) {
          if (ma === void 0)
              ma = Ve && Ve[1] || "";
` + ma + ne;
      var Oc = !1, Eu;
        var Ld = typeof WeakMap == "function" ? WeakMap : Map;
        Eu = new Ld();
      function jd(ne, ve) {
        if (!ne || Oc)
          var je = Eu.get(ne);
        Oc = !0;
        tn = ha.current, ha.current = null, xu();
              } catch (Xr) {
                Ve = Xr;
              } catch (Xr) {
                Ve = Xr;
            } catch (Xr) {
              Ve = Xr;
        } catch (Xr) {
          if (Xr && Ve && typeof Xr.stack == "string") {
            for (var sn = Xr.stack.split(`
`), An = Ve.stack.split(`
`), Xn = sn.length - 1, Dr = An.length - 1; Xn >= 1 && Dr >= 0 && sn[Xn] !== An[Dr]; )
              Dr--;
            for (; Xn >= 1 && Dr >= 0; Xn--, Dr--)
              if (sn[Xn] !== An[Dr]) {
                if (Xn !== 1 || Dr !== 1)
                    if (Xn--, Dr--, Dr < 0 || sn[Xn] !== An[Dr]) {
                      var yr = `
` + sn[Xn].replace(" at new ", " at ");
                      return ne.displayName && yr.includes("<anonymous>") && (yr = yr.replace("<anonymous>", ne.displayName)), typeof ne == "function" && Eu.set(ne, yr), yr;
                  while (Xn >= 1 && Dr >= 0);
          Oc = !1, ha.current = tn, bs(), Error.prepareStackTrace = ht;
        var Pn = ne ? ne.displayName || ne.name : "", br = Pn ? $d(Pn) : "";
        return typeof ne == "function" && Eu.set(ne, br), br;
      function Al(ne, ve, je) {
        return jd(ne, !1);
      function Iy(ne) {
      function Nl(ne, ve, je) {
          return jd(ne, Iy(ne));
          return $d(ne);
          case v:
            return $d("Suspense");
            return $d("SuspenseList");
              return Al(ne.render);
              return Nl(ne.type, ve, je);
                return Nl(tn(ht), ve, je);
      var er = {}, Fd = G.ReactDebugCurrentFrame;
      function Yn(ne) {
          var ve = ne._owner, je = Nl(ne.type, ne._source, ve ? ve.type : null);
          Fd.setExtraStackFrame(je);
          Fd.setExtraStackFrame(null);
      function gp(ne, ve, je, Ve, ht) {
              var sn = void 0;
                  var An = Error((Ve || "React class") + ": " + je + " type `" + _t + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ne[_t] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw An.name = "Invariant Violation", An;
                sn = ne[_t](ve, _t, Ve, je, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Xn) {
                sn = Xn;
              sn && !(sn instanceof Error) && (Yn(ht), X("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ve || "React class", je, _t, typeof sn), Yn(null)), sn instanceof Error && !(sn.message in er) && (er[sn.message] = !0, Yn(ht), X("Failed %s type: %s", je, sn.message), Yn(null));
      function Ha(ne) {
          var ve = ne._owner, je = Nl(ne.type, ne._source, ve ? ve.type : null);
          F(je);
          F(null);
      var yn;
      yn = !1;
      function zd() {
        if (j.current) {
          var ne = wt(j.current.type);
      function ti(ne) {
      function Va(ne) {
        return ne != null ? ti(ne.__source) : "";
      var Ii = {};
      function Ua(ne) {
        var ve = zd();
      function zr(ne, ve) {
          var je = Ua(ve);
          if (!Ii[je]) {
            Ii[je] = !0;
            ne && ne._owner && ne._owner !== j.current && (Ve = " It was passed a child from " + wt(ne._owner.type) + "."), Ha(ne), X('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', je, Ve), Ha(null);
      function vr(ne, ve) {
              bt(Ve) && zr(Ve, ve);
                bt(_t.value) && zr(_t.value, ve);
      function Tu(ne) {
            gp(je, ne.props, "prop", Ve, ne);
          } else if (ve.PropTypes !== void 0 && !yn) {
            yn = !0;
      function Do(ne) {
              Ha(ne), X("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ve), Ha(null);
          ne.ref !== null && (Ha(ne), X("Invalid attribute `ref` supplied to `React.Fragment`."), Ha(null));
      function Di(ne, ve, je) {
          var tn = Va(ve);
          tn ? ht += tn : ht += zd();
        var sn = pt.apply(this, arguments);
        if (sn == null)
          return sn;
          for (var An = 2; An < arguments.length; An++)
            vr(arguments[An], ne);
        return ne === s ? Do(sn) : Tu(sn), sn;
      }
      var Ns = !1;
      function Rc(ne) {
        var ve = Di.bind(null, ne);
        return ve.type = ne, Ns || (Ns = !0, Y("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(ve, "type", {
            return Y("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
      function vp(ne, ve, je) {
          vr(arguments[ht], Ve.type);
        return Tu(Ve), Ve;
      }
      function yp(ne, ve) {
        var je = A.transition;
        A.transition = {};
        var Ve = A.transition;
        A.transition._updatedFibers = /* @__PURE__ */ new Set();
          if (A.transition = je, je === null && Ve._updatedFibers) {
            ht > 10 && Y("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ve._updatedFibers.clear();
      var _u = !1, kc = null;
      function Dy(ne) {
        if (kc === null)
            kc = je.call(e, "timers").setImmediate;
            kc = function(ht) {
              _u === !1 && (_u = !0, typeof MessageChannel > "u" && X("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
        return kc(ne);
      var $s = 0, ga = !1;
      function Wa(ne) {
          var ve = $s;
          $s++, k.current === null && (k.current = []);
          var je = k.isBatchingLegacy, Ve;
            if (k.isBatchingLegacy = !0, Ve = ne(), !je && k.didScheduleLegacyUpdate) {
              var ht = k.current;
              ht !== null && (k.didScheduleLegacyUpdate = !1, Ou(ht));
          } catch (Pn) {
            throw Ls(ve), Pn;
            k.isBatchingLegacy = je;
            var tn = Ve, _t = !1, sn = {
              then: function(Pn, br) {
                _t = !0, tn.then(function(Xr) {
                  Ls(ve), $s === 0 ? Bd(Xr, Pn, br) : Pn(Xr);
                }, function(Xr) {
                  Ls(ve), br(Xr);
            return !ga && typeof Promise < "u" && Promise.resolve().then(function() {
              _t || (ga = !0, X("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), sn;
            var An = Ve;
            if (Ls(ve), $s === 0) {
              var Xn = k.current;
              Xn !== null && (Ou(Xn), k.current = null);
              var Dr = {
                then: function(Pn, br) {
                  k.current === null ? (k.current = [], Bd(An, Pn, br)) : Pn(An);
              return Dr;
              var yr = {
                then: function(Pn, br) {
                  Pn(An);
              return yr;
        ne !== $s - 1 && X("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), $s = ne;
      function Bd(ne, ve, je) {
          var Ve = k.current;
              Ou(Ve), Dy(function() {
                Ve.length === 0 ? (k.current = null, ve(ne)) : Bd(ne, ve, je);
      var Hd = !1;
      function Ou(ne) {
        if (!Hd) {
          Hd = !0;
            Hd = !1;
      var Pc = Di, Vd = vp, Ud = Rc, va = {
        map: Rr,
        forEach: Jo,
        count: Qo,
        only: gr
      t.Children = va, t.Component = ue, t.Fragment = s, t.Profiler = c, t.PureComponent = be, t.StrictMode = a, t.Suspense = v, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = G, t.act = Wa, t.cloneElement = Vd, t.createContext = Zo, t.createElement = Pc, t.createFactory = Ud, t.createRef = _e, t.forwardRef = Qi, t.isValidElement = bt, t.lazy = Xi, t.memo = ft, t.startTransition = yp, t.unstable_act = Wa, t.useCallback = Ln, t.useContext = hn, t.useDebugValue = wn, t.useDeferredValue = bi, t.useEffect = Bt, t.useId = As, t.useImperativeHandle = ei, t.useInsertionEffect = jt, t.useLayoutEffect = Kt, t.useMemo = kr, t.useReducer = Re, t.useRef = Je, t.useState = De, t.useSyncExternalStore = Dn, t.useTransition = xn, t.version = n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }(oS, oS.exports)), oS.exports;
process.env.NODE_ENV === "production" ? QP.exports = eK() : QP.exports = tK();
var x = QP.exports;
const pu = /* @__PURE__ */ vI(x), RT = /* @__PURE__ */ J9({
  default: pu
var KL;
function nK() {
  if (KL) return Lw;
  KL = 1;
  function a(c, f, h) {
    var g, v = {}, w = null, C = null;
    h !== void 0 && (w = "" + h), f.key !== void 0 && (w = "" + f.key), f.ref !== void 0 && (C = f.ref);
    for (g in f) r.call(f, g) && !s.hasOwnProperty(g) && (v[g] = f[g]);
    if (c && c.defaultProps) for (g in f = c.defaultProps, f) v[g] === void 0 && (v[g] = f[g]);
    return { $$typeof: t, type: c, key: w, ref: C, props: v, _owner: o.current };
  return Lw.Fragment = n, Lw.jsx = a, Lw.jsxs = a, Lw;
var jw = {};
var YL;
function rK() {
  return YL || (YL = 1, process.env.NODE_ENV !== "production" && function() {
    var e = x, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), c = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), T = Symbol.iterator, E = "@@iterator";
    var P = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var Ct = P.ReactDebugCurrentFrame, hn = Ct.getStackAddendum();
        hn !== "" && (Ye += "%s", ft = ft.concat([hn]));
    var A = !1, k = !1, j = !1, B = !1, H = !1, F;
    F = Symbol.for("react.module.reference");
    function D(ye) {
      return !!(typeof ye == "string" || typeof ye == "function" || ye === r || ye === s || H || ye === o || ye === h || ye === g || B || ye === C || A || k || j || typeof ye == "object" && ye !== null && (ye.$$typeof === w || ye.$$typeof === v || ye.$$typeof === a || ye.$$typeof === c || ye.$$typeof === f || // This needs to include all possible module reference object
      ye.$$typeof === F || ye.getModuleId !== void 0));
      var hn = Ye.displayName || Ye.name || "";
      return hn !== "" ? ft + "(" + hn + ")" : ft;
    function U(ye) {
    function K(ye) {
        case h:
            return U(Ye) + ".Consumer";
            return U(ft._context) + ".Provider";
          case v:
            return Ct !== null ? Ct : K(ye.type) || "Memo";
            var hn = ye, De = hn._payload, Re = hn._init;
              return K(Re(De));
    var ee = Object.assign, G = 0, Y, X, te, re, Q, V, ie;
          Y = console.log, X = console.info, te = console.warn, re = console.error, Q = console.group, V = console.groupCollapsed, ie = console.groupEnd;
              value: Y
              value: V
    var ge = P.ReactCurrentDispatcher, fe;
          } catch (hn) {
            var Ct = hn.stack.trim().match(/\n( *(at )?)/);
      var hn = Error.prepareStackTrace;
            } catch (wn) {
              Ct = wn;
            } catch (wn) {
              Ct = wn;
          } catch (wn) {
            Ct = wn;
      } catch (wn) {
        if (wn && Ct && typeof wn.stack == "string") {
          for (var Je = wn.stack.split(`
        be = !1, ge.current = De, he(), Error.prepareStackTrace = hn;
      var kr = ye ? ye.displayName || ye.name : "", ei = kr ? pe(kr) : "";
      return typeof ye == "function" && we.set(ye, ei), ei;
        case h:
          case v:
            var Ct = ye, hn = Ct._payload, De = Ct._init;
              return Be(De(hn), Ye, ft);
    var tt = Object.prototype.hasOwnProperty, Le = {}, rt = P.ReactDebugCurrentFrame;
    function wt(ye, Ye, ft, Ct, hn) {
            Je && !(Je instanceof Error) && (ot(hn), I("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ct || "React class", ft, Re, typeof Je), ot(null)), Je instanceof Error && !(Je.message in Le) && (Le[Je.message] = !0, ot(hn), I("Failed %s type: %s", ft, Je.message), ot(null));
    var At = P.ReactCurrentOwner, vt = {
    var We = function(ye, Ye, ft, Ct, hn, De, Re) {
        value: hn
    function St(ye, Ye, ft, Ct, hn) {
        ft !== void 0 && (Tt(ft), Je = "" + ft), pt(Ye) && (Tt(Ye.key), Je = "" + Ye.key), Ie(Ye) && (Bt = Ye.ref, yt(Ye, hn));
        return We(ye, Je, Bt, hn, Ct, At.current, Re);
    var Lt = P.ReactCurrentOwner, Cn = P.ReactDebugCurrentFrame;
    function pn(ye) {
        Cn.setExtraStackFrame(ft);
        Cn.setExtraStackFrame(null);
    var Or;
    Or = !1;
    function lr(ye) {
    function Fr() {
        if (Lt.current) {
          var ye = K(Lt.current.type);
    function Rr(ye) {
    var Qo = {};
    function Jo(ye) {
        var Ye = Fr();
        var ft = Jo(Ye);
        if (Qo[ft])
        Qo[ft] = !0;
        ye && ye._owner && ye._owner !== Lt.current && (Ct = " It was passed a child from " + K(ye._owner.type) + "."), pn(ye), I('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ft, Ct), pn(null);
    function gr(ye, Ye) {
            lr(Ct) && Wt(Ct, Ye);
        else if (lr(ye))
          var hn = O(ye);
          if (typeof hn == "function" && hn !== ye.entries)
            for (var De = hn.call(ye), Re; !(Re = De.next()).done; )
              lr(Re.value) && Wt(Re.value, Ye);
    function Zo(ye) {
        Ye.$$typeof === v))
          var Ct = K(Ye);
        } else if (Ye.PropTypes !== void 0 && !Or) {
          Or = !0;
          var hn = K(Ye);
          I("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", hn || "Unknown");
    function Kr(ye) {
            pn(ye), I("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ct), pn(null);
        ye.ref !== null && (pn(ye), I("Invalid attribute `ref` supplied to `React.Fragment`."), pn(null));
    var so = {};
    function Yr(ye, Ye, ft, Ct, hn, De) {
        var Re = D(ye);
          var Bt = Rr();
          Bt ? Je += Bt : Je += Fr();
          ye === null ? jt = "null" : nt(ye) ? jt = "array" : ye !== void 0 && ye.$$typeof === t ? (jt = "<" + (K(ye.type) || "Unknown") + " />", Je = " Did you accidentally export a JSX literal instead of a component?") : jt = typeof ye, I("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", jt, Je);
        var Kt = St(ye, Ye, ft, hn, De);
                for (var kr = 0; kr < Ln.length; kr++)
                  gr(Ln[kr], ye);
              gr(Ln, ye);
          var ei = K(ye), wn = Object.keys(Ye).filter(function(As) {
            return As !== "key";
          }), xn = wn.length > 0 ? "{key: someKey, " + wn.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!so[ei + xn]) {
            var bi = wn.length > 0 ? "{" + wn.join(": ..., ") + ": ...}" : "{}";
  <%s key={someKey} {...props} />`, xn, ei, bi, ei), so[ei + xn] = !0;
        return ye === r ? Kr(Kt) : Zo(Kt), Kt;
    function Yi(ye, Ye, ft) {
      return Yr(ye, Ye, ft, !0);
    function ki(ye, Ye, ft) {
      return Yr(ye, Ye, ft, !1);
    var Xi = ki, Qi = Yi;
    jw.Fragment = r, jw.jsx = Xi, jw.jsxs = Qi;
  }()), jw;
process.env.NODE_ENV === "production" ? XP.exports = nK() : XP.exports = rK();
var $ = XP.exports, iS = {}, JP = { exports: {} }, Zs = {}, RE = { exports: {} }, Yk = {};
var XL;
function oK() {
  return XL || (XL = 1, function(e) {
        var V = Q - 1 >>> 1, ie = te[V];
        if (0 < o(ie, re)) te[V] = re, te[Q] = ie, Q = V;
        e: for (var V = 0, ie = te.length, de = ie >>> 1; V < de; ) {
          var ue = 2 * (V + 1) - 1, he = te[ue], ge = ue + 1, fe = te[ge];
          if (0 > o(he, Q)) ge < ie && 0 > o(fe, he) ? (te[V] = fe, te[ge] = Q, V = ge) : (te[V] = he, te[ue] = Q, V = ue);
          else if (ge < ie && 0 > o(fe, Q)) te[V] = fe, te[ge] = Q, V = ge;
    var f = [], h = [], g = 1, v = null, w = 3, C = !1, T = !1, E = !1, O = typeof setTimeout == "function" ? setTimeout : null, P = typeof clearTimeout == "function" ? clearTimeout : null, I = typeof setImmediate < "u" ? setImmediate : null;
      for (var re = n(h); re !== null; ) {
        if (re.callback === null) r(h);
        else if (re.startTime <= te) r(h), re.sortIndex = re.expirationTime, t(f, re);
        re = n(h);
    function A(te) {
      if (E = !1, M(te), !T) if (n(f) !== null) T = !0, Y(k);
        var re = n(h);
        re !== null && X(A, re.startTime - te);
    function k(te, re) {
      T = !1, E && (E = !1, P(H), H = -1), C = !0;
        for (M(re), v = n(f); v !== null && (!(v.expirationTime > re) || te && !q()); ) {
          var V = v.callback;
          if (typeof V == "function") {
            v.callback = null, w = v.priorityLevel;
            var ie = V(v.expirationTime <= re);
            re = e.unstable_now(), typeof ie == "function" ? v.callback = ie : v === n(f) && r(f), M(re);
          v = n(f);
        if (v !== null) var de = !0;
          var ue = n(h);
          ue !== null && X(A, ue.startTime - re), de = !1;
        v = null, w = Q, C = !1;
    var j = !1, B = null, H = -1, F = 5, D = -1;
      return !(e.unstable_now() - D < F);
    function U() {
      if (B !== null) {
        D = te;
          re = B(!0, te);
          re ? K() : (j = !1, B = null);
      } else j = !1;
    var K;
    if (typeof I == "function") K = function() {
      I(U);
      ee.port1.onmessage = U, K = function() {
    } else K = function() {
      O(U, 0);
    function Y(te) {
      B = te, j || (j = !0, K());
      H = O(function() {
      T || C || (T = !0, Y(k));
      0 > te || 125 < te ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < te ? Math.floor(1e3 / te) : 5;
      var V = e.unstable_now();
      switch (typeof Q == "object" && Q !== null ? (Q = Q.delay, Q = typeof Q == "number" && 0 < Q ? V + Q : V) : Q = V, te) {
      return ie = Q + ie, te = { id: g++, callback: re, priorityLevel: te, startTime: Q, expirationTime: ie, sortIndex: -1 }, Q > V ? (te.sortIndex = Q, t(h, te), n(f) === null && te === n(h) && (E ? (P(H), H = -1) : E = !0, X(A, Q - V))) : (te.sortIndex = ie, t(f, te), T || C || (T = !0, Y(k))), te;
  }(Yk)), Yk;
var Xk = {};
var QL;
function iK() {
  return QL || (QL = 1, function(e) {
          var We = (yt + 1) * 2 - 1, St = Oe[We], Lt = We + 1, Cn = Oe[Lt];
            Lt < zt && f(Cn, St) < 0 ? (Oe[yt] = Cn, Oe[Lt] = Ie, yt = Lt) : (Oe[yt] = St, Oe[We] = Ie, yt = We);
          else if (Lt < zt && f(Cn, Ie) < 0)
            Oe[yt] = Cn, Oe[Lt] = Ie, yt = Lt;
      var h = 1, g = 2, v = 3, w = 4, C = 5;
        var P = Date, I = P.now();
          return P.now() - I;
      var M = 1073741823, A = -1, k = 250, j = 5e3, B = 1e4, H = M, F = [], D = [], q = 1, U = null, K = v, ee = !1, G = !1, Y = !1, X = typeof setTimeout == "function" ? setTimeout : null, te = typeof clearTimeout == "function" ? clearTimeout : null, re = typeof setImmediate < "u" ? setImmediate : null;
        for (var Ie = o(D); Ie !== null; ) {
            s(D);
            s(D), Ie.sortIndex = Ie.expirationTime, r(F, Ie);
          Ie = o(D);
      function V(Oe) {
        if (Y = !1, Q(Oe), !G)
          if (o(F) !== null)
            var Ie = o(D);
            Ie !== null && Tt(V, Ie.startTime - Oe);
        G = !1, Y && (Y = !1, At()), ee = !0;
        var pt = K;
          U = null, K = pt, ee = !1;
        for (Q(pt), U = o(F); U !== null && !(U.expirationTime > pt && (!Oe || rt())); ) {
          var yt = U.callback;
            U.callback = null, K = U.priorityLevel;
            var zt = U.expirationTime <= pt, bt = yt(zt);
            pt = e.unstable_now(), typeof bt == "function" ? U.callback = bt : U === o(F) && s(F), Q(pt);
            s(F);
          U = o(F);
        if (U !== null)
        var We = o(D);
        return We !== null && Tt(V, We.startTime - pt), !1;
          case h:
          case v:
            Oe = v;
        var pt = K;
        K = Oe;
          K = pt;
        switch (K) {
          case h:
          case v:
            Ie = v;
            Ie = K;
        var pt = K;
        K = Ie;
          K = pt;
        var Ie = K;
          var pt = K;
          K = Ie;
            K = pt;
          case h:
            We = A;
            We = k;
            We = H;
            We = B;
          case v:
            We = j;
        var St = zt + We, Lt = {
        return zt > yt ? (Lt.sortIndex = zt, r(D, Lt), o(F) === null && Lt === o(D) && (Y ? At() : Y = !0, Tt(V, zt - yt))) : (Lt.sortIndex = St, r(F, Lt), !G && !ee && (G = !0, Et(ie))), Lt;
        return o(F);
        return K;
      var Ce = !1, Ne = null, Be = -1, tt = n, Le = -1;
        var Oe = e.unstable_now() - Le;
          Le = Oe;
      e.unstable_IdlePriority = C, e.unstable_ImmediatePriority = h, e.unstable_LowPriority = w, e.unstable_NormalPriority = v, e.unstable_Profiling = Xe, e.unstable_UserBlockingPriority = g, e.unstable_cancelCallback = _e, e.unstable_continueExecution = be, e.unstable_forceFrameRate = wt, e.unstable_getCurrentPriorityLevel = ce, e.unstable_getFirstCallbackNode = we, e.unstable_next = he, e.unstable_pauseExecution = pe, e.unstable_requestPaint = vt, e.unstable_runWithPriority = ue, e.unstable_scheduleCallback = fe, e.unstable_shouldYield = rt, e.unstable_wrapCallback = ge, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }(Xk)), Xk;
var JL;
function JB() {
  return JL || (JL = 1, process.env.NODE_ENV === "production" ? RE.exports = oK() : RE.exports = iK()), RE.exports;
var ZL;
function sK() {
  if (ZL) return Zs;
  ZL = 1;
  var e = x, t = JB();
  var c = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), f = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, g = {}, v = {};
    return f.call(v, d) ? !0 : f.call(g, d) ? !1 : h.test(d) ? v[d] = !0 : (g[d] = !0, !1);
  function E(d, p, b, _, N, z, oe) {
    this.acceptsBooleans = p === 2 || p === 3 || p === 4, this.attributeName = _, this.attributeNamespace = N, this.mustUseProperty = b, this.propertyName = d, this.type = p, this.sanitizeURL = z, this.removeEmptyString = oe;
  var P = /[\-:]([a-z])/g;
      P,
    var p = d.replace(P, I);
    var p = d.replace(P, I);
    var N = O.hasOwnProperty(p) ? O[p] : null;
    (N !== null ? N.type !== 0 : _ || !(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (T(p, b, N, _) && (b = null), _ || N === null ? w(p) && (b === null ? d.removeAttribute(p) : d.setAttribute(p, "" + b)) : N.mustUseProperty ? d[N.propertyName] = b === null ? N.type === 3 ? !1 : "" : b : (p = N.attributeName, _ = N.attributeNamespace, b === null ? d.removeAttribute(p) : (N = N.type, b = N === 3 || N === 4 && b === !0 ? "" : "" + b, _ ? d.setAttributeNS(_, p, b) : d.setAttribute(p, b))));
  var A = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, k = Symbol.for("react.element"), j = Symbol.for("react.portal"), B = Symbol.for("react.fragment"), H = Symbol.for("react.strict_mode"), F = Symbol.for("react.profiler"), D = Symbol.for("react.provider"), q = Symbol.for("react.context"), U = Symbol.for("react.forward_ref"), K = Symbol.for("react.suspense"), ee = Symbol.for("react.suspense_list"), G = Symbol.for("react.memo"), Y = Symbol.for("react.lazy"), X = Symbol.for("react.offscreen"), te = Symbol.iterator;
  var Q = Object.assign, V;
    if (V === void 0) try {
      V = p && p[1] || "";
` + V + d;
        for (var N = Fe.stack.split(`
`), z = _.stack.split(`
`), oe = N.length - 1, me = z.length - 1; 1 <= oe && 0 <= me && N[oe] !== z[me]; ) me--;
        for (; 1 <= oe && 0 <= me; oe--, me--) if (N[oe] !== z[me]) {
              if (oe--, me--, 0 > me || N[oe] !== z[me]) {
` + N[oe].replace(" at new ", " at ");
      case B:
      case j:
      case F:
      case H:
      case K:
      case D:
      case U:
      case Y:
        return p === H ? "StrictMode" : "Mode";
      var N = b.get, z = b.set;
        return N.call(this);
        _ = "" + oe, z.call(this, oe);
  function Le(d, p) {
      for (var N = 0; N < b.length; N++) p["$" + b[N]] = !0;
      for (b = 0; b < d.length; b++) N = p.hasOwnProperty("$" + d[b].value), d[b].selected !== N && (d[b].selected = N), N && _ && (d[b].defaultSelected = !0);
      for (b = "" + pe(b), p = null, N = 0; N < d.length; N++) {
        if (d[N].value === b) {
          d[N].selected = !0, _ && (d[N].defaultSelected = !0);
        p !== null || d[N].disabled || (p = d[N]);
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(p, b, _, N) {
        return d(p, b, _, N);
      var _ = b.indexOf("--") === 0, N = yt(b, p[b], _);
      b === "float" && (b = "cssFloat"), _ ? d.setProperty(b, N) : d[b] = N;
  var Lt = null;
  function Cn(d) {
  var pn = null, Or = null, lr = null;
  function Fr(d) {
      if (typeof pn != "function") throw Error(n(280));
      p && (p = Qr(p), pn(d.stateNode, d.type, p));
  function Rr(d) {
    Or ? lr ? lr.push(d) : lr = [d] : Or = d;
  function Qo() {
    if (Or) {
      var d = Or, p = lr;
      if (lr = Or = null, Fr(d), p) for (d = 0; d < p.length; d++) Fr(p[d]);
  function Jo(d, p) {
  var gr = !1;
  function Zo(d, p, b) {
    if (gr) return d(p, b);
    gr = !0;
      return Jo(d, p, b);
      gr = !1, (Or !== null || lr !== null) && (Wt(), Qo());
  function Kr(d, p) {
    var _ = Qr(b);
  var so = !1;
    var Yr = {};
    Object.defineProperty(Yr, "passive", { get: function() {
      so = !0;
    } }), window.addEventListener("test", Yr, Yr), window.removeEventListener("test", Yr, Yr);
    so = !1;
  function Yi(d, p, b, _, N, z, oe, me, Se) {
  var ki = !1, Xi = null, Qi = !1, ye = null, Ye = { onError: function(d) {
    ki = !0, Xi = d;
  function ft(d, p, b, _, N, z, oe, me, Se) {
    ki = !1, Xi = null, Yi.apply(Ye, arguments);
  }
  function Ct(d, p, b, _, N, z, oe, me, Se) {
    if (ft.apply(this, arguments), ki) {
      if (ki) {
        var Fe = Xi;
        ki = !1, Xi = null;
      Qi || (Qi = !0, ye = Fe);
  function hn(d) {
    if (hn(d) !== d) throw Error(n(188));
      if (p = hn(d), p === null) throw Error(n(188));
      var N = b.return;
      if (N === null) break;
      var z = N.alternate;
      if (z === null) {
        if (_ = N.return, _ !== null) {
      if (N.child === z.child) {
        for (z = N.child; z; ) {
          if (z === b) return Re(N), d;
          if (z === _) return Re(N), p;
          z = z.sibling;
      if (b.return !== _.return) b = N, _ = z;
        for (var oe = !1, me = N.child; me; ) {
            oe = !0, b = N, _ = z;
            oe = !0, _ = N, b = z;
          for (me = z.child; me; ) {
              oe = !0, b = z, _ = N;
              oe = !0, _ = z, b = N;
  var Kt = t.unstable_scheduleCallback, Ln = t.unstable_cancelCallback, kr = t.unstable_shouldYield, ei = t.unstable_requestPaint, wn = t.unstable_now, xn = t.unstable_getCurrentPriorityLevel, bi = t.unstable_ImmediatePriority, As = t.unstable_UserBlockingPriority, Dn = t.unstable_NormalPriority, Io = t.unstable_LowPriority, Pi = t.unstable_IdlePriority, Ji = null, wi = null;
  function mp(d) {
    if (wi && typeof wi.onCommitFiberRoot == "function") try {
      wi.onCommitFiberRoot(Ji, d, void 0, (d.current.flags & 128) === 128);
  var Mi = Math.clz32 ? Math.clz32 : Nd, Cm = Math.log, xm = Math.LN2;
  function Nd(d) {
    return d >>>= 0, d === 0 ? 32 : 31 - (Cm(d) / xm | 0) | 0;
  var xu = 64, bs = 4194304;
  function ha(d) {
  function ma(d, p) {
    var _ = 0, N = d.suspendedLanes, z = d.pingedLanes, oe = b & 268435455;
      var me = oe & ~N;
      me !== 0 ? _ = ha(me) : (z &= oe, z !== 0 && (_ = ha(z)));
    } else oe = b & ~N, oe !== 0 ? _ = ha(oe) : z !== 0 && (_ = ha(z));
    if (p !== 0 && p !== _ && !(p & N) && (N = _ & -_, z = p & -p, N >= z || N === 16 && (z & 4194240) !== 0)) return p;
    if (_ & 4 && (_ |= b & 16), p = d.entangledLanes, p !== 0) for (d = d.entanglements, p &= _; 0 < p; ) b = 31 - Mi(p), N = 1 << b, _ |= d[b], p &= ~N;
  function $d(d, p) {
  function Oc(d, p) {
    for (var b = d.suspendedLanes, _ = d.pingedLanes, N = d.expirationTimes, z = d.pendingLanes; 0 < z; ) {
      var oe = 31 - Mi(z), me = 1 << oe, Se = N[oe];
      Se === -1 ? (!(me & b) || me & _) && (N[oe] = $d(me, p)) : Se <= p && (d.expiredLanes |= me), z &= ~me;
  function Eu(d) {
  function Ld() {
    var d = xu;
    return xu <<= 1, !(xu & 4194240) && (xu = 64), d;
  function jd(d) {
  function Al(d, p, b) {
    d.pendingLanes |= p, p !== 536870912 && (d.suspendedLanes = 0, d.pingedLanes = 0), d = d.eventTimes, p = 31 - Mi(p), d[p] = b;
  function Iy(d, p) {
      var N = 31 - Mi(b), z = 1 << N;
      p[N] = 0, _[N] = -1, d[N] = -1, b &= ~z;
  function Nl(d, p) {
      var _ = 31 - Mi(b), N = 1 << _;
      N & p | d[_] & p && (d[_] |= p), b &= ~N;
  var er = 0;
  function Fd(d) {
  var Yn, gp, Ha, yn, zd, ti = !1, Va = [], Ii = null, Ua = null, zr = null, vr = /* @__PURE__ */ new Map(), Tu = /* @__PURE__ */ new Map(), Do = [], Di = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Ns(d, p) {
        Ii = null;
        Ua = null;
        zr = null;
        vr.delete(p.pointerId);
        Tu.delete(p.pointerId);
  function Rc(d, p, b, _, N, z) {
    return d === null || d.nativeEvent !== z ? (d = { blockedOn: p, domEventName: b, eventSystemFlags: _, nativeEvent: z, targetContainers: [N] }, p !== null && (p = Qt(p), p !== null && gp(p)), d) : (d.eventSystemFlags |= _, p = d.targetContainers, N !== null && p.indexOf(N) === -1 && p.push(N), d);
  function vp(d, p, b, _, N) {
        return Ii = Rc(Ii, d, p, b, _, N), !0;
        return Ua = Rc(Ua, d, p, b, _, N), !0;
        return zr = Rc(zr, d, p, b, _, N), !0;
        var z = N.pointerId;
        return vr.set(z, Rc(vr.get(z) || null, d, p, b, _, N)), !0;
        return z = N.pointerId, Tu.set(z, Rc(Tu.get(z) || null, d, p, b, _, N)), !0;
  function yp(d) {
    var p = Lc(d.target);
      var b = hn(p);
            d.blockedOn = p, zd(d.priority, function() {
              Ha(b);
  function _u(d) {
      var b = Vd(d.domEventName, d.eventSystemFlags, p[0], d.nativeEvent);
        Lt = _, b.target.dispatchEvent(_), Lt = null;
      } else return p = Qt(b), p !== null && gp(p), d.blockedOn = b, !1;
  function kc(d, p, b) {
    _u(d) && b.delete(p);
  function Dy() {
    ti = !1, Ii !== null && _u(Ii) && (Ii = null), Ua !== null && _u(Ua) && (Ua = null), zr !== null && _u(zr) && (zr = null), vr.forEach(kc), Tu.forEach(kc);
  function $s(d, p) {
    d.blockedOn === p && (d.blockedOn = null, ti || (ti = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, Dy)));
  function ga(d) {
    function p(N) {
      return $s(N, d);
    if (0 < Va.length) {
      $s(Va[0], d);
      for (var b = 1; b < Va.length; b++) {
        var _ = Va[b];
    for (Ii !== null && $s(Ii, d), Ua !== null && $s(Ua, d), zr !== null && $s(zr, d), vr.forEach(p), Tu.forEach(p), b = 0; b < Do.length; b++) _ = Do[b], _.blockedOn === d && (_.blockedOn = null);
    for (; 0 < Do.length && (b = Do[0], b.blockedOn === null); ) yp(b), b.blockedOn === null && Do.shift();
  var Wa = A.ReactCurrentBatchConfig, Ls = !0;
  function Bd(d, p, b, _) {
    var N = er, z = Wa.transition;
    Wa.transition = null;
      er = 1, Ou(d, p, b, _);
      er = N, Wa.transition = z;
  function Hd(d, p, b, _) {
    var N = er, z = Wa.transition;
    Wa.transition = null;
      er = 4, Ou(d, p, b, _);
      er = N, Wa.transition = z;
  function Ou(d, p, b, _) {
      var N = Vd(d, p, b, _);
      if (N === null) Nm(d, p, _, Pc, b), Ns(d, _);
      else if (vp(N, d, p, b, _)) _.stopPropagation();
      else if (Ns(d, _), p & 4 && -1 < Di.indexOf(d)) {
        for (; N !== null; ) {
          var z = Qt(N);
          if (z !== null && Yn(z), z = Vd(d, p, b, _), z === null && Nm(d, p, _, Pc, b), z === N) break;
          N = z;
        }
        N !== null && _.stopPropagation();
      } else Nm(d, p, _, null, b);
    }
  }
  var Pc = null;
  function Vd(d, p, b, _) {
    if (Pc = null, d = Cn(_), d = Lc(d), d !== null) if (p = hn(d), p === null) d = null;
    return Pc = d, null;
  function Ud(d) {
        switch (xn()) {
          case bi:
          case As:
          case Dn:
          case Io:
          case Pi:
  var va = null, ne = null, ve = null;
    var d, p = ne, b = p.length, _, N = "value" in va ? va.value : va.textContent, z = N.length;
    for (d = 0; d < b && p[d] === N[d]; d++) ;
    for (_ = 1; _ <= oe && p[b - _] === N[z - _]; _++) ;
    return ve = N.slice(d, 1 < _ ? 1 - _ : void 0);
    function p(b, _, N, z, oe) {
      this._reactName = b, this._targetInst = N, this.type = _, this.nativeEvent = z, this.target = oe, this.currentTarget = null;
      for (var me in d) d.hasOwnProperty(me) && (b = d[me], this[me] = b ? b(z) : z[me]);
      return this.isDefaultPrevented = (z.defaultPrevented != null ? z.defaultPrevented : z.returnValue === !1) ? ht : tn, this.isPropagationStopped = tn, this;
  var sn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(d) {
  }, defaultPrevented: 0, isTrusted: 0 }, An = _t(sn), Xn = Q({}, sn, { view: 0, detail: 0 }), Dr = _t(Xn), yr, Pn, br, Xr = Q({}, Xn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: jy, button: 0, buttons: 0, relatedTarget: function(d) {
    return "movementX" in d ? d.movementX : (d !== br && (br && d.type === "mousemove" ? (yr = d.screenX - br.screenX, Pn = d.screenY - br.screenY) : Pn = yr = 0, br = d), yr);
    return "movementY" in d ? d.movementY : Pn;
  } }), Ru = _t(Xr), bp = Q({}, Xr, { dataTransfer: 0 }), $l = _t(bp), wp = Q({}, Xn, { relatedTarget: 0 }), Mc = _t(wp), Ay = Q({}, sn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Em = _t(Ay), Ny = Q({}, sn, { clipboardData: function(d) {
  } }), LC = _t(Ny), $y = Q({}, sn, { data: 0 }), Ly = _t($y), jC = {
  }, FC = {
  }, D1 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Ll(d) {
    return p.getModifierState ? p.getModifierState(d) : (d = D1[d]) ? !!p[d] : !1;
  function jy() {
    return Ll;
  var Fy = Q({}, Xn, { key: function(d) {
      var p = jC[d.key] || d.key;
    return d.type === "keypress" ? (d = Ve(d), d === 13 ? "Enter" : String.fromCharCode(d)) : d.type === "keydown" || d.type === "keyup" ? FC[d.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: jy, charCode: function(d) {
  } }), zy = _t(Fy), By = Q({}, Xr, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), zC = _t(By), Tm = Q({}, Xn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: jy }), BC = _t(Tm), Zi = Q({}, sn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), jl = _t(Zi), vo = Q({}, Xr, {
  }), Fl = _t(vo), Hy = [9, 13, 27, 32], Wd = c && "CompositionEvent" in window, Sp = null;
  c && "documentMode" in document && (Sp = document.documentMode);
  var Cp = c && "TextEvent" in window && !Sp, HC = c && (!Wd || Sp && 8 < Sp && 11 >= Sp), VC = " ", _m = !1;
  function UC(d, p) {
        return Hy.indexOf(p.keyCode) !== -1;
  function WC(d) {
  var Gd = !1;
  function GC(d, p) {
        return WC(p);
        return p.which !== 32 ? null : (_m = !0, VC);
        return d = p.data, d === VC && _m ? null : d;
  function A1(d, p) {
    if (Gd) return d === "compositionend" || !Wd && UC(d, p) ? (d = je(), ve = ne = va = null, Gd = !1, d) : null;
        return HC && p.locale !== "ko" ? null : p.data;
  var N1 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function qC(d) {
    return p === "input" ? !!N1[d.type] : p === "textarea";
  function Vy(d, p, b, _) {
    Rr(_), p = Rp(p, "onChange"), 0 < p.length && (b = new An("onChange", "change", null, b, _), d.push({ event: b, listeners: p }));
  var Ga = null, Ic = null;
  function KC(d) {
    Nc(d, 0);
  function xp(d) {
    var p = ba(d);
  function $1(d, p) {
  var YC = !1;
    var Uy;
      var Wy = "oninput" in document;
      if (!Wy) {
        var XC = document.createElement("div");
        XC.setAttribute("oninput", "return;"), Wy = typeof XC.oninput == "function";
      Uy = Wy;
    } else Uy = !1;
    YC = Uy && (!document.documentMode || 9 < document.documentMode);
  function QC() {
    Ga && (Ga.detachEvent("onpropertychange", JC), Ic = Ga = null);
  function JC(d) {
    if (d.propertyName === "value" && xp(Ic)) {
      Vy(p, Ic, d, Cn(d)), Zo(KC, p);
  function L1(d, p, b) {
    d === "focusin" ? (QC(), Ga = p, Ic = b, Ga.attachEvent("onpropertychange", JC)) : d === "focusout" && QC();
  function ZC(d) {
    if (d === "selectionchange" || d === "keyup" || d === "keydown") return xp(Ic);
  function j1(d, p) {
    if (d === "click") return xp(p);
  function e0(d, p) {
    if (d === "input" || d === "change") return xp(p);
  function F1(d, p) {
  var ya = typeof Object.is == "function" ? Object.is : F1;
  function Ep(d, p) {
    if (ya(d, p)) return !0;
      var N = b[_];
      if (!f.call(p, N) || !ya(d[N], p[N])) return !1;
  function t0(d) {
  function Om(d, p) {
    var b = t0(d);
      b = t0(b);
  function ku(d, p) {
    return d && p ? d === p ? !0 : d && d.nodeType === 3 ? !1 : p && p.nodeType === 3 ? ku(d, p.parentNode) : "contains" in d ? d.contains(p) : d.compareDocumentPosition ? !!(d.compareDocumentPosition(p) & 16) : !1 : !1;
  function Tp() {
  function Rm(d) {
  function qd(d) {
    var p = Tp(), b = d.focusedElem, _ = d.selectionRange;
    if (p !== b && b && b.ownerDocument && ku(b.ownerDocument.documentElement, b)) {
      if (_ !== null && Rm(b)) {
          var N = b.textContent.length, z = Math.min(_.start, N);
          _ = _.end === void 0 ? z : Math.min(_.end, N), !d.extend && z > _ && (N = _, _ = z, z = N), N = Om(b, z);
          var oe = Om(
          N && oe && (d.rangeCount !== 1 || d.anchorNode !== N.node || d.anchorOffset !== N.offset || d.focusNode !== oe.node || d.focusOffset !== oe.offset) && (p = p.createRange(), p.setStart(N.node, N.offset), d.removeAllRanges(), z > _ ? (d.addRange(p), d.extend(oe.node, oe.offset)) : (p.setEnd(oe.node, oe.offset), d.addRange(p)));
  var z1 = c && "documentMode" in document && 11 >= document.documentMode, Kd = null, Gy = null, _p = null, qy = !1;
  function Ky(d, p, b) {
    qy || Kd == null || Kd !== Ce(_) || (_ = Kd, "selectionStart" in _ && Rm(_) ? _ = { start: _.selectionStart, end: _.selectionEnd } : (_ = (_.ownerDocument && _.ownerDocument.defaultView || window).getSelection(), _ = { anchorNode: _.anchorNode, anchorOffset: _.anchorOffset, focusNode: _.focusNode, focusOffset: _.focusOffset }), _p && Ep(_p, _) || (_p = _, _ = Rp(Gy, "onSelect"), 0 < _.length && (p = new An("onSelect", "select", null, p, b), d.push({ event: p, listeners: _ }), p.target = Kd)));
  function km(d, p) {
  var Dc = { animationend: km("Animation", "AnimationEnd"), animationiteration: km("Animation", "AnimationIteration"), animationstart: km("Animation", "AnimationStart"), transitionend: km("Transition", "TransitionEnd") }, ni = {}, Yy = {};
  c && (Yy = document.createElement("div").style, "AnimationEvent" in window || (delete Dc.animationend.animation, delete Dc.animationiteration.animation, delete Dc.animationstart.animation), "TransitionEvent" in window || delete Dc.transitionend.transition);
  function Pm(d) {
    if (ni[d]) return ni[d];
    if (!Dc[d]) return d;
    var p = Dc[d], b;
    for (b in p) if (p.hasOwnProperty(b) && b in Yy) return ni[d] = p[b];
  var n0 = Pm("animationend"), r0 = Pm("animationiteration"), o0 = Pm("animationstart"), i0 = Pm("transitionend"), Xy = /* @__PURE__ */ new Map(), Mm = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function js(d, p) {
    Xy.set(d, p), s(p, [d]);
  for (var Qy = 0; Qy < Mm.length; Qy++) {
    var Ac = Mm[Qy], B1 = Ac.toLowerCase(), H1 = Ac[0].toUpperCase() + Ac.slice(1);
    js(B1, "on" + H1);
  js(n0, "onAnimationEnd"), js(r0, "onAnimationIteration"), js(o0, "onAnimationStart"), js("dblclick", "onDoubleClick"), js("focusin", "onFocus"), js("focusout", "onBlur"), js(i0, "onTransitionEnd"), a("onMouseEnter", ["mouseout", "mouseover"]), a("onMouseLeave", ["mouseout", "mouseover"]), a("onPointerEnter", ["pointerout", "pointerover"]), a("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Op = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Jy = new Set("cancel close invalid load scroll toggle".split(" ").concat(Op));
  function Im(d, p, b) {
  function Nc(d, p) {
      var _ = d[b], N = _.event;
        var z = void 0;
          if (me = me.listener, Se !== z && N.isPropagationStopped()) break e;
          Im(N, me, Fe), z = Se;
          if (me = _[oe], Se = me.instance, Fe = me.currentTarget, me = me.listener, Se !== z && N.isPropagationStopped()) break e;
          Im(N, me, Fe), z = Se;
    if (Qi) throw d = ye, Qi = !1, ye = null, d;
  function ur(d, p) {
    var b = p[Mp];
    b === void 0 && (b = p[Mp] = /* @__PURE__ */ new Set());
    b.has(_) || (s0(p, d, 2, !1), b.add(_));
  function Dm(d, p, b) {
    p && (_ |= 4), s0(b, d, _, p);
  var Am = "_reactListening" + Math.random().toString(36).slice(2);
  function Yd(d) {
    if (!d[Am]) {
      d[Am] = !0, r.forEach(function(b) {
        b !== "selectionchange" && (Jy.has(b) || Dm(b, !1, d), Dm(b, !0, d));
      p === null || p[Am] || (p[Am] = !0, Dm("selectionchange", !1, p));
  function s0(d, p, b, _) {
    switch (Ud(p)) {
        var N = Bd;
        N = Hd;
        N = Ou;
    b = N.bind(null, p, b, d), N = void 0, !so || p !== "touchstart" && p !== "touchmove" && p !== "wheel" || (N = !0), _ ? N !== void 0 ? d.addEventListener(p, b, { capture: !0, passive: N }) : d.addEventListener(p, b, !0) : N !== void 0 ? d.addEventListener(p, b, { passive: N }) : d.addEventListener(p, b, !1);
  function Nm(d, p, b, _, N) {
    var z = _;
        if (me === N || me.nodeType === 8 && me.parentNode === N) break;
          if ((Se === 3 || Se === 4) && (Se = oe.stateNode.containerInfo, Se === N || Se.nodeType === 8 && Se.parentNode === N)) return;
          if (oe = Lc(me), oe === null) return;
            _ = z = oe;
    Zo(function() {
      var Fe = z, at = Cn(b), ct = [];
        var st = Xy.get(d);
          var Mt = An, Ht = d;
              Mt = zy;
              Ht = "focus", Mt = Mc;
              Ht = "blur", Mt = Mc;
              Mt = Mc;
              Mt = Ru;
              Mt = $l;
              Mt = BC;
            case n0:
            case r0:
            case o0:
              Mt = Em;
            case i0:
              Mt = jl;
              Mt = Dr;
              Mt = Fl;
              Mt = LC;
              Mt = zC;
          var Gt = (p & 4) !== 0, fo = !Gt && d === "scroll", ke = Gt ? st !== null ? st + "Capture" : null : st;
            if (Ae.tag === 5 && lt !== null && (Ae = lt, ke !== null && (lt = Kr(Ee, ke), lt != null && Gt.push(Xd(Ee, lt, Ae)))), fo) break;
          if (st = d === "mouseover" || d === "pointerover", Mt = d === "mouseout" || d === "pointerout", st && b !== Lt && (Ht = b.relatedTarget || b.fromElement) && (Lc(Ht) || Ht[zl])) break e;
          if ((Mt || st) && (st = at.window === at ? at : (st = at.ownerDocument) ? st.defaultView || st.parentWindow : window, Mt ? (Ht = b.relatedTarget || b.toElement, Mt = Fe, Ht = Ht ? Lc(Ht) : null, Ht !== null && (fo = hn(Ht), Ht !== fo || Ht.tag !== 5 && Ht.tag !== 6) && (Ht = null)) : (Mt = null, Ht = Fe), Mt !== Ht)) {
            if (Gt = Ru, lt = "onMouseLeave", ke = "onMouseEnter", Ee = "mouse", (d === "pointerout" || d === "pointerover") && (Gt = zC, lt = "onPointerLeave", ke = "onPointerEnter", Ee = "pointer"), fo = Mt == null ? st : ba(Mt), Ae = Ht == null ? st : ba(Ht), st = new Gt(lt, Ee + "leave", Mt, b, at), st.target = fo, st.relatedTarget = Ae, lt = null, Lc(at) === Fe && (Gt = new Gt(ke, Ee + "enter", Ht, b, at), Gt.target = Ae, Gt.relatedTarget = fo, lt = Gt), fo = lt, Mt && Ht) t: {
              for (Gt = Mt, ke = Ht, Ee = 0, Ae = Gt; Ae; Ae = Pu(Ae)) Ee++;
              for (Ae = 0, lt = ke; lt; lt = Pu(lt)) Ae++;
              for (; 0 < Ee - Ae; ) Gt = Pu(Gt), Ee--;
              for (; 0 < Ae - Ee; ) ke = Pu(ke), Ae--;
                Gt = Pu(Gt), ke = Pu(ke);
            Mt !== null && a0(ct, st, Mt, Gt, !1), Ht !== null && fo !== null && a0(ct, fo, Ht, Gt, !0);
          if (st = Fe ? ba(Fe) : window, Mt = st.nodeName && st.nodeName.toLowerCase(), Mt === "select" || Mt === "input" && st.type === "file") var Vt = $1;
          else if (qC(st)) if (YC) Vt = e0;
            Vt = ZC;
            var on = L1;
          else (Mt = st.nodeName) && Mt.toLowerCase() === "input" && (st.type === "checkbox" || st.type === "radio") && (Vt = j1);
            Vy(ct, Vt, b, at);
          on && on(d, st, Fe), d === "focusout" && (on = st._wrapperState) && on.controlled && st.type === "number" && ot(st, "number", st.value);
        switch (on = Fe ? ba(Fe) : window, d) {
            (qC(on) || on.contentEditable === "true") && (Kd = on, Gy = Fe, _p = null);
            _p = Gy = Kd = null;
            qy = !0;
            qy = !1, Ky(ct, b, at);
            if (z1) break;
            Ky(ct, b, at);
        var an;
        if (Wd) e: {
              var vn = "onCompositionStart";
              vn = "onCompositionEnd";
              vn = "onCompositionUpdate";
          vn = void 0;
        else Gd ? UC(d, b) && (vn = "onCompositionEnd") : d === "keydown" && b.keyCode === 229 && (vn = "onCompositionStart");
        vn && (HC && b.locale !== "ko" && (Gd || vn !== "onCompositionStart" ? vn === "onCompositionEnd" && Gd && (an = je()) : (va = at, ne = "value" in va ? va.value : va.textContent, Gd = !0)), on = Rp(Fe, vn), 0 < on.length && (vn = new Ly(vn, d, null, b, at), ct.push({ event: vn, listeners: on }), an ? vn.data = an : (an = WC(b), an !== null && (vn.data = an)))), (an = Cp ? GC(d, b) : A1(d, b)) && (Fe = Rp(Fe, "onBeforeInput"), 0 < Fe.length && (at = new Ly("onBeforeInput", "beforeinput", null, b, at), ct.push({ event: at, listeners: Fe }), at.data = an));
      Nc(ct, p);
  function Xd(d, p, b) {
  function Rp(d, p) {
      var N = d, z = N.stateNode;
      N.tag === 5 && z !== null && (N = z, z = Kr(d, b), z != null && _.unshift(Xd(d, z, N)), z = Kr(d, p), z != null && _.push(Xd(d, z, N))), d = d.return;
  function Pu(d) {
  function a0(d, p, b, _, N) {
    for (var z = p._reactName, oe = []; b !== null && b !== _; ) {
      me.tag === 5 && Fe !== null && (me = Fe, N ? (Se = Kr(b, z), Se != null && oe.unshift(Xd(b, Se, me))) : N || (Se = Kr(b, z), Se != null && oe.push(Xd(b, Se, me)))), b = b.return;
  var l0 = /\r\n?/g, V1 = /\u0000|\uFFFD/g;
  function u0(d) {
    return (typeof d == "string" ? d : "" + d).replace(l0, `
`).replace(V1, "");
  function $m(d, p, b) {
    if (p = u0(p), u0(d) !== p && b) throw Error(n(425));
  function Mu() {
  var kp = null, $c = null;
  function Lm(d, p) {
  var jm = typeof setTimeout == "function" ? setTimeout : void 0, Zy = typeof clearTimeout == "function" ? clearTimeout : void 0, c0 = typeof Promise == "function" ? Promise : void 0, Qd = typeof queueMicrotask == "function" ? queueMicrotask : typeof c0 < "u" ? function(d) {
    return c0.resolve(null).then(d).catch(Fm);
  } : jm;
  function Fm(d) {
  function Jd(d, p) {
      var N = b.nextSibling;
      if (d.removeChild(b), N && N.nodeType === 8) if (b = N.data, b === "/$") {
          d.removeChild(N), ga(p);
      b = N;
    ga(p);
  function qa(d) {
  function d0(d) {
  var Iu = Math.random().toString(36).slice(2), Ka = "__reactFiber$" + Iu, Pp = "__reactProps$" + Iu, zl = "__reactContainer$" + Iu, Mp = "__reactEvents$" + Iu, Zd = "__reactListeners$" + Iu, U1 = "__reactHandles$" + Iu;
  function Lc(d) {
    var p = d[Ka];
      if (p = b[zl] || b[Ka]) {
        if (b = p.alternate, p.child !== null || b !== null && b.child !== null) for (d = d0(d); d !== null; ) {
          if (b = d[Ka]) return b;
          d = d0(d);
    return d = d[Ka] || d[zl], !d || d.tag !== 5 && d.tag !== 6 && d.tag !== 13 && d.tag !== 3 ? null : d;
  function ba(d) {
  function Qr(d) {
    return d[Pp] || null;
  var Un = [], Fs = -1;
  function zs(d) {
  function Ar(d) {
    0 > Fs || (d.current = Un[Fs], Un[Fs] = null, Fs--);
    Fs++, Un[Fs] = d.current, d.current = p;
  var Si = {}, oo = zs(Si), Ao = zs(!1), es = Si;
  function ts(d, p) {
    if (!b) return Si;
    var N = {}, z;
    for (z in b) N[z] = p[z];
    return _ && (d = d.stateNode, d.__reactInternalMemoizedUnmaskedChildContext = p, d.__reactInternalMemoizedMaskedChildContext = N), N;
  function yo(d) {
  function ef() {
    Ar(Ao), Ar(oo);
  function f0(d, p, b) {
    if (oo.current !== Si) throw Error(n(168));
    Xt(oo, p), Xt(Ao, b);
  function Ip(d, p, b) {
    for (var N in _) if (!(N in p)) throw Error(n(108, fe(d) || "Unknown", N));
  function Ho(d) {
    return d = (d = d.stateNode) && d.__reactInternalMemoizedMergedChildContext || Si, es = oo.current, Xt(oo, d), Xt(Ao, Ao.current), !0;
  function zm(d, p, b) {
    b ? (d = Ip(d, p, es), _.__reactInternalMemoizedMergedChildContext = d, Ar(Ao), Ar(oo), Xt(oo, d)) : Ar(Ao), Xt(Ao, b);
  var Ya = null, tf = !1, Bl = !1;
  function Bm(d) {
    Ya === null ? Ya = [d] : Ya.push(d);
  function Du(d) {
    tf = !0, Bm(d);
  function Xa() {
    if (!Bl && Ya !== null) {
      Bl = !0;
      var d = 0, p = er;
        var b = Ya;
        for (er = 1; d < b.length; d++) {
        Ya = null, tf = !1;
      } catch (N) {
        throw Ya !== null && (Ya = Ya.slice(d + 1)), Kt(bi, Xa), N;
        er = p, Bl = !1;
  var Au = [], Nu = 0, $u = null, Hl = 0, bo = [], Bs = 0, ws = null, Qa = 1, Ja = "";
  function jc(d, p) {
    Au[Nu++] = Hl, Au[Nu++] = $u, $u = d, Hl = p;
  }
  function p0(d, p, b) {
    bo[Bs++] = Qa, bo[Bs++] = Ja, bo[Bs++] = ws, ws = d;
    var _ = Qa;
    d = Ja;
    var N = 32 - Mi(_) - 1;
    _ &= ~(1 << N), b += 1;
    var z = 32 - Mi(p) + N;
    if (30 < z) {
      var oe = N - N % 5;
      z = (_ & (1 << oe) - 1).toString(32), _ >>= oe, N -= oe, Qa = 1 << 32 - Mi(p) + N | b << N | _, Ja = z + d;
    } else Qa = 1 << z | b << N | _, Ja = d;
  }
  function Hm(d) {
    d.return !== null && (jc(d, 1), p0(d, 1, 0));
  function Vm(d) {
    for (; d === $u; ) $u = Au[--Nu], Au[Nu] = null, Hl = Au[--Nu], Au[Nu] = null;
    for (; d === ws; ) ws = bo[--Bs], bo[Bs] = null, Ja = bo[--Bs], bo[Bs] = null, Qa = bo[--Bs], bo[Bs] = null;
  var ns = null, rs = null, Ur = !1, Hs = null;
  function eb(d, p) {
    var b = qs(5, null, null, 0);
  function h0(d, p) {
        return p = p.nodeType !== 1 || b.toLowerCase() !== p.nodeName.toLowerCase() ? null : p, p !== null ? (d.stateNode = p, ns = d, rs = qa(p.firstChild), !0) : !1;
        return p = d.pendingProps === "" || p.nodeType !== 3 ? null : p, p !== null ? (d.stateNode = p, ns = d, rs = null, !0) : !1;
        return p = p.nodeType !== 8 ? null : p, p !== null ? (b = ws !== null ? { id: Qa, overflow: Ja } : null, d.memoizedState = { dehydrated: p, treeContext: b, retryLane: 1073741824 }, b = qs(18, null, null, 0), b.stateNode = p, b.return = d, d.child = b, ns = d, rs = null, !0) : !1;
  function tb(d) {
  function nb(d) {
    if (Ur) {
      var p = rs;
        if (!h0(d, p)) {
          if (tb(d)) throw Error(n(418));
          p = qa(b.nextSibling);
          var _ = ns;
          p && h0(d, p) ? eb(_, b) : (d.flags = d.flags & -4097 | 2, Ur = !1, ns = d);
        if (tb(d)) throw Error(n(418));
        d.flags = d.flags & -4097 | 2, Ur = !1, ns = d;
  function No(d) {
    ns = d;
  function Um(d) {
    if (d !== ns) return !1;
    if (!Ur) return No(d), Ur = !0, !1;
    if ((p = d.tag !== 3) && !(p = d.tag !== 5) && (p = d.type, p = p !== "head" && p !== "body" && !Lm(d.type, d.memoizedProps)), p && (p = rs)) {
      if (tb(d)) throw Dp(), Error(n(418));
      for (; p; ) eb(d, p), p = qa(p.nextSibling);
    if (No(d), d.tag === 13) {
                rs = qa(d.nextSibling);
        rs = null;
    } else rs = ns ? qa(d.stateNode.nextSibling) : null;
  function Dp() {
    for (var d = rs; d; ) d = qa(d.nextSibling);
  function Lu() {
    rs = ns = null, Ur = !1;
  function Vl(d) {
    Hs === null ? Hs = [d] : Hs.push(d);
  var W1 = A.ReactCurrentBatchConfig;
  function Fc(d, p, b) {
        var N = _, z = "" + d;
        return p !== null && p.ref !== null && typeof p.ref == "function" && p.ref._stringRef === z ? p.ref : (p = function(oe) {
          var me = N.refs;
          oe === null ? delete me[z] : me[z] = oe;
        }, p._stringRef = z, p);
  function Wm(d, p) {
  function m0(d) {
  function zc(d) {
    function N(ke, Ee) {
      return ke = Wu(ke, Ee), ke.index = 0, ke.sibling = null, ke;
    function z(ke, Ee, Ae) {
      return Ee === null || Ee.tag !== 6 ? (Ee = Db(Ae, ke.mode, lt), Ee.return = ke, Ee) : (Ee = N(Ee, Ae), Ee.return = ke, Ee);
      return Vt === B ? at(ke, Ee, Ae.props.children, lt, Ae.key) : Ee !== null && (Ee.elementType === Vt || typeof Vt == "object" && Vt !== null && Vt.$$typeof === Y && m0(Vt) === Ee.type) ? (lt = N(Ee, Ae.props), lt.ref = Fc(ke, Ee, Ae), lt.return = ke, lt) : (lt = uh(Ae.type, Ae.key, Ae.props, null, ke.mode, lt), lt.ref = Fc(ke, Ee, Ae), lt.return = ke, lt);
      return Ee === null || Ee.tag !== 4 || Ee.stateNode.containerInfo !== Ae.containerInfo || Ee.stateNode.implementation !== Ae.implementation ? (Ee = Eg(Ae, ke.mode, lt), Ee.return = ke, Ee) : (Ee = N(Ee, Ae.children || []), Ee.return = ke, Ee);
      return Ee === null || Ee.tag !== 7 ? (Ee = Yl(Ae, ke.mode, lt, Vt), Ee.return = ke, Ee) : (Ee = N(Ee, Ae), Ee.return = ke, Ee);
      if (typeof Ee == "string" && Ee !== "" || typeof Ee == "number") return Ee = Db("" + Ee, ke.mode, Ae), Ee.return = ke, Ee;
          case k:
            return Ae = uh(Ee.type, Ee.key, Ee.props, null, ke.mode, Ae), Ae.ref = Fc(ke, null, Ee), Ae.return = ke, Ae;
          case j:
            return Ee = Eg(Ee, ke.mode, Ae), Ee.return = ke, Ee;
          case Y:
        if (wt(Ee) || re(Ee)) return Ee = Yl(Ee, ke.mode, Ae, null), Ee.return = ke, Ee;
        Wm(ke, Ee);
          case k:
          case j:
          case Y:
        Wm(ke, Ae);
          case k:
          case j:
          case Y:
            var on = lt._init;
            return Mt(ke, Ee, Ae, on(lt._payload), Vt);
        Wm(Ee, lt);
      for (var Vt = null, on = null, an = Ee, vn = Ee = 0, Wo = null; an !== null && vn < Ae.length; vn++) {
        an.index > vn ? (Wo = an, an = null) : Wo = an.sibling;
        var rr = st(ke, an, Ae[vn], lt);
        if (rr === null) {
          an === null && (an = Wo);
        d && an && rr.alternate === null && p(ke, an), Ee = z(rr, Ee, vn), on === null ? Vt = rr : on.sibling = rr, on = rr, an = Wo;
      if (vn === Ae.length) return b(ke, an), Ur && jc(ke, vn), Vt;
      if (an === null) {
        for (; vn < Ae.length; vn++) an = ct(ke, Ae[vn], lt), an !== null && (Ee = z(an, Ee, vn), on === null ? Vt = an : on.sibling = an, on = an);
        return Ur && jc(ke, vn), Vt;
      for (an = _(ke, an); vn < Ae.length; vn++) Wo = Mt(an, ke, vn, Ae[vn], lt), Wo !== null && (d && Wo.alternate !== null && an.delete(Wo.key === null ? vn : Wo.key), Ee = z(Wo, Ee, vn), on === null ? Vt = Wo : on.sibling = Wo, on = Wo);
      return d && an.forEach(function(Ku) {
        return p(ke, Ku);
      }), Ur && jc(ke, vn), Vt;
      for (var on = Vt = null, an = Ee, vn = Ee = 0, Wo = null, rr = Ae.next(); an !== null && !rr.done; vn++, rr = Ae.next()) {
        an.index > vn ? (Wo = an, an = null) : Wo = an.sibling;
        var Ku = st(ke, an, rr.value, lt);
        if (Ku === null) {
          an === null && (an = Wo);
        d && an && Ku.alternate === null && p(ke, an), Ee = z(Ku, Ee, vn), on === null ? Vt = Ku : on.sibling = Ku, on = Ku, an = Wo;
      if (rr.done) return b(
        an
      ), Ur && jc(ke, vn), Vt;
      if (an === null) {
        for (; !rr.done; vn++, rr = Ae.next()) rr = ct(ke, rr.value, lt), rr !== null && (Ee = z(rr, Ee, vn), on === null ? Vt = rr : on.sibling = rr, on = rr);
        return Ur && jc(ke, vn), Vt;
      }
      for (an = _(ke, an); !rr.done; vn++, rr = Ae.next()) rr = Mt(an, ke, vn, rr.value, lt), rr !== null && (d && rr.alternate !== null && an.delete(rr.key === null ? vn : rr.key), Ee = z(rr, Ee, vn), on === null ? Vt = rr : on.sibling = rr, on = rr);
      return d && an.forEach(function(Q0) {
        return p(ke, Q0);
      }), Ur && jc(ke, vn), Vt;
    }
    function fo(ke, Ee, Ae, lt) {
      if (typeof Ae == "object" && Ae !== null && Ae.type === B && Ae.key === null && (Ae = Ae.props.children), typeof Ae == "object" && Ae !== null) {
          case k:
              for (var Vt = Ae.key, on = Ee; on !== null; ) {
                if (on.key === Vt) {
                  if (Vt = Ae.type, Vt === B) {
                    if (on.tag === 7) {
                      b(ke, on.sibling), Ee = N(on, Ae.props.children), Ee.return = ke, ke = Ee;
                  } else if (on.elementType === Vt || typeof Vt == "object" && Vt !== null && Vt.$$typeof === Y && m0(Vt) === on.type) {
                    b(ke, on.sibling), Ee = N(on, Ae.props), Ee.ref = Fc(ke, on, Ae), Ee.return = ke, ke = Ee;
                  b(ke, on);
                } else p(ke, on);
                on = on.sibling;
              Ae.type === B ? (Ee = Yl(Ae.props.children, ke.mode, lt, Ae.key), Ee.return = ke, ke = Ee) : (lt = uh(Ae.type, Ae.key, Ae.props, null, ke.mode, lt), lt.ref = Fc(ke, Ee, Ae), lt.return = ke, ke = lt);
          case j:
              for (on = Ae.key; Ee !== null; ) {
                if (Ee.key === on) if (Ee.tag === 4 && Ee.stateNode.containerInfo === Ae.containerInfo && Ee.stateNode.implementation === Ae.implementation) {
                  b(ke, Ee.sibling), Ee = N(Ee, Ae.children || []), Ee.return = ke, ke = Ee;
              Ee = Eg(Ae, ke.mode, lt), Ee.return = ke, ke = Ee;
          case Y:
            return on = Ae._init, fo(ke, Ee, on(Ae._payload), lt);
        Wm(ke, Ae);
      return typeof Ae == "string" && Ae !== "" || typeof Ae == "number" ? (Ae = "" + Ae, Ee !== null && Ee.tag === 6 ? (b(ke, Ee.sibling), Ee = N(Ee, Ae), Ee.return = ke, ke = Ee) : (b(ke, Ee), Ee = Db(Ae, ke.mode, lt), Ee.return = ke, ke = Ee), oe(ke)) : b(ke, Ee);
    return fo;
  var ao = zc(!0), Rt = zc(!1), Ss = zs(null), os = null, nf = null, rb = null;
  function ob() {
    rb = nf = os = null;
  function ib(d) {
    var p = Ss.current;
    Ar(Ss), d._currentValue = p;
  function sb(d, p, b) {
  function Jr(d, p) {
    os = d, rb = nf = null, d = d.dependencies, d !== null && d.firstContext !== null && (d.lanes & p && (So = !0), d.firstContext = null);
  function Vs(d) {
    if (rb !== d) if (d = { context: d, memoizedValue: p, next: null }, nf === null) {
      if (os === null) throw Error(n(308));
      nf = d, os.dependencies = { lanes: 0, firstContext: d };
    } else nf = nf.next = d;
  var Bc = null;
  function ab(d) {
    Bc === null ? Bc = [d] : Bc.push(d);
  function lb(d, p, b, _) {
    var N = p.interleaved;
    return N === null ? (b.next = b, ab(p)) : (b.next = N.next, N.next = b), p.interleaved = b, Cs(d, _);
  function Cs(d, p) {
  var xs = !1;
  function ub(d) {
  function g0(d, p) {
  function Ul(d, p) {
  function ju(d, p, b) {
    if (_ = _.shared, Wn & 2) {
      var N = _.pending;
      return N === null ? p.next = p : (p.next = N.next, N.next = p), _.pending = p, Cs(d, b);
    return N = _.interleaved, N === null ? (p.next = p, ab(_)) : (p.next = N.next, N.next = p), _.interleaved = p, Cs(d, b);
  function Gm(d, p, b) {
      _ &= d.pendingLanes, b |= _, p.lanes = b, Nl(d, b);
  function v0(d, p) {
      var N = null, z = null;
          z === null ? N = z = oe : z = z.next = oe, b = b.next;
        z === null ? N = z = p : z = z.next = p;
      } else N = z = p;
      b = { baseState: _.baseState, firstBaseUpdate: N, lastBaseUpdate: z, shared: _.shared, effects: _.effects }, d.updateQueue = b;
  function Ap(d, p, b, _) {
    var N = d.updateQueue;
    xs = !1;
    var z = N.firstBaseUpdate, oe = N.lastBaseUpdate, me = N.shared.pending;
      N.shared.pending = null;
      Se.next = null, oe === null ? z = Fe : oe.next = Fe, oe = Se;
    if (z !== null) {
      var ct = N.baseState;
      oe = 0, at = Fe = Se = null, me = z;
                xs = !0;
          me.callback !== null && me.lane !== 0 && (d.flags |= 64, st = N.effects, st === null ? N.effects = [me] : st.push(me));
          if (me = N.shared.pending, me === null) break;
          st = me, me = st.next, st.next = null, N.lastBaseUpdate = st, N.shared.pending = null;
      if (at === null && (Se = ct), N.baseState = Se, N.firstBaseUpdate = Fe, N.lastBaseUpdate = at, p = N.shared.interleaved, p !== null) {
        N = p;
          oe |= N.lane, N = N.next;
        while (N !== p);
      } else z === null && (N.shared.lanes = 0);
      rl |= oe, d.lanes = oe, d.memoizedState = ct;
  function cb(d, p, b) {
      var _ = d[p], N = _.callback;
      if (N !== null) {
        if (_.callback = null, _ = b, typeof N != "function") throw Error(n(191, N));
        N.call(_);
  var Np = {}, Za = zs(Np), $p = zs(Np), Lp = zs(Np);
  function Hc(d) {
    if (d === Np) throw Error(n(174));
  function db(d, p) {
    switch (Xt(Lp, p), Xt($p, d), Xt(Za, Np), d = p.nodeType, d) {
    Ar(Za), Xt(Za, p);
  function Vc() {
    Ar(Za), Ar($p), Ar(Lp);
  function y0(d) {
    Hc(Lp.current);
    var p = Hc(Za.current), b = At(p, d.type);
    p !== b && (Xt($p, d), Xt(Za, b));
  function qm(d) {
    $p.current === d && (Ar(Za), Ar($p));
  var Zr = zs(0);
  function Km(d) {
  var jp = [];
    for (var d = 0; d < jp.length; d++) jp[d]._workInProgressVersionPrimary = null;
    jp.length = 0;
  var Mn = A.ReactCurrentDispatcher, tr = A.ReactCurrentBatchConfig, wr = 0, nr = null, wo = null, Vo = null, Ym = !1, Fp = !1, Uc = 0, it = 0;
  function Jn() {
  function cn(d, p) {
    for (var b = 0; b < p.length && b < d.length; b++) if (!ya(d[b], p[b])) return !1;
  function Fu(d, p, b, _, N, z) {
    if (wr = z, nr = p, p.memoizedState = null, p.updateQueue = null, p.lanes = 0, Mn.current = d === null || d.memoizedState === null ? cg : Wp, d = b(_, N), Fp) {
      z = 0;
        if (Fp = !1, Uc = 0, 25 <= z) throw Error(n(301));
        z += 1, Vo = wo = null, p.updateQueue = null, Mn.current = dg, d = b(_, N);
      } while (Fp);
    if (Mn.current = Yc, p = wo !== null && wo.next !== null, wr = 0, Vo = wo = nr = null, Ym = !1, p) throw Error(n(300));
  function wa() {
    var d = Uc !== 0;
    return Uc = 0, d;
  function Ci() {
    return Vo === null ? nr.memoizedState = Vo = d : Vo = Vo.next = d, Vo;
  function lo() {
    if (wo === null) {
      var d = nr.alternate;
    } else d = wo.next;
    var p = Vo === null ? nr.memoizedState : Vo.next;
    if (p !== null) Vo = p, wo = d;
      wo = d, d = { memoizedState: wo.memoizedState, baseState: wo.baseState, baseQueue: wo.baseQueue, queue: wo.queue, next: null }, Vo === null ? nr.memoizedState = Vo = d : Vo = Vo.next = d;
    return Vo;
  function Wl(d, p) {
  function zu(d) {
    var p = lo(), b = p.queue;
    var _ = wo, N = _.baseQueue, z = b.pending;
    if (z !== null) {
      if (N !== null) {
        var oe = N.next;
        N.next = z.next, z.next = oe;
      _.baseQueue = N = z, b.pending = null;
    if (N !== null) {
      z = N.next, _ = _.baseState;
      var me = oe = null, Se = null, Fe = z;
        if ((wr & at) === at) Se !== null && (Se = Se.next = { lane: 0, action: Fe.action, hasEagerState: Fe.hasEagerState, eagerState: Fe.eagerState, next: null }), _ = Fe.hasEagerState ? Fe.eagerState : d(_, Fe.action);
          Se === null ? (me = Se = ct, oe = _) : Se = Se.next = ct, nr.lanes |= at, rl |= at;
      } while (Fe !== null && Fe !== z);
      Se === null ? oe = _ : Se.next = me, ya(_, p.memoizedState) || (So = !0), p.memoizedState = _, p.baseState = oe, p.baseQueue = Se, b.lastRenderedState = _;
      N = d;
        z = N.lane, nr.lanes |= z, rl |= z, N = N.next;
      while (N !== d);
    } else N === null && (b.lanes = 0);
  function Wc(d) {
    var p = lo(), b = p.queue;
    var _ = b.dispatch, N = b.pending, z = p.memoizedState;
    if (N !== null) {
      var oe = N = N.next;
        z = d(z, oe.action), oe = oe.next;
      while (oe !== N);
      ya(z, p.memoizedState) || (So = !0), p.memoizedState = z, p.baseQueue === null && (p.baseState = z), b.lastRenderedState = z;
    return [z, _];
  function Xm() {
  function Qm(d, p) {
    var b = nr, _ = lo(), N = p(), z = !ya(_.memoizedState, N);
    if (z && (_.memoizedState = N, So = !0), _ = _.queue, zp(eg.bind(null, b, _, d), [d]), _.getSnapshot !== p || z || Vo !== null && Vo.memoizedState.tag & 1) {
      if (b.flags |= 2048, Gc(9, Zm.bind(null, b, _, N, p), void 0, null), $o === null) throw Error(n(349));
      wr & 30 || Jm(b, p, N);
    return N;
  function Jm(d, p, b) {
    d.flags |= 16384, d = { getSnapshot: p, value: b }, p = nr.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, nr.updateQueue = p, p.stores = [d]) : (b = p.stores, b === null ? p.stores = [d] : b.push(d));
  function Zm(d, p, b, _) {
    p.value = b, p.getSnapshot = _, tg(p) && ng(d);
  function eg(d, p, b) {
      tg(p) && ng(d);
  function tg(d) {
      return !ya(d, b);
  function ng(d) {
    var p = Cs(d, 1);
  function rg(d) {
    var p = Ci();
    return typeof d == "function" && (d = d()), p.memoizedState = p.baseState = d, d = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Wl, lastRenderedState: d }, p.queue = d, d = d.dispatch = Kc.bind(null, nr, d), [p.memoizedState, d];
  function Gc(d, p, b, _) {
    return d = { tag: d, create: p, destroy: b, deps: _, next: null }, p = nr.updateQueue, p === null ? (p = { lastEffect: null, stores: null }, nr.updateQueue = p, p.lastEffect = d.next = d) : (b = p.lastEffect, b === null ? p.lastEffect = d.next = d : (_ = b.next, b.next = d, d.next = _, p.lastEffect = d)), d;
  function og() {
    return lo().memoizedState;
  function rf(d, p, b, _) {
    var N = Ci();
    nr.flags |= d, N.memoizedState = Gc(1 | p, b, void 0, _ === void 0 ? null : _);
  function of(d, p, b, _) {
    var N = lo();
    var z = void 0;
    if (wo !== null) {
      var oe = wo.memoizedState;
      if (z = oe.destroy, _ !== null && cn(_, oe.deps)) {
        N.memoizedState = Gc(p, b, z, _);
    nr.flags |= d, N.memoizedState = Gc(1 | p, b, z, _);
  function ig(d, p) {
    return rf(8390656, 8, d, p);
  function zp(d, p) {
    return of(2048, 8, d, p);
  function sg(d, p) {
    return of(4, 2, d, p);
  function Bp(d, p) {
    return of(4, 4, d, p);
  function qc(d, p) {
  function ag(d, p, b) {
    return b = b != null ? b.concat([d]) : null, of(4, 4, qc.bind(null, p, d), b);
  function Hp() {
  function lg(d, p) {
    var b = lo();
    return _ !== null && p !== null && cn(p, _[1]) ? _[0] : (b.memoizedState = [d, p], d);
  function ug(d, p) {
    var b = lo();
    return _ !== null && p !== null && cn(p, _[1]) ? _[0] : (d = d(), b.memoizedState = [d, p], d);
  function fb(d, p, b) {
    return wr & 21 ? (ya(b, p) || (b = Ld(), nr.lanes |= b, rl |= b, d.baseState = !0), p) : (d.baseState && (d.baseState = !1, So = !0), d.memoizedState = b);
  function Vp(d, p) {
    var b = er;
    er = b !== 0 && 4 > b ? b : 4, d(!0);
    var _ = tr.transition;
    tr.transition = {};
      er = b, tr.transition = _;
  function pb() {
    return lo().memoizedState;
  function Up(d, p, b) {
    var _ = ol(d);
    if (b = { lane: _, action: b, hasEagerState: !1, eagerState: null, next: null }, is(d)) b0(p, b);
    else if (b = lb(d, p, b, _), b !== null) {
      var N = Eo();
      Li(b, d, _, N), Pr(b, p, _);
  function Kc(d, p, b) {
    var _ = ol(d), N = { lane: _, action: b, hasEagerState: !1, eagerState: null, next: null };
    if (is(d)) b0(p, N);
      var z = d.alternate;
      if (d.lanes === 0 && (z === null || z.lanes === 0) && (z = p.lastRenderedReducer, z !== null)) try {
        var oe = p.lastRenderedState, me = z(oe, b);
        if (N.hasEagerState = !0, N.eagerState = me, ya(me, oe)) {
          Se === null ? (N.next = N, ab(p)) : (N.next = Se.next, Se.next = N), p.interleaved = N;
      b = lb(d, p, N, _), b !== null && (N = Eo(), Li(b, d, _, N), Pr(b, p, _));
  function is(d) {
    return d === nr || p !== null && p === nr;
  function b0(d, p) {
    Fp = Ym = !0;
  function Pr(d, p, b) {
      _ &= d.pendingLanes, b |= _, p.lanes = b, Nl(d, b);
  var Yc = { readContext: Vs, useCallback: Jn, useContext: Jn, useEffect: Jn, useImperativeHandle: Jn, useInsertionEffect: Jn, useLayoutEffect: Jn, useMemo: Jn, useReducer: Jn, useRef: Jn, useState: Jn, useDebugValue: Jn, useDeferredValue: Jn, useTransition: Jn, useMutableSource: Jn, useSyncExternalStore: Jn, useId: Jn, unstable_isNewReconciler: !1 }, cg = { readContext: Vs, useCallback: function(d, p) {
    return Ci().memoizedState = [d, p === void 0 ? null : p], d;
  }, useContext: Vs, useEffect: ig, useImperativeHandle: function(d, p, b) {
    return b = b != null ? b.concat([d]) : null, rf(
      qc.bind(null, p, d),
    return rf(4194308, 4, d, p);
    return rf(4, 2, d, p);
    var b = Ci();
    var _ = Ci();
    return p = b !== void 0 ? b(p) : p, _.memoizedState = _.baseState = p, d = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: d, lastRenderedState: p }, _.queue = d, d = d.dispatch = Up.bind(null, nr, d), [_.memoizedState, d];
    var p = Ci();
  }, useState: rg, useDebugValue: Hp, useDeferredValue: function(d) {
    return Ci().memoizedState = d;
    var d = rg(!1), p = d[0];
    return d = Vp.bind(null, d[1]), Ci().memoizedState = d, [p, d];
    var _ = nr, N = Ci();
    if (Ur) {
      if (b = p(), $o === null) throw Error(n(349));
      wr & 30 || Jm(_, p, b);
    N.memoizedState = b;
    var z = { value: b, getSnapshot: p };
    return N.queue = z, ig(eg.bind(
      z,
    ), [d]), _.flags |= 2048, Gc(9, Zm.bind(null, _, z, b, p), void 0, null), b;
    var d = Ci(), p = $o.identifierPrefix;
    if (Ur) {
      var b = Ja, _ = Qa;
      b = (_ & ~(1 << 32 - Mi(_) - 1)).toString(32) + b, p = ":" + p + "R" + b, b = Uc++, 0 < b && (p += "H" + b.toString(32)), p += ":";
  }, unstable_isNewReconciler: !1 }, Wp = {
    readContext: Vs,
    useCallback: lg,
    useContext: Vs,
    useEffect: zp,
    useImperativeHandle: ag,
    useInsertionEffect: sg,
    useLayoutEffect: Bp,
    useMemo: ug,
    useReducer: zu,
    useRef: og,
      return zu(Wl);
    useDebugValue: Hp,
      var p = lo();
      return fb(p, wo.memoizedState, d);
      var d = zu(Wl)[0], p = lo().memoizedState;
    useMutableSource: Xm,
    useSyncExternalStore: Qm,
    useId: pb,
  }, dg = { readContext: Vs, useCallback: lg, useContext: Vs, useEffect: zp, useImperativeHandle: ag, useInsertionEffect: sg, useLayoutEffect: Bp, useMemo: ug, useReducer: Wc, useRef: og, useState: function() {
    return Wc(Wl);
  }, useDebugValue: Hp, useDeferredValue: function(d) {
    var p = lo();
    return wo === null ? p.memoizedState = d : fb(p, wo.memoizedState, d);
    var d = Wc(Wl)[0], p = lo().memoizedState;
  }, useMutableSource: Xm, useSyncExternalStore: Qm, useId: pb, unstable_isNewReconciler: !1 };
  function Sa(d, p) {
  function hb(d, p, b, _) {
  var fg = { isMounted: function(d) {
    return (d = d._reactInternals) ? hn(d) === d : !1;
    var _ = Eo(), N = ol(d), z = Ul(_, N);
    z.payload = p, b != null && (z.callback = b), p = ju(d, z, N), p !== null && (Li(p, d, N, _), Gm(p, d, N));
    var _ = Eo(), N = ol(d), z = Ul(_, N);
    z.tag = 1, z.payload = p, b != null && (z.callback = b), p = ju(d, z, N), p !== null && (Li(p, d, N, _), Gm(p, d, N));
    var b = Eo(), _ = ol(d), N = Ul(b, _);
    N.tag = 2, p != null && (N.callback = p), p = ju(d, N, _), p !== null && (Li(p, d, _, b), Gm(p, d, _));
  function w0(d, p, b, _, N, z, oe) {
    return d = d.stateNode, typeof d.shouldComponentUpdate == "function" ? d.shouldComponentUpdate(_, z, oe) : p.prototype && p.prototype.isPureReactComponent ? !Ep(b, _) || !Ep(N, z) : !0;
  function pg(d, p, b) {
    var _ = !1, N = Si, z = p.contextType;
    return typeof z == "object" && z !== null ? z = Vs(z) : (N = yo(p) ? es : oo.current, _ = p.contextTypes, z = (_ = _ != null) ? ts(d, N) : Si), p = new p(b, z), d.memoizedState = p.state !== null && p.state !== void 0 ? p.state : null, p.updater = fg, d.stateNode = p, p._reactInternals = d, _ && (d = d.stateNode, d.__reactInternalMemoizedUnmaskedChildContext = N, d.__reactInternalMemoizedMaskedChildContext = z), p;
  function S0(d, p, b, _) {
    d = p.state, typeof p.componentWillReceiveProps == "function" && p.componentWillReceiveProps(b, _), typeof p.UNSAFE_componentWillReceiveProps == "function" && p.UNSAFE_componentWillReceiveProps(b, _), p.state !== d && fg.enqueueReplaceState(p, p.state, null);
  function Gp(d, p, b, _) {
    var N = d.stateNode;
    N.props = b, N.state = d.memoizedState, N.refs = {}, ub(d);
    var z = p.contextType;
    typeof z == "object" && z !== null ? N.context = Vs(z) : (z = yo(p) ? es : oo.current, N.context = ts(d, z)), N.state = d.memoizedState, z = p.getDerivedStateFromProps, typeof z == "function" && (hb(d, p, z, b), N.state = d.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof N.getSnapshotBeforeUpdate == "function" || typeof N.UNSAFE_componentWillMount != "function" && typeof N.componentWillMount != "function" || (p = N.state, typeof N.componentWillMount == "function" && N.componentWillMount(), typeof N.UNSAFE_componentWillMount == "function" && N.UNSAFE_componentWillMount(), p !== N.state && fg.enqueueReplaceState(N, N.state, null), Ap(d, b, N, _), N.state = d.memoizedState), typeof N.componentDidMount == "function" && (d.flags |= 4194308);
  function Xc(d, p) {
      var N = b;
    } catch (z) {
      N = `
Error generating stack: ` + z.message + `
` + z.stack;
    return { value: d, source: p, stack: N, digest: null };
  function mb(d, p, b) {
  function gb(d, p) {
  var hg = typeof WeakMap == "function" ? WeakMap : Map;
  function C0(d, p, b) {
    b = Ul(-1, b), b.tag = 3, b.payload = { element: null };
      df || (df = !0, Zc = _), gb(d, p);
  function vb(d, p, b) {
    b = Ul(-1, b), b.tag = 3;
      var N = p.value;
        return _(N);
        gb(d, p);
    var z = d.stateNode;
    return z !== null && typeof z.componentDidCatch == "function" && (b.callback = function() {
      gb(d, p), typeof _ != "function" && (Vu === null ? Vu = /* @__PURE__ */ new Set([this]) : Vu.add(this));
  function yb(d, p, b) {
      _ = d.pingCache = new hg();
      var N = /* @__PURE__ */ new Set();
      _.set(p, N);
    } else N = _.get(p), N === void 0 && (N = /* @__PURE__ */ new Set(), _.set(p, N));
    N.has(b) || (N.add(b), d = J1.bind(null, d, p, b), p.then(d, d));
  function x0(d) {
  function Bu(d, p, b, _, N) {
    return d.mode & 1 ? (d.flags |= 65536, d.lanes = N, d) : (d === p ? d.flags |= 65536 : (d.flags |= 128, b.flags |= 131072, b.flags &= -52805, b.tag === 1 && (b.alternate === null ? b.tag = 17 : (p = Ul(-1, 1), p.tag = 2, ju(b, p, 1))), b.lanes |= 1), d);
  var qp = A.ReactCurrentOwner, So = !1;
  function ri(d, p, b, _) {
    p.child = d === null ? Rt(p, null, b, _) : ao(p, d.child, b, _);
  function ss(d, p, b, _, N) {
    var z = p.ref;
    return Jr(p, N), _ = Fu(d, p, b, _, z, N), b = wa(), d !== null && !So ? (p.updateQueue = d.updateQueue, p.flags &= -2053, d.lanes &= ~N, Ws(d, p, N)) : (Ur && b && Hm(p), p.flags |= 1, ri(d, p, _, N), p.child);
  function Qc(d, p, b, _, N) {
      var z = b.type;
      return typeof z == "function" && !Ib(z) && z.defaultProps === void 0 && b.compare === null && b.defaultProps === void 0 ? (p.tag = 15, p.type = z, _n(d, p, z, _, N)) : (d = uh(b.type, null, _, p, p.mode, N), d.ref = p.ref, d.return = p, p.child = d);
    if (z = d.child, !(d.lanes & N)) {
      var oe = z.memoizedProps;
      if (b = b.compare, b = b !== null ? b : Ep, b(oe, _) && d.ref === p.ref) return Ws(d, p, N);
    return p.flags |= 1, d = Wu(z, _), d.ref = p.ref, d.return = p, p.child = d;
  function _n(d, p, b, _, N) {
      var z = d.memoizedProps;
      if (Ep(z, _) && d.ref === p.ref) if (So = !1, p.pendingProps = _ = z, (d.lanes & N) !== 0) d.flags & 131072 && (So = !0);
      else return p.lanes = d.lanes, Ws(d, p, N);
    return E0(d, p, b, _, N);
  function Kp(d, p, b) {
    var _ = p.pendingProps, N = _.children, z = d !== null ? d.memoizedState : null;
    if (_.mode === "hidden") if (!(p.mode & 1)) p.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Xt(lf, Es), Es |= b;
      if (!(b & 1073741824)) return d = z !== null ? z.baseLanes | b : b, p.lanes = p.childLanes = 1073741824, p.memoizedState = { baseLanes: d, cachePool: null, transitions: null }, p.updateQueue = null, Xt(lf, Es), Es |= d, null;
      p.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, _ = z !== null ? z.baseLanes : b, Xt(lf, Es), Es |= _;
    else z !== null ? (_ = z.baseLanes | b, p.memoizedState = null) : _ = b, Xt(lf, Es), Es |= _;
    return ri(d, p, N, b), p.child;
  function bb(d, p) {
  function E0(d, p, b, _, N) {
    var z = yo(b) ? es : oo.current;
    return z = ts(p, z), Jr(p, N), b = Fu(d, p, b, _, z, N), _ = wa(), d !== null && !So ? (p.updateQueue = d.updateQueue, p.flags &= -2053, d.lanes &= ~N, Ws(d, p, N)) : (Ur && _ && Hm(p), p.flags |= 1, ri(d, p, b, N), p.child);
  function T0(d, p, b, _, N) {
    if (yo(b)) {
      var z = !0;
      Ho(p);
    } else z = !1;
    if (Jr(p, N), p.stateNode === null) Us(d, p), pg(p, b, _), Gp(p, b, _, N), _ = !0;
      typeof Fe == "object" && Fe !== null ? Fe = Vs(Fe) : (Fe = yo(b) ? es : oo.current, Fe = ts(p, Fe));
      ct || typeof oe.UNSAFE_componentWillReceiveProps != "function" && typeof oe.componentWillReceiveProps != "function" || (me !== _ || Se !== Fe) && S0(p, oe, _, Fe), xs = !1;
      oe.state = st, Ap(p, _, oe, N), Se = p.memoizedState, me !== _ || st !== Se || Ao.current || xs ? (typeof at == "function" && (hb(p, b, at, _), Se = p.memoizedState), (me = xs || w0(p, b, me, _, st, Se, Fe)) ? (ct || typeof oe.UNSAFE_componentWillMount != "function" && typeof oe.componentWillMount != "function" || (typeof oe.componentWillMount == "function" && oe.componentWillMount(), typeof oe.UNSAFE_componentWillMount == "function" && oe.UNSAFE_componentWillMount()), typeof oe.componentDidMount == "function" && (p.flags |= 4194308)) : (typeof oe.componentDidMount == "function" && (p.flags |= 4194308), p.memoizedProps = _, p.memoizedState = Se), oe.props = _, oe.state = Se, oe.context = Fe, _ = me) : (typeof oe.componentDidMount == "function" && (p.flags |= 4194308), _ = !1);
      oe = p.stateNode, g0(d, p), me = p.memoizedProps, Fe = p.type === p.elementType ? me : Sa(p.type, me), oe.props = Fe, ct = p.pendingProps, st = oe.context, Se = b.contextType, typeof Se == "object" && Se !== null ? Se = Vs(Se) : (Se = yo(b) ? es : oo.current, Se = ts(p, Se));
      (at = typeof Mt == "function" || typeof oe.getSnapshotBeforeUpdate == "function") || typeof oe.UNSAFE_componentWillReceiveProps != "function" && typeof oe.componentWillReceiveProps != "function" || (me !== ct || st !== Se) && S0(p, oe, _, Se), xs = !1, st = p.memoizedState, oe.state = st, Ap(p, _, oe, N);
      me !== ct || st !== Ht || Ao.current || xs ? (typeof Mt == "function" && (hb(p, b, Mt, _), Ht = p.memoizedState), (Fe = xs || w0(p, b, Fe, _, st, Ht, Se) || !1) ? (at || typeof oe.UNSAFE_componentWillUpdate != "function" && typeof oe.componentWillUpdate != "function" || (typeof oe.componentWillUpdate == "function" && oe.componentWillUpdate(_, Ht, Se), typeof oe.UNSAFE_componentWillUpdate == "function" && oe.UNSAFE_componentWillUpdate(_, Ht, Se)), typeof oe.componentDidUpdate == "function" && (p.flags |= 4), typeof oe.getSnapshotBeforeUpdate == "function" && (p.flags |= 1024)) : (typeof oe.componentDidUpdate != "function" || me === d.memoizedProps && st === d.memoizedState || (p.flags |= 4), typeof oe.getSnapshotBeforeUpdate != "function" || me === d.memoizedProps && st === d.memoizedState || (p.flags |= 1024), p.memoizedProps = _, p.memoizedState = Ht), oe.props = _, oe.state = Ht, oe.context = Se, _ = Fe) : (typeof oe.componentDidUpdate != "function" || me === d.memoizedProps && st === d.memoizedState || (p.flags |= 4), typeof oe.getSnapshotBeforeUpdate != "function" || me === d.memoizedProps && st === d.memoizedState || (p.flags |= 1024), _ = !1);
    return Yp(d, p, b, _, z, N);
  function Yp(d, p, b, _, N, z) {
    bb(d, p);
    if (!_ && !oe) return N && zm(p, b, !1), Ws(d, p, z);
    _ = p.stateNode, qp.current = p;
    return p.flags |= 1, d !== null && oe ? (p.child = ao(p, d.child, null, z), p.child = ao(p, null, me, z)) : ri(d, p, me, z), p.memoizedState = _.state, N && zm(p, b, !0), p.child;
  function sf(d) {
    p.pendingContext ? f0(d, p.pendingContext, p.pendingContext !== p.context) : p.context && f0(d, p.context, !1), db(d, p.containerInfo);
  function _0(d, p, b, _, N) {
    return Lu(), Vl(N), p.flags |= 256, ri(d, p, b, _), p.child;
  var mg = { dehydrated: null, treeContext: null, retryLane: 0 };
  function wb(d) {
  function gg(d, p, b) {
    var _ = p.pendingProps, N = Zr.current, z = !1, oe = (p.flags & 128) !== 0, me;
    if ((me = oe) || (me = d !== null && d.memoizedState === null ? !1 : (N & 2) !== 0), me ? (z = !0, p.flags &= -129) : (d === null || d.memoizedState !== null) && (N |= 1), Xt(Zr, N & 1), d === null)
      return nb(p), d = p.memoizedState, d !== null && (d = d.dehydrated, d !== null) ? (p.mode & 1 ? d.data === "$!" ? p.lanes = 8 : p.lanes = 1073741824 : p.lanes = 1, null) : (oe = _.children, d = _.fallback, z ? (_ = p.mode, z = p.child, oe = { mode: "hidden", children: oe }, !(_ & 1) && z !== null ? (z.childLanes = 0, z.pendingProps = oe) : z = Gu(oe, _, 0, null), d = Yl(d, _, b, null), z.return = p, d.return = p, z.sibling = d, p.child = z, p.child.memoizedState = wb(b), p.memoizedState = mg, d) : Sb(p, oe));
    if (N = d.memoizedState, N !== null && (me = N.dehydrated, me !== null)) return O0(d, p, oe, _, me, N, b);
    if (z) {
      z = _.fallback, oe = p.mode, N = d.child, me = N.sibling;
      return !(oe & 1) && p.child !== N ? (_ = p.child, _.childLanes = 0, _.pendingProps = Se, p.deletions = null) : (_ = Wu(N, Se), _.subtreeFlags = N.subtreeFlags & 14680064), me !== null ? z = Wu(me, z) : (z = Yl(z, oe, b, null), z.flags |= 2), z.return = p, _.return = p, _.sibling = z, p.child = _, _ = z, z = p.child, oe = d.child.memoizedState, oe = oe === null ? wb(b) : { baseLanes: oe.baseLanes | b, cachePool: null, transitions: oe.transitions }, z.memoizedState = oe, z.childLanes = d.childLanes & ~b, p.memoizedState = mg, _;
    return z = d.child, d = z.sibling, _ = Wu(z, { mode: "visible", children: _.children }), !(p.mode & 1) && (_.lanes = b), _.return = p, _.sibling = null, d !== null && (b = p.deletions, b === null ? (p.deletions = [d], p.flags |= 16) : b.push(d)), p.child = _, p.memoizedState = null, _;
  function Sb(d, p) {
    return p = Gu({ mode: "visible", children: p }, d.mode, 0, null), p.return = d, d.child = p;
  function Xp(d, p, b, _) {
    return _ !== null && Vl(_), ao(p, d.child, null, b), d = Sb(p, p.pendingProps.children), d.flags |= 2, p.memoizedState = null, d;
  function O0(d, p, b, _, N, z, oe) {
      return p.flags & 256 ? (p.flags &= -257, _ = mb(Error(n(422))), Xp(d, p, oe, _)) : p.memoizedState !== null ? (p.child = d.child, p.flags |= 128, null) : (z = _.fallback, N = p.mode, _ = Gu({ mode: "visible", children: _.children }, N, 0, null), z = Yl(z, N, oe, null), z.flags |= 2, _.return = p, z.return = p, _.sibling = z, p.child = _, p.mode & 1 && ao(p, d.child, null, oe), p.child.memoizedState = wb(oe), p.memoizedState = mg, z);
    if (!(p.mode & 1)) return Xp(d, p, oe, null);
    if (N.data === "$!") {
      if (_ = N.nextSibling && N.nextSibling.dataset, _) var me = _.dgst;
      return _ = me, z = Error(n(419)), _ = mb(z, _, void 0), Xp(d, p, oe, _);
    }
    if (me = (oe & d.childLanes) !== 0, So || me) {
      if (_ = $o, _ !== null) {
            N = 2;
            N = 8;
            N = 32;
            N = 268435456;
            N = 0;
        N = N & (_.suspendedLanes | oe) ? 0 : N, N !== 0 && N !== z.retryLane && (z.retryLane = N, Cs(d, N), Li(_, d, N, -1));
      return Mb(), _ = mb(Error(n(421))), Xp(d, p, oe, _);
    return N.data === "$?" ? (p.flags |= 128, p.child = d.child, p = Z1.bind(null, d), N._reactRetry = p, null) : (d = z.treeContext, rs = qa(N.nextSibling), ns = p, Ur = !0, Hs = null, d !== null && (bo[Bs++] = Qa, bo[Bs++] = Ja, bo[Bs++] = ws, Qa = d.id, Ja = d.overflow, ws = p), p = Sb(p, _.children), p.flags |= 4096, p);
  function Cb(d, p, b) {
    _ !== null && (_.lanes |= p), sb(d.return, p, b);
  function Ai(d, p, b, _, N) {
    var z = d.memoizedState;
    z === null ? d.memoizedState = { isBackwards: p, rendering: null, renderingStartTime: 0, last: _, tail: b, tailMode: N } : (z.isBackwards = p, z.rendering = null, z.renderingStartTime = 0, z.last = _, z.tail = b, z.tailMode = N);
  function el(d, p, b) {
    var _ = p.pendingProps, N = _.revealOrder, z = _.tail;
    if (ri(d, p, _.children, b), _ = Zr.current, _ & 2) _ = _ & 1 | 2, p.flags |= 128;
        if (d.tag === 13) d.memoizedState !== null && Cb(d, b, p);
        else if (d.tag === 19) Cb(d, b, p);
    if (Xt(Zr, _), !(p.mode & 1)) p.memoizedState = null;
    else switch (N) {
        for (b = p.child, N = null; b !== null; ) d = b.alternate, d !== null && Km(d) === null && (N = b), b = b.sibling;
        b = N, b === null ? (N = p.child, p.child = null) : (N = b.sibling, b.sibling = null), Ai(p, !1, N, b, z);
        for (b = null, N = p.child, p.child = null; N !== null; ) {
          if (d = N.alternate, d !== null && Km(d) === null) {
            p.child = N;
          d = N.sibling, N.sibling = b, b = N, N = d;
        Ai(p, !0, b, null, z);
        Ai(p, !1, null, null, void 0);
  function Us(d, p) {
  function Ws(d, p, b) {
    if (d !== null && (p.dependencies = d.dependencies), rl |= p.lanes, !(b & p.childLanes)) return null;
      for (d = p.child, b = Wu(d, d.pendingProps), p.child = b, b.return = p; d.sibling !== null; ) d = d.sibling, b = b.sibling = Wu(d, d.pendingProps), b.return = p;
  function Qp(d, p, b) {
        sf(p), Lu();
        y0(p);
        yo(p.type) && Ho(p);
        db(p, p.stateNode.containerInfo);
        var _ = p.type._context, N = p.memoizedProps.value;
        Xt(Ss, _._currentValue), _._currentValue = N;
          return _.dehydrated !== null ? (Xt(Zr, Zr.current & 1), p.flags |= 128, null) : b & p.child.childLanes ? gg(d, p, b) : (Xt(Zr, Zr.current & 1), d = Ws(d, p, b), d !== null ? d.sibling : null);
        Xt(Zr, Zr.current & 1);
          if (_) return el(d, p, b);
        if (N = p.memoizedState, N !== null && (N.rendering = null, N.tail = null, N.lastEffect = null), Xt(Zr, Zr.current), _) break;
        return p.lanes = 0, Kp(d, p, b);
    return Ws(d, p, b);
  var Gs, Co, R0, k0;
  Gs = function(d, p) {
  }, Co = function() {
  }, R0 = function(d, p, b, _) {
    var N = d.memoizedProps;
    if (N !== _) {
      d = p.stateNode, Hc(Za.current);
      var z = null;
          N = Ne(d, N), _ = Ne(d, _), z = [];
          N = Q({}, N, { value: void 0 }), _ = Q({}, _, { value: void 0 }), z = [];
          N = nt(d, N), _ = nt(d, _), z = [];
          typeof N.onClick != "function" && typeof _.onClick == "function" && (d.onclick = Mu);
      for (Fe in N) if (!_.hasOwnProperty(Fe) && N.hasOwnProperty(Fe) && N[Fe] != null) if (Fe === "style") {
        var me = N[Fe];
      } else Fe !== "dangerouslySetInnerHTML" && Fe !== "children" && Fe !== "suppressContentEditableWarning" && Fe !== "suppressHydrationWarning" && Fe !== "autoFocus" && (o.hasOwnProperty(Fe) ? z || (z = []) : (z = z || []).push(Fe, null));
        if (me = N != null ? N[Fe] : void 0, _.hasOwnProperty(Fe) && Se !== me && (Se != null || me != null)) if (Fe === "style") if (me) {
        } else b || (z || (z = []), z.push(
        else Fe === "dangerouslySetInnerHTML" ? (Se = Se ? Se.__html : void 0, me = me ? me.__html : void 0, Se != null && me !== Se && (z = z || []).push(Fe, Se)) : Fe === "children" ? typeof Se != "string" && typeof Se != "number" || (z = z || []).push(Fe, "" + Se) : Fe !== "suppressContentEditableWarning" && Fe !== "suppressHydrationWarning" && (o.hasOwnProperty(Fe) ? (Se != null && Fe === "onScroll" && ur("scroll", d), z || me === Se || (z = [])) : (z = z || []).push(Fe, Se));
      b && (z = z || []).push("style", b);
      var Fe = z;
  }, k0 = function(d, p, b, _) {
  function Jp(d, p) {
    if (!Ur) switch (d.tailMode) {
  function Uo(d) {
    if (p) for (var N = d.child; N !== null; ) b |= N.lanes | N.childLanes, _ |= N.subtreeFlags & 14680064, _ |= N.flags & 14680064, N.return = d, N = N.sibling;
    else for (N = d.child; N !== null; ) b |= N.lanes | N.childLanes, _ |= N.subtreeFlags, _ |= N.flags, N.return = d, N = N.sibling;
  function P0(d, p, b) {
    switch (Vm(p), p.tag) {
        return Uo(p), null;
        return yo(p.type) && ef(), Uo(p), null;
        return _ = p.stateNode, Vc(), Ar(Ao), Ar(oo), Jt(), _.pendingContext && (_.context = _.pendingContext, _.pendingContext = null), (d === null || d.child === null) && (Um(p) ? p.flags |= 4 : d === null || d.memoizedState.isDehydrated && !(p.flags & 256) || (p.flags |= 1024, Hs !== null && (ed(Hs), Hs = null))), Co(d, p), Uo(p), null;
        qm(p);
        var N = Hc(Lp.current);
        if (b = p.type, d !== null && p.stateNode != null) R0(d, p, b, _, N), d.ref !== p.ref && (p.flags |= 512, p.flags |= 2097152);
            return Uo(p), null;
          if (d = Hc(Za.current), Um(p)) {
            var z = p.memoizedProps;
            switch (_[Ka] = p, _[Pp] = z, d = (p.mode & 1) !== 0, b) {
                ur("cancel", _), ur("close", _);
                ur("load", _);
                for (N = 0; N < Op.length; N++) ur(Op[N], _);
                ur("error", _);
                ur(
                ), ur("load", _);
                ur("toggle", _);
                Be(_, z), ur("invalid", _);
                _._wrapperState = { wasMultiple: !!z.multiple }, ur("invalid", _);
                Ft(_, z), ur("invalid", _);
            We(b, z), N = null;
            for (var oe in z) if (z.hasOwnProperty(oe)) {
              var me = z[oe];
              oe === "children" ? typeof me == "string" ? _.textContent !== me && (z.suppressHydrationWarning !== !0 && $m(_.textContent, me, d), N = ["children", me]) : typeof me == "number" && _.textContent !== "" + me && (z.suppressHydrationWarning !== !0 && $m(
              ), N = ["children", "" + me]) : o.hasOwnProperty(oe) && me != null && oe === "onScroll" && ur("scroll", _);
                _e(_), rt(_, z, !0);
                typeof z.onClick == "function" && (_.onclick = Mu);
            _ = N, p.updateQueue = _, _ !== null && (p.flags |= 4);
            oe = N.nodeType === 9 ? N : N.ownerDocument, d === "http://www.w3.org/1999/xhtml" && (d = Tt(b)), d === "http://www.w3.org/1999/xhtml" ? b === "script" ? (d = oe.createElement("div"), d.innerHTML = "<script><\/script>", d = d.removeChild(d.firstChild)) : typeof _.is == "string" ? d = oe.createElement(b, { is: _.is }) : (d = oe.createElement(b), b === "select" && (oe = d, _.multiple ? oe.multiple = !0 : _.size && (oe.size = _.size))) : d = oe.createElementNS(d, b), d[Ka] = p, d[Pp] = _, Gs(d, p, !1, !1), p.stateNode = d;
                  ur("cancel", d), ur("close", d), N = _;
                  ur("load", d), N = _;
                  for (N = 0; N < Op.length; N++) ur(Op[N], d);
                  N = _;
                  ur("error", d), N = _;
                  ur(
                  ), ur("load", d), N = _;
                  ur("toggle", d), N = _;
                  Be(d, _), N = Ne(d, _), ur("invalid", d);
                  N = _;
                  d._wrapperState = { wasMultiple: !!_.multiple }, N = Q({}, _, { value: void 0 }), ur("invalid", d);
                  Ft(d, _), N = nt(d, _), ur("invalid", d);
                  N = _;
              We(b, N), me = N;
              for (z in me) if (me.hasOwnProperty(z)) {
                var Se = me[z];
                z === "style" ? zt(d, Se) : z === "dangerouslySetInnerHTML" ? (Se = Se ? Se.__html : void 0, Se != null && Xe(d, Se)) : z === "children" ? typeof Se == "string" ? (b !== "textarea" || Se !== "") && Oe(d, Se) : typeof Se == "number" && Oe(d, "" + Se) : z !== "suppressContentEditableWarning" && z !== "suppressHydrationWarning" && z !== "autoFocus" && (o.hasOwnProperty(z) ? Se != null && z === "onScroll" && ur("scroll", d) : Se != null && M(d, z, Se, oe));
                  d.multiple = !!_.multiple, z = _.value, z != null ? gt(d, !!_.multiple, z, !1) : _.defaultValue != null && gt(
                  typeof N.onClick == "function" && (d.onclick = Mu);
        return Uo(p), null;
        if (d && p.stateNode != null) k0(d, p, d.memoizedProps, _);
          if (b = Hc(Lp.current), Hc(Za.current), Um(p)) {
            if (_ = p.stateNode, b = p.memoizedProps, _[Ka] = p, (z = _.nodeValue !== b) && (d = ns, d !== null)) switch (d.tag) {
                $m(_.nodeValue, b, (d.mode & 1) !== 0);
                d.memoizedProps.suppressHydrationWarning !== !0 && $m(_.nodeValue, b, (d.mode & 1) !== 0);
            z && (p.flags |= 4);
          } else _ = (b.nodeType === 9 ? b : b.ownerDocument).createTextNode(_), _[Ka] = p, p.stateNode = _;
        return Uo(p), null;
        if (Ar(Zr), _ = p.memoizedState, d === null || d.memoizedState !== null && d.memoizedState.dehydrated !== null) {
          if (Ur && rs !== null && p.mode & 1 && !(p.flags & 128)) Dp(), Lu(), p.flags |= 98560, z = !1;
          else if (z = Um(p), _ !== null && _.dehydrated !== null) {
              if (!z) throw Error(n(318));
              if (z = p.memoizedState, z = z !== null ? z.dehydrated : null, !z) throw Error(n(317));
              z[Ka] = p;
            } else Lu(), !(p.flags & 128) && (p.memoizedState = null), p.flags |= 4;
            Uo(p), z = !1;
          } else Hs !== null && (ed(Hs), Hs = null), z = !0;
          if (!z) return p.flags & 65536 ? p : null;
        }
        return p.flags & 128 ? (p.lanes = b, p) : (_ = _ !== null, _ !== (d !== null && d.memoizedState !== null) && _ && (p.child.flags |= 8192, p.mode & 1 && (d === null || Zr.current & 1 ? co === 0 && (co = 3) : Mb())), p.updateQueue !== null && (p.flags |= 4), Uo(p), null);
        return Vc(), Co(d, p), d === null && Yd(p.stateNode.containerInfo), Uo(p), null;
        return ib(p.type._context), Uo(p), null;
        return yo(p.type) && ef(), Uo(p), null;
        if (Ar(Zr), z = p.memoizedState, z === null) return Uo(p), null;
        if (_ = (p.flags & 128) !== 0, oe = z.rendering, oe === null) if (_) Jp(z, !1);
          if (co !== 0 || d !== null && d.flags & 128) for (d = p.child; d !== null; ) {
            if (oe = Km(d), oe !== null) {
              for (p.flags |= 128, Jp(z, !1), _ = oe.updateQueue, _ !== null && (p.updateQueue = _, p.flags |= 4), p.subtreeFlags = 0, _ = b, b = p.child; b !== null; ) z = b, d = _, z.flags &= 14680066, oe = z.alternate, oe === null ? (z.childLanes = 0, z.lanes = d, z.child = null, z.subtreeFlags = 0, z.memoizedProps = null, z.memoizedState = null, z.updateQueue = null, z.dependencies = null, z.stateNode = null) : (z.childLanes = oe.childLanes, z.lanes = oe.lanes, z.child = oe.child, z.subtreeFlags = 0, z.deletions = null, z.memoizedProps = oe.memoizedProps, z.memoizedState = oe.memoizedState, z.updateQueue = oe.updateQueue, z.type = oe.type, d = oe.dependencies, z.dependencies = d === null ? null : { lanes: d.lanes, firstContext: d.firstContext }), b = b.sibling;
              return Xt(Zr, Zr.current & 1 | 2), p.child;
          z.tail !== null && wn() > cf && (p.flags |= 128, _ = !0, Jp(z, !1), p.lanes = 4194304);
          if (!_) if (d = Km(oe), d !== null) {
            if (p.flags |= 128, _ = !0, b = d.updateQueue, b !== null && (p.updateQueue = b, p.flags |= 4), Jp(z, !0), z.tail === null && z.tailMode === "hidden" && !oe.alternate && !Ur) return Uo(p), null;
          } else 2 * wn() - z.renderingStartTime > cf && b !== 1073741824 && (p.flags |= 128, _ = !0, Jp(z, !1), p.lanes = 4194304);
          z.isBackwards ? (oe.sibling = p.child, p.child = oe) : (b = z.last, b !== null ? b.sibling = oe : p.child = oe, z.last = oe);
        return z.tail !== null ? (p = z.tail, z.rendering = p, z.tail = p.sibling, z.renderingStartTime = wn(), p.sibling = null, b = Zr.current, Xt(Zr, _ ? b & 1 | 2 : b & 1), p) : (Uo(p), null);
        return Pb(), _ = p.memoizedState !== null, d !== null && d.memoizedState !== null !== _ && (p.flags |= 8192), _ && p.mode & 1 ? Es & 1073741824 && (Uo(p), p.subtreeFlags & 6 && (p.flags |= 8192)) : Uo(p), null;
  function vg(d, p) {
    switch (Vm(p), p.tag) {
        return yo(p.type) && ef(), d = p.flags, d & 65536 ? (p.flags = d & -65537 | 128, p) : null;
        return Vc(), Ar(Ao), Ar(oo), Jt(), d = p.flags, d & 65536 && !(d & 128) ? (p.flags = d & -65537 | 128, p) : null;
        return qm(p), null;
        if (Ar(Zr), d = p.memoizedState, d !== null && d.dehydrated !== null) {
          Lu();
        return Ar(Zr), null;
        return Vc(), null;
        return ib(p.type._context), null;
        return Pb(), null;
  var Zp = !1, xi = !1, G1 = typeof WeakSet == "function" ? WeakSet : Set, Nt = null;
  function af(d, p) {
      Wr(d, p, _);
  function yg(d, p, b) {
      Wr(d, p, _);
  var M0 = !1;
  function I0(d, p) {
    if (kp = Ls, d = Tp(), Rm(d)) {
          var N = _.anchorOffset, z = _.focusNode;
            b.nodeType, z.nodeType;
            for (var Mt; ct !== b || N !== 0 && ct.nodeType !== 3 || (me = oe + N), ct !== z || _ !== 0 && ct.nodeType !== 3 || (Se = oe + _), ct.nodeType === 3 && (oe += ct.nodeValue.length), (Mt = ct.firstChild) !== null; )
              if (st === b && ++Fe === N && (me = oe), st === z && ++at === _ && (Se = oe), (Mt = ct.nextSibling) !== null) break;
    for ($c = { focusedElem: d, selectionRange: b }, Ls = !1, Nt = p; Nt !== null; ) if (p = Nt, d = p.child, (p.subtreeFlags & 1028) !== 0 && d !== null) d.return = p, Nt = d;
              var Gt = Ht.memoizedProps, fo = Ht.memoizedState, ke = p.stateNode, Ee = ke.getSnapshotBeforeUpdate(p.elementType === p.type ? Gt : Sa(p.type, Gt), fo);
        Wr(p, p.return, lt);
    return Ht = M0, M0 = !1, Ht;
  function eh(d, p, b) {
      var N = _ = _.next;
        if ((N.tag & d) === d) {
          var z = N.destroy;
          N.destroy = void 0, z !== void 0 && yg(p, b, z);
        N = N.next;
      } while (N !== _);
  function th(d, p) {
  function xb(d) {
  function bg(d) {
    p !== null && (d.alternate = null, bg(p)), d.child = null, d.deletions = null, d.sibling = null, d.tag === 5 && (p = d.stateNode, p !== null && (delete p[Ka], delete p[Pp], delete p[Mp], delete p[Zd], delete p[U1])), d.stateNode = null, d.return = null, d.dependencies = null, d.memoizedProps = null, d.memoizedState = null, d.pendingProps = null, d.stateNode = null, d.updateQueue = null;
  function nh(d) {
  function Gl(d) {
        if (d.return === null || nh(d.return)) return null;
  function tl(d, p, b) {
    if (_ === 5 || _ === 6) d = d.stateNode, p ? b.nodeType === 8 ? b.parentNode.insertBefore(d, p) : b.insertBefore(d, p) : (b.nodeType === 8 ? (p = b.parentNode, p.insertBefore(d, b)) : (p = b, p.appendChild(d)), b = b._reactRootContainer, b != null || p.onclick !== null || (p.onclick = Mu));
    else if (_ !== 4 && (d = d.child, d !== null)) for (tl(d, p, b), d = d.sibling; d !== null; ) tl(d, p, b), d = d.sibling;
  function nl(d, p, b) {
    else if (_ !== 4 && (d = d.child, d !== null)) for (nl(d, p, b), d = d.sibling; d !== null; ) nl(d, p, b), d = d.sibling;
  var uo = null, Ni = !1;
  function $i(d, p, b) {
    for (b = b.child; b !== null; ) D0(d, p, b), b = b.sibling;
  function D0(d, p, b) {
    if (wi && typeof wi.onCommitFiberUnmount == "function") try {
      wi.onCommitFiberUnmount(Ji, b);
        xi || af(b, p);
        var _ = uo, N = Ni;
        uo = null, $i(d, p, b), uo = _, Ni = N, uo !== null && (Ni ? (d = uo, b = b.stateNode, d.nodeType === 8 ? d.parentNode.removeChild(b) : d.removeChild(b)) : uo.removeChild(b.stateNode));
        uo !== null && (Ni ? (d = uo, b = b.stateNode, d.nodeType === 8 ? Jd(d.parentNode, b) : d.nodeType === 1 && Jd(d, b), ga(d)) : Jd(uo, b.stateNode));
        _ = uo, N = Ni, uo = b.stateNode.containerInfo, Ni = !0, $i(d, p, b), uo = _, Ni = N;
        if (!xi && (_ = b.updateQueue, _ !== null && (_ = _.lastEffect, _ !== null))) {
          N = _ = _.next;
            var z = N, oe = z.destroy;
            z = z.tag, oe !== void 0 && (z & 2 || z & 4) && yg(b, p, oe), N = N.next;
          } while (N !== _);
        $i(d, p, b);
        if (!xi && (af(b, p), _ = b.stateNode, typeof _.componentWillUnmount == "function")) try {
          Wr(b, p, me);
        $i(d, p, b);
        $i(d, p, b);
        b.mode & 1 ? (xi = (_ = xi) || b.memoizedState !== null, $i(d, p, b), xi = _) : $i(d, p, b);
        $i(d, p, b);
  function A0(d) {
      b === null && (b = d.stateNode = new G1()), p.forEach(function(_) {
        var N = V0.bind(null, d, _);
        b.has(_) || (b.add(_), _.then(N, N));
  function Ca(d, p) {
      var N = b[_];
        var z = d, oe = p, me = oe;
              uo = me.stateNode, Ni = !1;
              uo = me.stateNode.containerInfo, Ni = !0;
              uo = me.stateNode.containerInfo, Ni = !0;
        if (uo === null) throw Error(n(160));
        D0(z, oe, N), uo = null, Ni = !1;
        var Se = N.alternate;
        Se !== null && (Se.return = null), N.return = null;
        Wr(N, p, Fe);
    if (p.subtreeFlags & 12854) for (p = p.child; p !== null; ) Eb(p, d), p = p.sibling;
  function Eb(d, p) {
        if (Ca(p, d), as(d), _ & 4) {
            eh(3, d, d.return), th(3, d);
            Wr(d, d.return, Gt);
            eh(5, d, d.return);
            Wr(d, d.return, Gt);
        Ca(p, d), as(d), _ & 512 && b !== null && af(b, b.return);
        if (Ca(p, d), as(d), _ & 512 && b !== null && af(b, b.return), d.flags & 32) {
          var N = d.stateNode;
            Oe(N, "");
            Wr(d, d.return, Gt);
        if (_ & 4 && (N = d.stateNode, N != null)) {
          var z = d.memoizedProps, oe = b !== null ? b.memoizedProps : z, me = d.type, Se = d.updateQueue;
            me === "input" && z.type === "radio" && z.name != null && tt(N, z), St(me, oe);
            var Fe = St(me, z);
              at === "style" ? zt(N, ct) : at === "dangerouslySetInnerHTML" ? Xe(N, ct) : at === "children" ? Oe(N, ct) : M(N, at, ct, Fe);
                Le(N, z);
                ut(N, z);
                var st = N._wrapperState.wasMultiple;
                N._wrapperState.wasMultiple = !!z.multiple;
                var Mt = z.value;
                Mt != null ? gt(N, !!z.multiple, Mt, !1) : st !== !!z.multiple && (z.defaultValue != null ? gt(
                  N,
                  !!z.multiple,
                  z.defaultValue,
                ) : gt(N, !!z.multiple, z.multiple ? [] : "", !1));
            N[Pp] = z;
            Wr(d, d.return, Gt);
        if (Ca(p, d), as(d), _ & 4) {
          N = d.stateNode, z = d.memoizedProps;
            N.nodeValue = z;
            Wr(d, d.return, Gt);
        if (Ca(p, d), as(d), _ & 4 && b !== null && b.memoizedState.isDehydrated) try {
          ga(p.containerInfo);
          Wr(d, d.return, Gt);
        Ca(p, d), as(d);
        Ca(p, d), as(d), N = d.child, N.flags & 8192 && (z = N.memoizedState !== null, N.stateNode.isHidden = z, !z || N.alternate !== null && N.alternate.memoizedState !== null || (Ob = wn())), _ & 4 && A0(d);
        if (at = b !== null && b.memoizedState !== null, d.mode & 1 ? (xi = (Fe = xi) || at, Ca(p, d), xi = Fe) : Ca(p, d), as(d), _ & 8192) {
                  eh(4, st, st.return);
                  af(st, st.return);
                      Wr(_, b, Gt);
                  af(st, st.return);
                    rh(ct);
              Mt !== null ? (Mt.return = st, Nt = Mt) : rh(ct);
                  N = ct.stateNode, Fe ? (z = N.style, typeof z.setProperty == "function" ? z.setProperty("display", "none", "important") : z.display = "none") : (me = ct.stateNode, Se = ct.memoizedProps.style, oe = Se != null && Se.hasOwnProperty("display") ? Se.display : null, me.style.display = yt("display", oe));
                  Wr(d, d.return, Gt);
                Wr(d, d.return, Gt);
        Ca(p, d), as(d), _ & 4 && A0(d);
        Ca(
        ), as(d);
  function as(d) {
            if (nh(b)) {
            var N = _.stateNode;
            _.flags & 32 && (Oe(N, ""), _.flags &= -33);
            var z = Gl(d);
            nl(d, z, N);
            var oe = _.stateNode.containerInfo, me = Gl(d);
            tl(d, me, oe);
        Wr(d, d.return, Se);
  function q1(d, p, b) {
    Nt = d, Tb(d);
  function Tb(d, p, b) {
      var N = Nt, z = N.child;
      if (N.tag === 22 && _) {
        var oe = N.memoizedState !== null || Zp;
          var me = N.alternate, Se = me !== null && me.memoizedState !== null || xi;
          me = Zp;
          var Fe = xi;
          if (Zp = oe, (xi = Se) && !Fe) for (Nt = N; Nt !== null; ) oe = Nt, Se = oe.child, oe.tag === 22 && oe.memoizedState !== null ? _b(N) : Se !== null ? (Se.return = oe, Nt = Se) : _b(N);
          for (; z !== null; ) Nt = z, Tb(z), z = z.sibling;
          Nt = N, Zp = me, xi = Fe;
        N0(d);
      } else N.subtreeFlags & 8772 && z !== null ? (z.return = N, Nt = z) : N0(d);
  function N0(d) {
              xi || th(5, p);
              if (p.flags & 4 && !xi) if (b === null) _.componentDidMount();
                var N = p.elementType === p.type ? b.memoizedProps : Sa(p.type, b.memoizedProps);
                _.componentDidUpdate(N, b.memoizedState, _.__reactInternalSnapshotBeforeUpdate);
              var z = p.updateQueue;
              z !== null && cb(p, z, _);
                cb(p, oe, b);
                    ct !== null && ga(ct);
          xi || p.flags & 512 && xb(p);
          Wr(p, p.return, st);
  function rh(d) {
  function _b(d) {
              th(4, p);
              Wr(p, b, Se);
              var N = p.return;
                Wr(p, N, Se);
            var z = p.return;
              xb(p);
              Wr(p, z, Se);
              xb(p);
              Wr(p, oe, Se);
        Wr(p, p.return, Se);
  var K1 = Math.ceil, Hu = A.ReactCurrentDispatcher, Jc = A.ReactCurrentOwner, oi = A.ReactCurrentBatchConfig, Wn = 0, $o = null, xo = null, ii = 0, Es = 0, lf = zs(0), co = 0, oh = null, rl = 0, uf = 0, wg = 0, ih = null, ls = null, Ob = 0, cf = 1 / 0, Ts = null, df = !1, Zc = null, Vu = null, Sg = !1, ql = null, sh = 0, Uu = 0, ff = null, ah = -1, Ei = 0;
  function Eo() {
    return Wn & 6 ? wn() : ah !== -1 ? ah : ah = wn();
  function ol(d) {
    return d.mode & 1 ? Wn & 2 && ii !== 0 ? ii & -ii : W1.transition !== null ? (Ei === 0 && (Ei = Ld()), Ei) : (d = er, d !== 0 || (d = window.event, d = d === void 0 ? 16 : Ud(d.type)), d) : 1;
    if (50 < Uu) throw Uu = 0, ff = null, Error(n(185));
    Al(d, b, _), (!(Wn & 2) || d !== $o) && (d === $o && (!(Wn & 2) && (uf |= b), co === 4 && xa(d, ii)), us(d, _), b === 1 && Wn === 0 && !(p.mode & 1) && (cf = wn() + 500, tf && Xa()));
  function us(d, p) {
    Oc(d, p);
    var _ = ma(d, d === $o ? ii : 0);
      if (b != null && Ln(b), p === 1) d.tag === 0 ? Du(Rb.bind(null, d)) : Bm(Rb.bind(null, d)), Qd(function() {
        !(Wn & 6) && Xa();
        switch (Fd(_)) {
            b = bi;
            b = As;
            b = Dn;
            b = Pi;
            b = Dn;
        b = W0(b, Cg.bind(null, d));
  function Cg(d, p) {
    if (ah = -1, Ei = 0, Wn & 6) throw Error(n(327));
    if (pf() && d.callbackNode !== b) return null;
    var _ = ma(d, d === $o ? ii : 0);
    if (_ & 30 || _ & d.expiredLanes || p) p = xg(d, _);
      var N = Wn;
      Wn |= 2;
      var z = L0();
      ($o !== d || ii !== p) && (Ts = null, cf = wn() + 500, Kl(d, p));
          j0();
          $0(d, me);
      ob(), Hu.current = z, Wn = N, xo !== null ? p = 0 : ($o = null, ii = 0, p = co);
      if (p === 2 && (N = Eu(d), N !== 0 && (_ = N, p = lh(d, N))), p === 1) throw b = oh, Kl(d, 0), xa(d, _), us(d, wn()), b;
      if (p === 6) xa(d, _);
        if (N = d.current.alternate, !(_ & 30) && !Y1(N) && (p = xg(d, _), p === 2 && (z = Eu(d), z !== 0 && (_ = z, p = lh(d, z))), p === 1)) throw b = oh, Kl(d, 0), xa(d, _), us(d, wn()), b;
        switch (d.finishedWork = N, d.finishedLanes = _, p) {
            nd(d, ls, Ts);
            if (xa(d, _), (_ & 130023424) === _ && (p = Ob + 500 - wn(), 10 < p)) {
              if (ma(d, 0) !== 0) break;
              if (N = d.suspendedLanes, (N & _) !== _) {
                Eo(), d.pingedLanes |= d.suspendedLanes & N;
              d.timeoutHandle = jm(nd.bind(null, d, ls, Ts), p);
            nd(d, ls, Ts);
            if (xa(d, _), (_ & 4194240) === _) break;
            for (p = d.eventTimes, N = -1; 0 < _; ) {
              var oe = 31 - Mi(_);
              z = 1 << oe, oe = p[oe], oe > N && (N = oe), _ &= ~z;
            if (_ = N, _ = wn() - _, _ = (120 > _ ? 120 : 480 > _ ? 480 : 1080 > _ ? 1080 : 1920 > _ ? 1920 : 3e3 > _ ? 3e3 : 4320 > _ ? 4320 : 1960 * K1(_ / 1960)) - _, 10 < _) {
              d.timeoutHandle = jm(nd.bind(null, d, ls, Ts), _);
            nd(d, ls, Ts);
            nd(d, ls, Ts);
    return us(d, wn()), d.callbackNode === b ? Cg.bind(null, d) : null;
  function lh(d, p) {
    var b = ih;
    return d.current.memoizedState.isDehydrated && (Kl(d, p).flags |= 256), d = xg(d, p), d !== 2 && (p = ls, ls = b, p !== null && ed(p)), d;
  function ed(d) {
    ls === null ? ls = d : ls.push.apply(ls, d);
  function Y1(d) {
          var N = b[_], z = N.getSnapshot;
          N = N.value;
            if (!ya(z(), N)) return !1;
  function xa(d, p) {
    for (p &= ~wg, p &= ~uf, d.suspendedLanes |= p, d.pingedLanes &= ~p, d = d.expirationTimes; 0 < p; ) {
      var b = 31 - Mi(p), _ = 1 << b;
  function Rb(d) {
    if (Wn & 6) throw Error(n(327));
    pf();
    var p = ma(d, 0);
    if (!(p & 1)) return us(d, wn()), null;
    var b = xg(d, p);
      var _ = Eu(d);
      _ !== 0 && (p = _, b = lh(d, _));
    if (b === 1) throw b = oh, Kl(d, 0), xa(d, p), us(d, wn()), b;
    return d.finishedWork = d.current.alternate, d.finishedLanes = p, nd(d, ls, Ts), us(d, wn()), null;
  function kb(d, p) {
    var b = Wn;
    Wn |= 1;
      Wn = b, Wn === 0 && (cf = wn() + 500, tf && Xa());
  function td(d) {
    ql !== null && ql.tag === 0 && !(Wn & 6) && pf();
    var p = Wn;
    Wn |= 1;
    var b = oi.transition, _ = er;
      if (oi.transition = null, er = 1, d) return d();
      er = _, oi.transition = b, Wn = p, !(Wn & 6) && Xa();
  function Pb() {
    Es = lf.current, Ar(lf);
  function Kl(d, p) {
    if (b !== -1 && (d.timeoutHandle = -1, Zy(b)), xo !== null) for (b = xo.return; b !== null; ) {
      switch (Vm(_), _.tag) {
          _ = _.type.childContextTypes, _ != null && ef();
          Vc(), Ar(Ao), Ar(oo), Jt();
          qm(_);
          Vc();
          Ar(Zr);
          Ar(Zr);
          ib(_.type._context);
          Pb();
    if ($o = d, xo = d = Wu(d.current, null), ii = Es = p, co = 0, oh = null, wg = uf = rl = 0, ls = ih = null, Bc !== null) {
      for (p = 0; p < Bc.length; p++) if (b = Bc[p], _ = b.interleaved, _ !== null) {
        var N = _.next, z = b.pending;
        if (z !== null) {
          var oe = z.next;
          z.next = N, _.next = oe;
      Bc = null;
  function $0(d, p) {
      var b = xo;
        if (ob(), Mn.current = Yc, Ym) {
          for (var _ = nr.memoizedState; _ !== null; ) {
            var N = _.queue;
            N !== null && (N.pending = null), _ = _.next;
          Ym = !1;
        if (wr = 0, Vo = wo = nr = null, Fp = !1, Uc = 0, Jc.current = null, b === null || b.return === null) {
          co = 1, oh = p, xo = null;
          var z = d, oe = b.return, me = b, Se = p;
          if (p = ii, me.flags |= 32768, Se !== null && typeof Se == "object" && typeof Se.then == "function") {
            var Mt = x0(oe);
              Mt.flags &= -257, Bu(Mt, oe, me, z, p), Mt.mode & 1 && yb(z, Fe, p), p = Mt, Se = Fe;
                yb(z, Fe, p), Mb();
          } else if (Ur && me.mode & 1) {
            var fo = x0(oe);
            if (fo !== null) {
              !(fo.flags & 65536) && (fo.flags |= 256), Bu(fo, oe, me, z, p), Vl(Xc(Se, me));
          z = Se = Xc(Se, me), co !== 4 && (co = 2), ih === null ? ih = [z] : ih.push(z), z = oe;
            switch (z.tag) {
                z.flags |= 65536, p &= -p, z.lanes |= p;
                var ke = C0(z, Se, p);
                v0(z, ke);
                var Ee = z.type, Ae = z.stateNode;
                if (!(z.flags & 128) && (typeof Ee.getDerivedStateFromError == "function" || Ae !== null && typeof Ae.componentDidCatch == "function" && (Vu === null || !Vu.has(Ae)))) {
                  z.flags |= 65536, p &= -p, z.lanes |= p;
                  var lt = vb(z, me, p);
                  v0(z, lt);
            z = z.return;
          } while (z !== null);
        z0(b);
        p = Vt, xo === b && b !== null && (xo = b = b.return);
  function L0() {
    var d = Hu.current;
    return Hu.current = Yc, d === null ? Yc : d;
  function Mb() {
    (co === 0 || co === 3 || co === 2) && (co = 4), $o === null || !(rl & 268435455) && !(uf & 268435455) || xa($o, ii);
  function xg(d, p) {
    var b = Wn;
    Wn |= 2;
    var _ = L0();
    ($o !== d || ii !== p) && (Ts = null, Kl(d, p));
        X1();
      } catch (N) {
        $0(d, N);
    if (ob(), Wn = b, Hu.current = _, xo !== null) throw Error(n(261));
    return $o = null, ii = 0, co;
  function X1() {
    for (; xo !== null; ) F0(xo);
  function j0() {
    for (; xo !== null && !kr(); ) F0(xo);
  function F0(d) {
    var p = U0(d.alternate, d, Es);
    d.memoizedProps = d.pendingProps, p === null ? z0(d) : xo = p, Jc.current = null;
  function z0(d) {
        if (b = vg(b, p), b !== null) {
          b.flags &= 32767, xo = b;
          co = 6, xo = null;
      } else if (b = P0(b, p, Es), b !== null) {
        xo = b;
        xo = p;
      xo = p = d;
    co === 0 && (co = 5);
  function nd(d, p, b) {
    var _ = er, N = oi.transition;
      oi.transition = null, er = 1, Q1(d, p, b, _);
      oi.transition = N, er = _;
  function Q1(d, p, b, _) {
      pf();
    while (ql !== null);
    if (Wn & 6) throw Error(n(327));
    var N = d.finishedLanes;
    var z = b.lanes | b.childLanes;
    if (Iy(d, z), d === $o && (xo = $o = null, ii = 0), !(b.subtreeFlags & 2064) && !(b.flags & 2064) || Sg || (Sg = !0, W0(Dn, function() {
      return pf(), null;
    })), z = (b.flags & 15990) !== 0, b.subtreeFlags & 15990 || z) {
      z = oi.transition, oi.transition = null;
      var oe = er;
      er = 1;
      var me = Wn;
      Wn |= 4, Jc.current = null, I0(d, b), Eb(b, d), qd($c), Ls = !!kp, $c = kp = null, d.current = b, q1(b), ei(), Wn = me, er = oe, oi.transition = z;
    if (Sg && (Sg = !1, ql = d, sh = N), z = d.pendingLanes, z === 0 && (Vu = null), mp(b.stateNode), us(d, wn()), p !== null) for (_ = d.onRecoverableError, b = 0; b < p.length; b++) N = p[b], _(N.value, { componentStack: N.stack, digest: N.digest });
    if (df) throw df = !1, d = Zc, Zc = null, d;
    return sh & 1 && d.tag !== 0 && pf(), z = d.pendingLanes, z & 1 ? d === ff ? Uu++ : (Uu = 0, ff = d) : Uu = 0, Xa(), null;
  function pf() {
    if (ql !== null) {
      var d = Fd(sh), p = oi.transition, b = er;
        if (oi.transition = null, er = 16 > d ? 16 : d, ql === null) var _ = !1;
          if (d = ql, ql = null, sh = 0, Wn & 6) throw Error(n(331));
          var N = Wn;
          for (Wn |= 4, Nt = d.current; Nt !== null; ) {
            var z = Nt, oe = z.child;
              var me = z.deletions;
                        eh(8, at, z);
                      if (bg(at), at === Fe) {
                var Ht = z.alternate;
                      var fo = Gt.sibling;
                      Gt.sibling = null, Gt = fo;
                Nt = z;
            if (z.subtreeFlags & 2064 && oe !== null) oe.return = z, Nt = oe;
              if (z = Nt, z.flags & 2048) switch (z.tag) {
                  eh(9, z, z.return);
              var ke = z.sibling;
                ke.return = z.return, Nt = ke;
              Nt = z.return;
                    th(9, me);
                Wr(me, me.return, Vt);
          if (Wn = N, Xa(), wi && typeof wi.onPostCommitFiberRoot == "function") try {
            wi.onPostCommitFiberRoot(Ji, d);
        er = b, oi.transition = p;
  function B0(d, p, b) {
    p = Xc(b, p), p = C0(d, p, 1), d = ju(d, p, 1), p = Eo(), d !== null && (Al(d, 1, p), us(d, p));
  function Wr(d, p, b) {
    if (d.tag === 3) B0(d, d, b);
        B0(p, d, b);
        if (typeof p.type.getDerivedStateFromError == "function" || typeof _.componentDidCatch == "function" && (Vu === null || !Vu.has(_))) {
          d = Xc(b, d), d = vb(p, d, 1), p = ju(p, d, 1), d = Eo(), p !== null && (Al(p, 1, d), us(p, d));
  function J1(d, p, b) {
    _ !== null && _.delete(p), p = Eo(), d.pingedLanes |= d.suspendedLanes & b, $o === d && (ii & b) === b && (co === 4 || co === 3 && (ii & 130023424) === ii && 500 > wn() - Ob ? Kl(d, 0) : wg |= b), us(d, p);
  function H0(d, p) {
    p === 0 && (d.mode & 1 ? (p = bs, bs <<= 1, !(bs & 130023424) && (bs = 4194304)) : p = 1);
    var b = Eo();
    d = Cs(d, p), d !== null && (Al(d, p, b), us(d, b));
  function Z1(d) {
    p !== null && (b = p.retryLane), H0(d, b);
  function V0(d, p) {
        var _ = d.stateNode, N = d.memoizedState;
        N !== null && (b = N.retryLane);
    _ !== null && _.delete(p), H0(d, b);
  var U0;
  U0 = function(d, p, b) {
    if (d !== null) if (d.memoizedProps !== p.pendingProps || Ao.current) So = !0;
      if (!(d.lanes & b) && !(p.flags & 128)) return So = !1, Qp(d, p, b);
      So = !!(d.flags & 131072);
    else So = !1, Ur && p.flags & 1048576 && p0(p, Hl, p.index);
        Us(d, p), d = p.pendingProps;
        var N = ts(p, oo.current);
        Jr(p, b), N = Fu(null, p, _, d, N, b);
        var z = wa();
        return p.flags |= 1, typeof N == "object" && N !== null && typeof N.render == "function" && N.$$typeof === void 0 ? (p.tag = 1, p.memoizedState = null, p.updateQueue = null, yo(_) ? (z = !0, Ho(p)) : z = !1, p.memoizedState = N.state !== null && N.state !== void 0 ? N.state : null, ub(p), N.updater = fg, p.stateNode = N, N._reactInternals = p, Gp(p, _, d, b), p = Yp(null, p, _, !0, z, b)) : (p.tag = 0, Ur && z && Hm(p), ri(null, p, N, b), p = p.child), p;
          switch (Us(d, p), d = p.pendingProps, N = _._init, _ = N(_._payload), p.type = _, N = p.tag = tO(_), d = Sa(_, d), N) {
              p = E0(null, p, _, d, b);
              p = T0(null, p, _, d, b);
              p = ss(null, p, _, d, b);
              p = Qc(null, p, _, Sa(_.type, d), b);
        return _ = p.type, N = p.pendingProps, N = p.elementType === _ ? N : Sa(_, N), E0(d, p, _, N, b);
        return _ = p.type, N = p.pendingProps, N = p.elementType === _ ? N : Sa(_, N), T0(d, p, _, N, b);
          if (sf(p), d === null) throw Error(n(387));
          _ = p.pendingProps, z = p.memoizedState, N = z.element, g0(d, p), Ap(p, _, null, b);
          if (_ = oe.element, z.isDehydrated) if (z = { element: _, isDehydrated: !1, cache: oe.cache, pendingSuspenseBoundaries: oe.pendingSuspenseBoundaries, transitions: oe.transitions }, p.updateQueue.baseState = z, p.memoizedState = z, p.flags & 256) {
            N = Xc(Error(n(423)), p), p = _0(d, p, _, b, N);
          } else if (_ !== N) {
            N = Xc(Error(n(424)), p), p = _0(d, p, _, b, N);
          } else for (rs = qa(p.stateNode.containerInfo.firstChild), ns = p, Ur = !0, Hs = null, b = Rt(p, null, _, b), p.child = b; b; ) b.flags = b.flags & -3 | 4096, b = b.sibling;
            if (Lu(), _ === N) {
              p = Ws(d, p, b);
            ri(d, p, _, b);
        return y0(p), d === null && nb(p), _ = p.type, N = p.pendingProps, z = d !== null ? d.memoizedProps : null, oe = N.children, Lm(_, N) ? oe = null : z !== null && Lm(_, z) && (p.flags |= 32), bb(d, p), ri(d, p, oe, b), p.child;
        return d === null && nb(p), null;
        return gg(d, p, b);
        return db(p, p.stateNode.containerInfo), _ = p.pendingProps, d === null ? p.child = ao(p, null, _, b) : ri(d, p, _, b), p.child;
        return _ = p.type, N = p.pendingProps, N = p.elementType === _ ? N : Sa(_, N), ss(d, p, _, N, b);
        return ri(d, p, p.pendingProps, b), p.child;
        return ri(d, p, p.pendingProps.children, b), p.child;
        return ri(d, p, p.pendingProps.children, b), p.child;
          if (_ = p.type._context, N = p.pendingProps, z = p.memoizedProps, oe = N.value, Xt(Ss, _._currentValue), _._currentValue = oe, z !== null) if (ya(z.value, oe)) {
            if (z.children === N.children && !Ao.current) {
              p = Ws(d, p, b);
          } else for (z = p.child, z !== null && (z.return = p); z !== null; ) {
            var me = z.dependencies;
              oe = z.child;
                  if (z.tag === 1) {
                    Se = Ul(-1, b & -b), Se.tag = 2;
                    var Fe = z.updateQueue;
                  z.lanes |= b, Se = z.alternate, Se !== null && (Se.lanes |= b), sb(
                    z.return,
            } else if (z.tag === 10) oe = z.type === p.type ? null : z.child;
            else if (z.tag === 18) {
              if (oe = z.return, oe === null) throw Error(n(341));
              oe.lanes |= b, me = oe.alternate, me !== null && (me.lanes |= b), sb(oe, b, p), oe = z.sibling;
            } else oe = z.child;
            if (oe !== null) oe.return = z;
            else for (oe = z; oe !== null; ) {
              if (z = oe.sibling, z !== null) {
                z.return = oe.return, oe = z;
            z = oe;
          ri(d, p, N.children, b), p = p.child;
        return N = p.type, _ = p.pendingProps.children, Jr(p, b), N = Vs(N), _ = _(N), p.flags |= 1, ri(d, p, _, b), p.child;
        return _ = p.type, N = Sa(_, p.pendingProps), N = Sa(_.type, N), Qc(d, p, _, N, b);
        return _n(d, p, p.type, p.pendingProps, b);
        return _ = p.type, N = p.pendingProps, N = p.elementType === _ ? N : Sa(_, N), Us(d, p), p.tag = 1, yo(_) ? (d = !0, Ho(p)) : d = !1, Jr(p, b), pg(p, _, N), Gp(p, _, N, b), Yp(null, p, _, !0, d, b);
        return el(d, p, b);
        return Kp(d, p, b);
  function W0(d, p) {
  function eO(d, p, b, _) {
  function qs(d, p, b, _) {
    return new eO(d, p, b, _);
  function Ib(d) {
  function tO(d) {
    if (typeof d == "function") return Ib(d) ? 1 : 0;
      if (d = d.$$typeof, d === U) return 11;
  function Wu(d, p) {
    return b === null ? (b = qs(d.tag, p, d.key, d.mode), b.elementType = d.elementType, b.type = d.type, b.stateNode = d.stateNode, b.alternate = d, d.alternate = b) : (b.pendingProps = p, b.type = d.type, b.flags = 0, b.subtreeFlags = 0, b.deletions = null), b.flags = d.flags & 14680064, b.childLanes = d.childLanes, b.lanes = d.lanes, b.child = d.child, b.memoizedProps = d.memoizedProps, b.memoizedState = d.memoizedState, b.updateQueue = d.updateQueue, p = d.dependencies, b.dependencies = p === null ? null : { lanes: p.lanes, firstContext: p.firstContext }, b.sibling = d.sibling, b.index = d.index, b.ref = d.ref, b;
  function uh(d, p, b, _, N, z) {
    if (_ = d, typeof d == "function") Ib(d) && (oe = 1);
      case B:
        return Yl(b.children, N, z, p);
        oe = 8, N |= 8;
      case F:
        return d = qs(12, b, p, N | 2), d.elementType = F, d.lanes = z, d;
      case K:
        return d = qs(13, b, p, N), d.elementType = K, d.lanes = z, d;
        return d = qs(19, b, p, N), d.elementType = ee, d.lanes = z, d;
        return Gu(b, N, z, p);
          case D:
          case U:
          case Y:
    return p = qs(oe, b, p, N), p.elementType = d, p.type = _, p.lanes = z, p;
  function Yl(d, p, b, _) {
    return d = qs(7, d, _, p), d.lanes = b, d;
  function Gu(d, p, b, _) {
    return d = qs(22, d, _, p), d.elementType = X, d.lanes = b, d.stateNode = { isHidden: !1 }, d;
  function Db(d, p, b) {
    return d = qs(6, d, null, p), d.lanes = b, d;
  function Eg(d, p, b) {
    return p = qs(4, d.children !== null ? d.children : [], d.key, p), p.lanes = b, p.stateNode = { containerInfo: d.containerInfo, pendingChildren: null, implementation: d.implementation }, p;
  function G0(d, p, b, _, N) {
    this.tag = p, this.containerInfo = d, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = jd(0), this.expirationTimes = jd(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = jd(0), this.identifierPrefix = _, this.onRecoverableError = N, this.mutableSourceEagerHydrationData = null;
  function Tg(d, p, b, _, N, z, oe, me, Se) {
    return d = new G0(d, p, b, me, Se), p === 1 ? (p = 1, z === !0 && (p |= 8)) : p = 0, z = qs(3, null, null, p), d.current = z, z.stateNode = d, z.memoizedState = { element: _, isDehydrated: b, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ub(z), d;
  function nO(d, p, b) {
    return { $$typeof: j, key: _ == null ? null : "" + _, children: d, containerInfo: p, implementation: b };
  function Ab(d) {
    if (!d) return Si;
      if (hn(d) !== d || d.tag !== 1) throw Error(n(170));
            if (yo(p.type)) {
      if (yo(b)) return Ip(d, b, p);
  function q0(d, p, b, _, N, z, oe, me, Se) {
    return d = Tg(b, _, !0, d, N, z, oe, me, Se), d.context = Ab(null), b = d.current, _ = Eo(), N = ol(b), z = Ul(_, N), z.callback = p ?? null, ju(b, z, N), d.current.lanes = N, Al(d, N, _), us(d, _), d;
  function _g(d, p, b, _) {
    var N = p.current, z = Eo(), oe = ol(N);
    return b = Ab(b), p.context === null ? p.context = b : p.pendingContext = b, p = Ul(z, oe), p.payload = { element: d }, _ = _ === void 0 ? null : _, _ !== null && (p.callback = _), d = ju(N, p, oe), d !== null && (Li(d, N, oe, z), Gm(d, N, oe)), oe;
  function Og(d) {
  function Nb(d, p) {
  function Rg(d, p) {
    Nb(d, p), (d = d.alternate) && Nb(d, p);
  function K0() {
  var rd = typeof reportError == "function" ? reportError : function(d) {
  function $b(d) {
  kg.prototype.render = $b.prototype.render = function(d) {
    _g(d, p, null, null);
  }, kg.prototype.unmount = $b.prototype.unmount = function() {
      td(function() {
        _g(null, d, null, null);
      }), p[zl] = null;
  function kg(d) {
  kg.prototype.unstable_scheduleHydration = function(d) {
      var p = yn();
      for (var b = 0; b < Do.length && p !== 0 && p < Do[b].priority; b++) ;
      Do.splice(b, 0, d), b === 0 && yp(d);
  function Lb(d) {
  function Pg(d) {
  function Y0() {
  function rO(d, p, b, _, N) {
    if (N) {
        var z = _;
          var Fe = Og(oe);
          z.call(Fe);
      var oe = q0(p, _, d, 0, null, !1, !1, "", Y0);
      return d._reactRootContainer = oe, d[zl] = oe.current, Yd(d.nodeType === 8 ? d.parentNode : d), td(), oe;
    for (; N = d.lastChild; ) d.removeChild(N);
        var Fe = Og(Se);
    var Se = Tg(d, 0, !1, null, null, !1, !1, "", Y0);
    return d._reactRootContainer = Se, d[zl] = Se.current, Yd(d.nodeType === 8 ? d.parentNode : d), td(function() {
      _g(p, Se, b, _);
  function ch(d, p, b, _, N) {
    var z = b._reactRootContainer;
    if (z) {
      var oe = z;
      if (typeof N == "function") {
        var me = N;
        N = function() {
          var Se = Og(oe);
      _g(p, oe, d, N);
    } else oe = rO(b, p, d, N, _);
    return Og(oe);
  Yn = function(d) {
          var b = ha(p.pendingLanes);
          b !== 0 && (Nl(p, b | 1), us(p, wn()), !(Wn & 6) && (cf = wn() + 500, Xa()));
        td(function() {
          var _ = Cs(d, 1);
            var N = Eo();
            Li(_, d, 1, N);
        }), Rg(d, 1);
  }, gp = function(d) {
      var p = Cs(d, 134217728);
        var b = Eo();
      Rg(d, 134217728);
  }, Ha = function(d) {
      var p = ol(d), b = Cs(d, p);
        var _ = Eo();
      Rg(d, p);
  }, yn = function() {
    return er;
  }, zd = function(d, p) {
    var b = er;
      return er = d, p();
      er = b;
  }, pn = function(d, p, b) {
        if (Le(d, b), p = b.name, b.type === "radio" && p != null) {
              var N = Qr(_);
              if (!N) throw Error(n(90));
              ce(_), Le(_, N);
  }, Jo = kb, Wt = td;
  var oO = { usingClientEntryPoint: !1, Events: [Qt, ba, Qr, Rr, Qo, kb] }, dh = { findFiberByHostInstance: Lc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, X0 = { bundleType: dh.bundleType, version: dh.version, rendererPackageName: dh.rendererPackageName, rendererConfig: dh.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: A.ReactCurrentDispatcher, findHostInstanceByFiber: function(d) {
  }, findFiberByHostInstance: dh.findFiberByHostInstance || K0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
    var qu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!qu.isDisabled && qu.supportsFiber) try {
      Ji = qu.inject(X0), wi = qu;
  return Zs.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oO, Zs.createPortal = function(d, p) {
    if (!Lb(p)) throw Error(n(200));
    return nO(d, p, null, b);
  }, Zs.createRoot = function(d, p) {
    if (!Lb(d)) throw Error(n(299));
    var b = !1, _ = "", N = rd;
    return p != null && (p.unstable_strictMode === !0 && (b = !0), p.identifierPrefix !== void 0 && (_ = p.identifierPrefix), p.onRecoverableError !== void 0 && (N = p.onRecoverableError)), p = Tg(d, 1, !1, null, null, b, !1, _, N), d[zl] = p.current, Yd(d.nodeType === 8 ? d.parentNode : d), new $b(p);
  }, Zs.findDOMNode = function(d) {
  }, Zs.flushSync = function(d) {
    return td(d);
  }, Zs.hydrate = function(d, p, b) {
    if (!Pg(p)) throw Error(n(200));
    return ch(null, d, p, !0, b);
  }, Zs.hydrateRoot = function(d, p, b) {
    if (!Lb(d)) throw Error(n(405));
    var _ = b != null && b.hydratedSources || null, N = !1, z = "", oe = rd;
    if (b != null && (b.unstable_strictMode === !0 && (N = !0), b.identifierPrefix !== void 0 && (z = b.identifierPrefix), b.onRecoverableError !== void 0 && (oe = b.onRecoverableError)), p = q0(p, null, d, 1, b ?? null, N, !1, z, oe), d[zl] = p.current, Yd(d), _) for (d = 0; d < _.length; d++) b = _[d], N = b._getVersion, N = N(b._source), p.mutableSourceEagerHydrationData == null ? p.mutableSourceEagerHydrationData = [b, N] : p.mutableSourceEagerHydrationData.push(
      N
    return new kg(p);
  }, Zs.render = function(d, p, b) {
    if (!Pg(p)) throw Error(n(200));
    return ch(null, d, p, !1, b);
  }, Zs.unmountComponentAtNode = function(d) {
    if (!Pg(d)) throw Error(n(40));
    return d._reactRootContainer ? (td(function() {
      ch(null, null, d, !1, function() {
        d._reactRootContainer = null, d[zl] = null;
  }, Zs.unstable_batchedUpdates = kb, Zs.unstable_renderSubtreeIntoContainer = function(d, p, b, _) {
    if (!Pg(b)) throw Error(n(200));
    return ch(d, p, b, !1, _);
  }, Zs.version = "18.3.1-next-f1338f8080-20240426", Zs;
var ea = {};
var ej;
function aK() {
  return ej || (ej = 1, process.env.NODE_ENV !== "production" && function() {
    var e = x, t = JB(), n = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
        for (var l = arguments.length, m = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++)
          m[y - 1] = arguments[y];
        c("warn", i, m);
        for (var l = arguments.length, m = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++)
          m[y - 1] = arguments[y];
        c("error", i, m);
    function c(i, l, m) {
        var y = n.ReactDebugCurrentFrame, S = y.getStackAddendum();
        S !== "" && (l += "%s", m = m.concat([S]));
        var R = m.map(function(L) {
    var f = 0, h = 1, g = 2, v = 3, w = 4, C = 5, T = 6, E = 7, O = 8, P = 9, I = 10, M = 11, A = 12, k = 13, j = 14, B = 15, H = 16, F = 17, D = 18, q = 19, U = 21, K = 22, ee = 23, G = 24, Y = 25, X = !0, te = !1, re = !1, Q = !1, V = !1, ie = !0, de = !0, ue = !0, he = !0, ge = /* @__PURE__ */ new Set(), fe = {}, pe = {};
        var m = i.toLowerCase();
        pe[m] = i, i === "onDoubleClick" && (pe.ondblclick = i);
      for (var y = 0; y < l.length; y++)
        ge.add(l[y]);
        var l = typeof Symbol == "function" && Symbol.toStringTag, m = l && i[Symbol.toStringTag] || i.constructor.name || "Object";
        return m;
    function Le(i) {
    function bt(i, l, m) {
      return l !== null ? l.type === nt : m ? !1 : i.length > 2 && (i[0] === "o" || i[0] === "O") && (i[1] === "n" || i[1] === "N");
    function We(i, l, m, y) {
      if (m !== null && m.type === nt)
          if (y)
          if (m !== null)
            return !m.acceptsBooleans;
    function St(i, l, m, y) {
      if (l === null || typeof l > "u" || We(i, l, m, y))
      if (y)
      if (m !== null)
        switch (m.type) {
    function Lt(i) {
      return pn.hasOwnProperty(i) ? pn[i] : null;
    function Cn(i, l, m, y, S, R, L) {
      this.acceptsBooleans = l === ut || l === Et || l === Tt, this.attributeName = y, this.attributeNamespace = S, this.mustUseProperty = m, this.propertyName = i, this.type = l, this.sanitizeURL = R, this.removeEmptyString = L;
    var pn = {}, Or = [
    Or.forEach(function(i) {
      pn[i] = new Cn(
      var l = i[0], m = i[1];
      pn[l] = new Cn(
        m,
      pn[i] = new Cn(
      pn[i] = new Cn(
      pn[i] = new Cn(
      pn[i] = new Cn(
      pn[i] = new Cn(
      pn[i] = new Cn(
      pn[i] = new Cn(
    var lr = /[\-\:]([a-z])/g, Fr = function(i) {
      var l = i.replace(lr, Fr);
      pn[l] = new Cn(
      var l = i.replace(lr, Fr);
      pn[l] = new Cn(
      var l = i.replace(lr, Fr);
      pn[l] = new Cn(
      pn[i] = new Cn(
    var Rr = "xlinkHref";
    pn[Rr] = new Cn(
      pn[i] = new Cn(
    var Qo = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Jo = !1;
      !Jo && Qo.test(i) && (Jo = !0, a("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(i)));
    function gr(i, l, m, y) {
      if (y.mustUseProperty) {
        var S = y.propertyName;
        tt(m, l), y.sanitizeURL && Wt("" + m);
        var R = y.attributeName, L = null;
        if (y.type === Tt) {
            var W = i.getAttribute(R);
            return W === "" ? !0 : St(l, m, y, !1) ? W : W === "" + m ? m : W;
          if (St(l, m, y, !1))
          if (y.type === Et)
            return m;
        return St(l, m, y, !1) ? L === null ? m : L : L === "" + m ? m : L;
    function Zo(i, l, m, y) {
          return m === void 0 ? void 0 : null;
        return tt(m, l), S === "" + m ? m : S;
    function Kr(i, l, m, y) {
      var S = Lt(l);
      if (!bt(l, S, y)) {
        if (St(l, m, S, y) && (m = null), y || S === null) {
            m === null ? i.removeAttribute(R) : (tt(m, l), i.setAttribute(R, "" + m));
          var W = S.propertyName;
          if (m === null) {
            i[W] = Z === Et ? !1 : "";
            i[W] = m;
        if (m === null)
          Te === Et || Te === Tt && m === !0 ? xe = "" : (tt(m, ae), xe = "" + m, S.sanitizeURL && Wt(xe.toString())), le ? i.setAttributeNS(le, ae, xe) : i.setAttribute(ae, xe);
    var so = Symbol.for("react.element"), Yr = Symbol.for("react.portal"), Yi = Symbol.for("react.fragment"), ki = Symbol.for("react.strict_mode"), Xi = Symbol.for("react.profiler"), Qi = Symbol.for("react.provider"), ye = Symbol.for("react.context"), Ye = Symbol.for("react.forward_ref"), ft = Symbol.for("react.suspense"), Ct = Symbol.for("react.suspense_list"), hn = Symbol.for("react.memo"), De = Symbol.for("react.lazy"), Re = Symbol.for("react.scope"), Je = Symbol.for("react.debug_trace_mode"), Bt = Symbol.for("react.offscreen"), jt = Symbol.for("react.legacy_hidden"), Kt = Symbol.for("react.cache"), Ln = Symbol.for("react.tracing_marker"), kr = Symbol.iterator, ei = "@@iterator";
    function wn(i) {
      var l = kr && i[kr] || i[ei];
    var xn = Object.assign, bi = 0, As, Dn, Io, Pi, Ji, wi, mp;
    function Mi() {
    Mi.__reactDisabledLog = !0;
    function Cm() {
        if (bi === 0) {
          As = console.log, Dn = console.info, Io = console.warn, Pi = console.error, Ji = console.group, wi = console.groupCollapsed, mp = console.groupEnd;
            value: Mi,
        bi++;
    function xm() {
        if (bi--, bi === 0) {
            log: xn({}, i, {
              value: As
            info: xn({}, i, {
              value: Dn
            warn: xn({}, i, {
              value: Io
            error: xn({}, i, {
              value: Pi
            group: xn({}, i, {
              value: Ji
            groupCollapsed: xn({}, i, {
              value: wi
            groupEnd: xn({}, i, {
              value: mp
        bi < 0 && a("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    var Nd = n.ReactCurrentDispatcher, xu;
    function bs(i, l, m) {
        if (xu === void 0)
            var y = S.stack.trim().match(/\n( *(at )?)/);
            xu = y && y[1] || "";
` + xu + i;
    var ha = !1, ma;
      var $d = typeof WeakMap == "function" ? WeakMap : Map;
      ma = new $d();
    function Oc(i, l) {
      if (!i || ha)
        var m = ma.get(i);
        if (m !== void 0)
          return m;
      var y;
      ha = !0;
      R = Nd.current, Nd.current = null, Cm();
              y = ze;
              y = ze;
            y = ze;
        if (ze && y && typeof ze.stack == "string") {
          for (var W = ze.stack.split(`
`), Z = y.stack.split(`
`), ae = W.length - 1, le = Z.length - 1; ae >= 1 && le >= 0 && W[ae] !== Z[le]; )
            if (W[ae] !== Z[le]) {
                  if (ae--, le--, le < 0 || W[ae] !== Z[le]) {
` + W[ae].replace(" at new ", " at ");
                    return i.displayName && Te.includes("<anonymous>") && (Te = Te.replace("<anonymous>", i.displayName)), typeof i == "function" && ma.set(i, Te), Te;
        ha = !1, Nd.current = R, xm(), Error.prepareStackTrace = S;
      var xe = i ? i.displayName || i.name : "", $e = xe ? bs(xe) : "";
      return typeof i == "function" && ma.set(i, $e), $e;
    function Eu(i, l, m) {
      return Oc(i, !0);
    function Ld(i, l, m) {
      return Oc(i, !1);
    function jd(i) {
    function Al(i, l, m) {
        return Oc(i, jd(i));
        return bs(i);
          return bs("Suspense");
          return bs("SuspenseList");
            return Ld(i.render);
          case hn:
            return Al(i.type, l, m);
            var y = i, S = y._payload, R = y._init;
              return Al(R(S), l, m);
    function Iy(i) {
          return bs(i.type);
        case H:
          return bs("Lazy");
        case k:
          return bs("Suspense");
          return bs("SuspenseList");
        case B:
          return Ld(i.type);
          return Ld(i.type.render);
        case h:
          return Eu(i.type);
    function Nl(i) {
        var l = "", m = i;
          l += Iy(m), m = m.return;
        while (m);
      } catch (y) {
Error generating stack: ` + y.message + `
` + y.stack;
    function er(i, l, m) {
      var y = i.displayName;
      if (y)
        return y;
      return S !== "" ? m + "(" + S + ")" : m;
    function Fd(i) {
    function Yn(i) {
        case Yi:
        case Yr:
        case Xi:
        case ki:
            return Fd(l) + ".Consumer";
          case Qi:
            var m = i;
            return Fd(m._context) + ".Provider";
            return er(i, i.render, "ForwardRef");
          case hn:
            var y = i.displayName || null;
            return y !== null ? y : Yn(i.type) || "Memo";
              return Yn(L(R));
    function gp(i, l, m) {
      var y = l.displayName || l.name || "";
      return i.displayName || (y !== "" ? m + "(" + y + ")" : m);
    function Ha(i) {
    function yn(i) {
      var l = i.tag, m = i.type;
        case P:
          var y = m;
          return Ha(y) + ".Consumer";
          var S = m;
          return Ha(S._context) + ".Provider";
        case D:
          return gp(m, m.render, "ForwardRef");
          return m;
        case v:
        case H:
          return Yn(m);
          return m === ki ? "StrictMode" : "Mode";
        case K:
        case A:
        case U:
        case k:
        case Y:
        case h:
        case g:
        case j:
        case B:
          if (typeof m == "function")
            return m.displayName || m.name || null;
          if (typeof m == "string")
            return m;
    var zd = n.ReactDebugCurrentFrame, ti = null, Va = !1;
    function Ii() {
        if (ti === null)
        var i = ti._debugOwner;
          return yn(i);
    function Ua() {
      return ti === null ? "" : Nl(ti);
    function zr() {
      zd.getCurrentStack = null, ti = null, Va = !1;
    function vr(i) {
      zd.getCurrentStack = i === null ? null : Ua, ti = i, Va = !1;
    function Tu() {
      return ti;
    function Do(i) {
      Va = i;
    function Di(i) {
    function Ns(i) {
    var Rc = {
    function vp(i, l) {
      Rc[l.type] || l.onChange || l.onInput || l.readOnly || l.disabled || l.value == null || a("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), l.onChange || l.readOnly || l.disabled || l.checked == null || a("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    function yp(i) {
      var l = i.type, m = i.nodeName;
      return m && m.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
    function _u(i) {
    function kc(i) {
    function Dy(i) {
      return i && (yp(i) ? l = i.checked ? "true" : "false" : l = i.value), l;
    function $s(i) {
      var l = yp(i) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(i.constructor.prototype, l);
      var y = "" + i[l];
      if (!(i.hasOwnProperty(l) || typeof m > "u" || typeof m.get != "function" || typeof m.set != "function")) {
        var S = m.get, R = m.set;
          set: function(W) {
            gt(W), y = "" + W, R.call(this, W);
          enumerable: m.enumerable
            return y;
          setValue: function(W) {
            gt(W), y = "" + W;
            kc(i), delete i[l];
    function ga(i) {
      _u(i) || (i._valueTracker = $s(i));
    function Wa(i) {
      var l = _u(i);
      var m = l.getValue(), y = Dy(i);
      return y !== m ? (l.setValue(y), !0) : !1;
    var Bd = !1, Hd = !1, Ou = !1, Pc = !1;
    function Vd(i) {
    function Ud(i, l) {
      var m = i, y = l.checked, S = xn({}, l, {
        checked: y ?? m._wrapperState.initialChecked
    function va(i, l) {
      vp("input", l), l.checked !== void 0 && l.defaultChecked !== void 0 && !Hd && (a("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Ii() || "A component", l.type), Hd = !0), l.value !== void 0 && l.defaultValue !== void 0 && !Bd && (a("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Ii() || "A component", l.type), Bd = !0);
      var m = i, y = l.defaultValue == null ? "" : l.defaultValue;
      m._wrapperState = {
        initialValue: Ns(l.value != null ? l.value : y),
        controlled: Vd(l)
      var m = i, y = l.checked;
      y != null && Kr(m, "checked", y, !1);
      var m = i;
        var y = Vd(l);
        !m._wrapperState.controlled && y && !Pc && (a("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Pc = !0), m._wrapperState.controlled && !y && !Ou && (a("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Ou = !0);
      var S = Ns(l.value), R = l.type;
        R === "number" ? (S === 0 && m.value === "" || // We explicitly want to coerce to number here if possible.
        m.value != S) && (m.value = Di(S)) : m.value !== Di(S) && (m.value = Di(S));
        m.removeAttribute("value");
      l.hasOwnProperty("value") ? tn(m, l.type, S) : l.hasOwnProperty("defaultValue") && tn(m, l.type, Ns(l.defaultValue)), l.checked == null && l.defaultChecked != null && (m.defaultChecked = !!l.defaultChecked);
    function je(i, l, m) {
      var y = i;
        var L = Di(y._wrapperState.initialValue);
        m || L !== y.value && (y.value = L), y.defaultValue = L;
      var W = y.name;
      W !== "" && (y.name = ""), y.defaultChecked = !y.defaultChecked, y.defaultChecked = !!y._wrapperState.initialChecked, W !== "" && (y.name = W);
      var m = i;
      ve(m, l), ht(m, l);
      var m = l.name;
      if (l.type === "radio" && m != null) {
        for (var y = i; y.parentNode; )
          y = y.parentNode;
        tt(m, "name");
        for (var S = y.querySelectorAll("input[name=" + JSON.stringify("" + m) + '][type="radio"]'), R = 0; R < S.length; R++) {
            var W = hx(L);
            if (!W)
            Wa(L), ve(L, W);
    function tn(i, l, m) {
      (l !== "number" || Ls(i.ownerDocument) !== i) && (m == null ? i.defaultValue = Di(i._wrapperState.initialValue) : i.defaultValue !== Di(m) && (i.defaultValue = Di(m)));
    var _t = !1, sn = !1, An = !1;
    function Xn(i, l) {
      l.value == null && (typeof l.children == "object" && l.children !== null ? e.Children.forEach(l.children, function(m) {
        m != null && (typeof m == "string" || typeof m == "number" || sn || (sn = !0, a("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : l.dangerouslySetInnerHTML != null && (An || (An = !0, a("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), l.selected != null && !_t && (a("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), _t = !0);
    function Dr(i, l) {
      l.value != null && i.setAttribute("value", Di(Ns(l.value)));
    var yr = Array.isArray;
    function Pn(i) {
      return yr(i);
    var br;
    br = !1;
    function Xr() {
      var i = Ii();
    var Ru = ["value", "defaultValue"];
    function bp(i) {
        vp("select", i);
        for (var l = 0; l < Ru.length; l++) {
          var m = Ru[l];
          if (i[m] != null) {
            var y = Pn(i[m]);
            i.multiple && !y ? a("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", m, Xr()) : !i.multiple && y && a("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", m, Xr());
    function $l(i, l, m, y) {
        for (var R = m, L = {}, W = 0; W < R.length; W++)
          L["$" + R[W]] = !0;
          S[Z].selected !== ae && (S[Z].selected = ae), ae && y && (S[Z].defaultSelected = !0);
        for (var le = Di(Ns(m)), Te = null, xe = 0; xe < S.length; xe++) {
            S[xe].selected = !0, y && (S[xe].defaultSelected = !0);
    function wp(i, l) {
      return xn({}, l, {
    function Mc(i, l) {
      var m = i;
      bp(l), m._wrapperState = {
      }, l.value !== void 0 && l.defaultValue !== void 0 && !br && (a("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), br = !0);
    function Ay(i, l) {
      var m = i;
      m.multiple = !!l.multiple;
      var y = l.value;
      y != null ? $l(m, !!l.multiple, y, !1) : l.defaultValue != null && $l(m, !!l.multiple, l.defaultValue, !0);
    function Em(i, l) {
      var m = i, y = m._wrapperState.wasMultiple;
      m._wrapperState.wasMultiple = !!l.multiple;
      S != null ? $l(m, !!l.multiple, S, !1) : y !== !!l.multiple && (l.defaultValue != null ? $l(m, !!l.multiple, l.defaultValue, !0) : $l(m, !!l.multiple, l.multiple ? [] : "", !1));
    function Ny(i, l) {
      var m = i, y = l.value;
      y != null && $l(m, !!l.multiple, y, !1);
    var LC = !1;
    function $y(i, l) {
      var m = i;
      var y = xn({}, l, {
        children: Di(m._wrapperState.initialValue)
      return y;
    function Ly(i, l) {
      var m = i;
      vp("textarea", l), l.value !== void 0 && l.defaultValue !== void 0 && !LC && (a("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Ii() || "A component"), LC = !0);
      var y = l.value;
      if (y == null) {
            if (Pn(S)) {
        R == null && (R = ""), y = R;
      m._wrapperState = {
        initialValue: Ns(y)
    function jC(i, l) {
      var m = i, y = Ns(l.value), S = Ns(l.defaultValue);
      if (y != null) {
        var R = Di(y);
        R !== m.value && (m.value = R), l.defaultValue == null && m.defaultValue !== R && (m.defaultValue = R);
      S != null && (m.defaultValue = Di(S));
    function FC(i, l) {
      var m = i, y = m.textContent;
      y === m._wrapperState.initialValue && y !== "" && y !== null && (m.value = y);
    function D1(i, l) {
      jC(i, l);
    var Ll = "http://www.w3.org/1999/xhtml", jy = "http://www.w3.org/1998/Math/MathML", Fy = "http://www.w3.org/2000/svg";
    function zy(i) {
          return Fy;
          return jy;
          return Ll;
    function By(i, l) {
      return i == null || i === Ll ? zy(l) : i === Fy && l === "foreignObject" ? Ll : i;
    var zC = function(i) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(l, m, y, S) {
          return i(l, m, y, S);
    }, Tm, BC = zC(function(i, l) {
      if (i.namespaceURI === Fy && !("innerHTML" in i)) {
        Tm = Tm || document.createElement("div"), Tm.innerHTML = "<svg>" + l.valueOf().toString() + "</svg>";
        for (var m = Tm.firstChild; i.firstChild; )
        for (; m.firstChild; )
          i.appendChild(m.firstChild);
    }), Zi = 1, jl = 3, vo = 8, Fl = 9, Hy = 11, Wd = function(i, l) {
        var m = i.firstChild;
        if (m && m === i.lastChild && m.nodeType === jl) {
          m.nodeValue = l;
    }, Sp = {
    }, Cp = {
    function HC(i, l) {
    var VC = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Cp).forEach(function(i) {
      VC.forEach(function(l) {
        Cp[HC(l, i)] = Cp[i];
    function _m(i, l, m) {
      var y = l == null || typeof l == "boolean" || l === "";
      return y ? "" : !m && typeof l == "number" && l !== 0 && !(Cp.hasOwnProperty(i) && Cp[i]) ? l + "px" : (ot(l, i), ("" + l).trim());
    var UC = /([A-Z])/g, WC = /^ms-/;
    function Gd(i) {
      return i.replace(UC, "-$1").toLowerCase().replace(WC, "-ms-");
    var GC = function() {
      var A1 = /^(?:webkit|moz|o)[A-Z]/, N1 = /^-ms-/, qC = /-(.)/g, Vy = /;\s*$/, Ga = {}, Ic = {}, KC = !1, xp = !1, $1 = function(i) {
        return i.replace(qC, function(l, m) {
          return m.toUpperCase();
      }, YC = function(i) {
        Ga.hasOwnProperty(i) && Ga[i] || (Ga[i] = !0, a(
          $1(i.replace(N1, "ms-"))
      }, Uy = function(i) {
        Ga.hasOwnProperty(i) && Ga[i] || (Ga[i] = !0, a("Unsupported vendor-prefixed style property %s. Did you mean %s?", i, i.charAt(0).toUpperCase() + i.slice(1)));
      }, Wy = function(i, l) {
        Ic.hasOwnProperty(l) && Ic[l] || (Ic[l] = !0, a(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, i, l.replace(Vy, "")));
      }, XC = function(i, l) {
        KC || (KC = !0, a("`NaN` is an invalid value for the `%s` css style property.", i));
      }, QC = function(i, l) {
        xp || (xp = !0, a("`Infinity` is an invalid value for the `%s` css style property.", i));
      GC = function(i, l) {
        i.indexOf("-") > -1 ? YC(i) : A1.test(i) ? Uy(i) : Vy.test(l) && Wy(i, l), typeof l == "number" && (isNaN(l) ? XC(i, l) : isFinite(l) || QC(i, l));
    var JC = GC;
    function L1(i) {
        var l = "", m = "";
        for (var y in i)
          if (i.hasOwnProperty(y)) {
            var S = i[y];
              var R = y.indexOf("--") === 0;
              l += m + (R ? y : Gd(y)) + ":", l += _m(y, S, R), m = ";";
    function ZC(i, l) {
      var m = i.style;
      for (var y in l)
        if (l.hasOwnProperty(y)) {
          var S = y.indexOf("--") === 0;
          S || JC(y, l[y]);
          var R = _m(y, l[y], S);
          y === "float" && (y = "cssFloat"), S ? m.setProperty(y, R) : m[y] = R;
    function j1(i) {
    function e0(i) {
      for (var m in i)
        for (var y = Sp[m] || [m], S = 0; S < y.length; S++)
          l[y[S]] = m;
    function F1(i, l) {
        var m = e0(i), y = e0(l), S = {};
        for (var R in m) {
          var L = m[R], W = y[R];
          if (W && L !== W) {
            var Z = L + "," + W;
            S[Z] = !0, a("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", j1(i[L]) ? "Removing" : "Updating", L, W);
    var ya = {
    }, Ep = xn({
    }, ya), t0 = "__html";
    function Om(i, l) {
        if (Ep[i] && (l.children != null || l.dangerouslySetInnerHTML != null))
          if (typeof l.dangerouslySetInnerHTML != "object" || !(t0 in l.dangerouslySetInnerHTML))
    function ku(i, l) {
    var Tp = {
    }, Rm = {
    }, qd = {}, z1 = new RegExp("^(aria)-[" + Oe + "]*$"), Kd = new RegExp("^(aria)[A-Z][" + Oe + "]*$");
    function Gy(i, l) {
        if (ce.call(qd, l) && qd[l])
        if (Kd.test(l)) {
          var m = "aria-" + l.slice(4).toLowerCase(), y = Rm.hasOwnProperty(m) ? m : null;
          if (y == null)
            return a("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", l), qd[l] = !0, !0;
          if (l !== y)
            return a("Invalid ARIA attribute `%s`. Did you mean `%s`?", l, y), qd[l] = !0, !0;
        }
        if (z1.test(l)) {
          var S = l.toLowerCase(), R = Rm.hasOwnProperty(S) ? S : null;
            return qd[l] = !0, !1;
            return a("Unknown ARIA attribute `%s`. Did you mean `%s`?", l, R), qd[l] = !0, !0;
    function _p(i, l) {
        var m = [];
        for (var y in l) {
          var S = Gy(i, y);
          S || m.push(y);
        var R = m.map(function(L) {
        m.length === 1 ? a("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", R, i) : m.length > 1 && a("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", R, i);
    function qy(i, l) {
      ku(i, l) || _p(i, l);
    var Ky = !1;
    function km(i, l) {
        l != null && l.value === null && !Ky && (Ky = !0, i === "select" && l.multiple ? a("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", i) : a("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", i));
    var Dc = function() {
      var ni = {}, Yy = /^on./, Pm = /^on[^A-Z]/, n0 = new RegExp("^(aria)-[" + Oe + "]*$"), r0 = new RegExp("^(aria)[A-Z][" + Oe + "]*$");
      Dc = function(i, l, m, y) {
        if (ce.call(ni, l) && ni[l])
          return a("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), ni[l] = !0, !0;
        if (y != null) {
          var R = y.registrationNameDependencies, L = y.possibleRegistrationNames;
          var W = L.hasOwnProperty(S) ? L[S] : null;
          if (W != null)
            return a("Invalid event handler property `%s`. Did you mean `%s`?", l, W), ni[l] = !0, !0;
          if (Yy.test(l))
            return a("Unknown event handler property `%s`. It will be ignored.", l), ni[l] = !0, !0;
        } else if (Yy.test(l))
          return Pm.test(l) && a("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", l), ni[l] = !0, !0;
        if (n0.test(l) || r0.test(l))
          return a("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), ni[l] = !0, !0;
          return a("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), ni[l] = !0, !0;
        if (S === "is" && m !== null && m !== void 0 && typeof m != "string")
          return a("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof m), ni[l] = !0, !0;
        if (typeof m == "number" && isNaN(m))
          return a("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", l), ni[l] = !0, !0;
        var Z = Lt(l), ae = Z !== null && Z.type === nt;
        if (Tp.hasOwnProperty(S)) {
          var le = Tp[S];
            return a("Invalid DOM property `%s`. Did you mean `%s`?", l, le), ni[l] = !0, !0;
          return a("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", l, S), ni[l] = !0, !0;
        return typeof m == "boolean" && We(l, m, Z, !1) ? (m ? a('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', m, l, l, m, l) : a('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', m, l, l, m, l, l, l), ni[l] = !0, !0) : ae ? !0 : We(l, m, Z, !1) ? (ni[l] = !0, !1) : ((m === "false" || m === "true") && Z !== null && Z.type === Et && (a("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", m, l, m === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', l, m), ni[l] = !0), !0);
    var o0 = function(i, l, m) {
        var y = [];
          var R = Dc(i, S, l[S], m);
          R || y.push(S);
        var L = y.map(function(W) {
          return "`" + W + "`";
        y.length === 1 ? a("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", L, i) : y.length > 1 && a("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", L, i);
    function i0(i, l, m) {
      ku(i, l) || o0(i, l, m);
    var Xy = 1, Mm = 2, js = 4, Qy = Xy | Mm | js, Ac = null;
    function B1(i) {
      Ac !== null && a("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Ac = i;
    function H1() {
      Ac === null && a("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Ac = null;
    function Op(i) {
      return i === Ac;
    function Jy(i) {
      return l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === jl ? l.parentNode : l;
    var Im = null, Nc = null, ur = null;
    function Dm(i) {
      var l = gf(i);
        if (typeof Im != "function")
        var m = l.stateNode;
        if (m) {
          var y = hx(m);
          Im(l.stateNode, l.type, y);
    function Am(i) {
      Im = i;
    function Yd(i) {
      Nc ? ur ? ur.push(i) : ur = [i] : Nc = i;
    function s0() {
      return Nc !== null || ur !== null;
    function Nm() {
      if (Nc) {
        var i = Nc, l = ur;
        if (Nc = null, ur = null, Dm(i), l)
          for (var m = 0; m < l.length; m++)
            Dm(l[m]);
    var Xd = function(i, l) {
    }, Rp = function() {
    }, Pu = !1;
    function a0() {
      var i = s0();
      i && (Rp(), Nm());
    }
    function l0(i, l, m) {
      if (Pu)
        return i(l, m);
      Pu = !0;
        return Xd(i, l, m);
        Pu = !1, a0();
    function V1(i, l, m) {
      Xd = i, Rp = m;
    function u0(i) {
    function $m(i, l, m) {
          return !!(m.disabled && u0(l));
    function Mu(i, l) {
      var m = i.stateNode;
      if (m === null)
      var y = hx(m);
      if (y === null)
      var S = y[l];
      if ($m(l, i.type, y))
    var kp = !1;
        var $c = {};
        Object.defineProperty($c, "passive", {
            kp = !0;
        }), window.addEventListener("test", $c, $c), window.removeEventListener("test", $c, $c);
        kp = !1;
    function Lm(i, l, m, y, S, R, L, W, Z) {
        l.apply(m, ae);
    var jm = Lm;
      var Zy = document.createElement("react");
      jm = function(l, m, y, S, R, L, W, Z, ae) {
        var le = document.createEvent("Event"), Te = !1, xe = !0, $e = window.event, ze = Object.getOwnPropertyDescriptor(window, "event");
          Zy.removeEventListener(qe, nn, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = $e);
          Te = !0, Ge(), m.apply(y, kt), xe = !1;
        var Yt, qn = !1, zn = !1;
          if (Yt = Me.error, qn = !0, Yt === null && Me.colno === 0 && Me.lineno === 0 && (zn = !0), Me.defaultPrevented && Yt != null && typeof Yt == "object")
        if (window.addEventListener("error", Pe), Zy.addEventListener(qe, nn, !1), le.initEvent(qe, !1, !1), Zy.dispatchEvent(le), ze && Object.defineProperty(window, "event", ze), Te && xe && (qn ? zn && (Yt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Yt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Yt)), window.removeEventListener("error", Pe), !Te)
          return Ge(), Lm.apply(this, arguments);
    var c0 = jm, Qd = !1, Fm = null, Jd = !1, qa = null, d0 = {
        Qd = !0, Fm = i;
    function Iu(i, l, m, y, S, R, L, W, Z) {
      Qd = !1, Fm = null, c0.apply(d0, arguments);
    function Ka(i, l, m, y, S, R, L, W, Z) {
      if (Iu.apply(this, arguments), Qd) {
        var ae = Mp();
        Jd || (Jd = !0, qa = ae);
    function Pp() {
      if (Jd) {
        var i = qa;
        throw Jd = !1, qa = null, i;
    function zl() {
      return Qd;
    function Mp() {
      if (Qd) {
        var i = Fm;
        return Qd = !1, Fm = null, i;
    function Zd(i) {
    function U1(i) {
    function Lc(i, l) {
    ), ba = (
    ), Qr = (
    ), Un = (
    ), Fs = (
    ), zs = (
    ), Ar = (
    ), Si = (
    ), oo = (
    ), Ao = (
    ), es = (
    ), ts = (
    ), yo = (
    ), ef = (
    ), f0 = (
    ), Ip = (
    ), Ho = (
    ), zm = (
    ), Ya = (
    ), tf = (
    ), Bl = (
    ), Bm = (
    ), Du = (
    ), Xa = (
    ), Au = (
      Un | Ao | 0
    ), Nu = Qr | Un | Fs | zs | oo | ts | yo, $u = Un | Ar | oo | yo, Hl = es | Fs, bo = Bl | Bm | tf, Bs = n.ReactCurrentOwner;
    function ws(i) {
      var l = i, m = i;
        var y = l;
          l = y, (l.flags & (Qr | ts)) !== Qt && (m = l.return), y = l.return;
        while (y);
      return l.tag === v ? m : null;
    function Qa(i) {
      if (i.tag === k) {
          var m = i.alternate;
          m !== null && (l = m.memoizedState);
    function Ja(i) {
      return i.tag === v ? i.stateNode.containerInfo : null;
    function jc(i) {
      return ws(i) === i;
    function p0(i) {
        var l = Bs.current;
        if (l !== null && l.tag === h) {
          var m = l, y = m.stateNode;
          y._warnedAboutRefsInRender || a("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", yn(m) || "A component"), y._warnedAboutRefsInRender = !0;
      var S = Zd(i);
      return S ? ws(S) === S : !1;
    function Hm(i) {
      if (ws(i) !== i)
    function Vm(i) {
        var m = ws(i);
        if (m === null)
        return m !== i ? null : i;
      for (var y = i, S = l; ; ) {
        var R = y.return;
          var W = R.return;
          if (W !== null) {
            y = S = W;
            if (Z === y)
              return Hm(R), i;
              return Hm(R), l;
        if (y.return !== S.return)
          y = R, S = L;
            if (le === y) {
              ae = !0, y = R, S = L;
              ae = !0, S = R, y = L;
              if (le === y) {
                ae = !0, y = L, S = R;
                ae = !0, S = L, y = R;
        if (y.alternate !== S)
      if (y.tag !== v)
      return y.stateNode.current === y ? i : l;
      var l = Vm(i);
      return l !== null ? rs(l) : null;
    }
    function rs(i) {
        var m = rs(l);
        if (m !== null)
          return m;
    function Ur(i) {
      var l = Vm(i);
      return l !== null ? Hs(l) : null;
    function Hs(i) {
          var m = Hs(l);
          if (m !== null)
            return m;
    var eb = t.unstable_scheduleCallback, h0 = t.unstable_cancelCallback, tb = t.unstable_shouldYield, nb = t.unstable_requestPaint, No = t.unstable_now, Um = t.unstable_getCurrentPriorityLevel, Dp = t.unstable_ImmediatePriority, Lu = t.unstable_UserBlockingPriority, Vl = t.unstable_NormalPriority, W1 = t.unstable_LowPriority, Fc = t.unstable_IdlePriority, Wm = t.unstable_yieldValue, m0 = t.unstable_setDisableYieldValue, zc = null, ao = null, Rt = null, Ss = !1, os = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function nf(i) {
        de && (i = xn({}, i, {
          getLaneLabelMap: Bc,
          injectProfilingHooks: Vs
        })), zc = l.inject(i), ao = l;
      } catch (m) {
        a("React instrumentation encountered an error: %s.", m);
    function rb(i, l) {
      if (ao && typeof ao.onScheduleFiberRoot == "function")
          ao.onScheduleFiberRoot(zc, i, l);
        } catch (m) {
          Ss || (Ss = !0, a("React instrumentation encountered an error: %s", m));
    function ob(i, l) {
      if (ao && typeof ao.onCommitFiberRoot == "function")
          var m = (i.current.flags & Xt) === Xt;
            var y;
              case Ai:
                y = Dp;
              case el:
                y = Lu;
                y = Vl;
                break;
              case Ws:
                y = Fc;
                y = Vl;
            ao.onCommitFiberRoot(zc, i, y, m);
          Ss || (Ss = !0, a("React instrumentation encountered an error: %s", S));
    function ib(i) {
      if (ao && typeof ao.onPostCommitFiberRoot == "function")
          ao.onPostCommitFiberRoot(zc, i);
          Ss || (Ss = !0, a("React instrumentation encountered an error: %s", l));
    function sb(i) {
      if (ao && typeof ao.onCommitFiberUnmount == "function")
          ao.onCommitFiberUnmount(zc, i);
          Ss || (Ss = !0, a("React instrumentation encountered an error: %s", l));
    function Jr(i) {
      if (typeof Wm == "function" && (m0(i), o(i)), ao && typeof ao.setStrictMode == "function")
          ao.setStrictMode(zc, i);
          Ss || (Ss = !0, a("React instrumentation encountered an error: %s", l));
    function Vs(i) {
    function Bc() {
        for (var i = /* @__PURE__ */ new Map(), l = 1, m = 0; m < Uc; m++) {
          var y = b0(l);
          i.set(l, y), l *= 2;
    function ab(i) {
    function lb() {
    function Cs(i) {
    function xs() {
    function ub(i) {
    function g0() {
    function Ul(i) {
    function ju() {
    function Gm(i) {
    function v0() {
    function Ap(i) {
    function cb() {
    function Np(i, l, m) {
      Rt !== null && typeof Rt.markComponentErrored == "function" && Rt.markComponentErrored(i, l, m);
    function Za(i, l, m) {
      Rt !== null && typeof Rt.markComponentSuspended == "function" && Rt.markComponentSuspended(i, l, m);
    function $p(i) {
    function Lp() {
    function Hc(i) {
    function db() {
    function Vc(i) {
    function y0() {
    function qm() {
    function Zr(i) {
    function Km(i, l) {
    function jp(i, l) {
    ), Mn = (
    ), tr = (
    ), wr = (
    ), nr = (
    ), wo = Math.clz32 ? Math.clz32 : Fp, Vo = Math.log, Ym = Math.LN2;
    function Fp(i) {
      return l === 0 ? 32 : 31 - (Vo(l) / Ym | 0) | 0;
    var Uc = 31, it = (
    ), Jn = (
    ), cn = (
    ), Fu = (
    ), wa = (
    ), Ci = (
    ), lo = (
    ), Wl = (
    ), zu = (
    ), Wc = (
    ), Xm = (
    ), Qm = (
    ), Jm = (
    ), Zm = (
    ), eg = (
    ), tg = (
    ), ng = (
    ), rg = (
    ), Gc = (
    ), og = (
    ), rf = (
    ), of = (
    ), ig = (
    ), zp = (
    ), sg = (
    ), Bp = (
    ), qc = (
    ), ag = (
    ), Hp = (
    ), lg = (
    ), ug = (
    ), fb = qc, Vp = (
    ), pb = (
    ), Up = (
    ), Kc = (
    ), is = (
    function b0(i) {
        if (i & cn)
        if (i & Fu)
        if (i & wa)
        if (i & Ci)
        if (i & lo)
        if (i & Wl)
        if (i & zu)
          return "Retry";
        if (i & Vp)
        if (i & Up)
        if (i & Kc)
        if (i & is)
    var Pr = -1, Yc = Wc, cg = qc;
    function Wp(i) {
      switch (Bu(i)) {
        case cn:
          return cn;
        case Fu:
          return Fu;
        case wa:
          return wa;
        case Ci:
          return Ci;
        case lo:
          return lo;
        case Wl:
          return Wl;
        case Wc:
        case Gc:
        case rf:
        case of:
        case zp:
        case sg:
          return i & zu;
        case qc:
        case ag:
        case lg:
        case ug:
          return i & Bp;
        case Vp:
          return Vp;
        case Up:
          return Up;
        case Kc:
          return Kc;
        case is:
          return is;
    function dg(i, l) {
      var m = i.pendingLanes;
      if (m === it)
      var y = it, S = i.suspendedLanes, R = i.pingedLanes, L = m & pb;
        var W = L & ~S;
        if (W !== it)
          y = Wp(W);
          Z !== it && (y = Wp(Z));
        var ae = m & ~S;
        ae !== it ? y = Wp(ae) : R !== it && (y = Wp(R));
      if (y === it)
      if (l !== it && l !== y && // If we already suspended with a delay, then interrupting is fine. Don't
        var le = Bu(y), Te = Bu(l);
          le === lo && (Te & zu) !== it
      (y & wa) !== it && (y |= m & lo);
        for (var $e = i.entanglements, ze = y & xe; ze > 0; ) {
          var Ge = So(ze), kt = 1 << Ge;
          y |= $e[Ge], ze &= ~kt;
      return y;
    function Sa(i, l) {
      for (var m = i.eventTimes, y = Pr; l > 0; ) {
        var S = So(l), R = 1 << S, L = m[S];
        L > y && (y = L), l &= ~R;
      return y;
    function hb(i, l) {
        case cn:
        case Fu:
        case wa:
        case Ci:
        case lo:
        case Wl:
        case Wc:
        case Gc:
        case rf:
        case of:
        case zp:
        case sg:
          return l + 5e3;
        case qc:
        case ag:
        case lg:
        case ug:
          return Pr;
        case Vp:
        case Up:
        case Kc:
        case is:
          return Pr;
          return a("Should have found matching lanes. This is a bug in React."), Pr;
    function fg(i, l) {
      for (var m = i.pendingLanes, y = i.suspendedLanes, S = i.pingedLanes, R = i.expirationTimes, L = m; L > 0; ) {
        var W = So(L), Z = 1 << W, ae = R[W];
        ae === Pr ? ((Z & y) === it || (Z & S) !== it) && (R[W] = hb(Z, l)) : ae <= l && (i.expiredLanes |= Z), L &= ~Z;
    function w0(i) {
      return Wp(i.pendingLanes);
    function pg(i) {
      var l = i.pendingLanes & ~is;
      return l !== it ? l : l & is ? is : it;
    function S0(i) {
      return (i & cn) !== it;
    function Gp(i) {
      return (i & pb) !== it;
    function Xc(i) {
      return (i & Bp) === i;
    function mb(i) {
      var l = cn | wa | lo;
    function gb(i) {
      return (i & zu) === i;
    function hg(i, l) {
      var m = Fu | wa | Ci | lo;
      return (l & m) !== it;
    function C0(i, l) {
    function vb(i) {
      return (i & zu) !== it;
    function yb() {
      var i = Yc;
      return Yc <<= 1, (Yc & zu) === it && (Yc = Wc), i;
    function x0() {
      var i = cg;
      return cg <<= 1, (cg & Bp) === it && (cg = qc), i;
    function Bu(i) {
    function qp(i) {
      return Bu(i);
    function So(i) {
      return 31 - wo(i);
    function ri(i) {
      return So(i);
    function ss(i, l) {
    function Qc(i, l) {
    function _n(i, l) {
    function Kp(i, l) {
    function bb(i, l) {
    function E0(i) {
    function T0(i, l) {
      return i !== Jn && i < l ? i : l;
    function Yp(i) {
      for (var l = [], m = 0; m < Uc; m++)
    function sf(i, l, m) {
      i.pendingLanes |= l, l !== Kc && (i.suspendedLanes = it, i.pingedLanes = it);
      var y = i.eventTimes, S = ri(l);
      y[S] = m;
    function _0(i, l) {
      for (var m = i.expirationTimes, y = l; y > 0; ) {
        var S = So(y), R = 1 << S;
        m[S] = Pr, y &= ~R;
    function mg(i, l, m) {
    function wb(i, l) {
      var m = i.pendingLanes & ~l;
      for (var y = i.entanglements, S = i.eventTimes, R = i.expirationTimes, L = m; L > 0; ) {
        var W = So(L), Z = 1 << W;
        y[W] = it, S[W] = Pr, R[W] = Pr, L &= ~Z;
    function gg(i, l) {
      for (var m = i.entangledLanes |= l, y = i.entanglements, S = m; S; ) {
        var R = So(S), L = 1 << R;
        y[R] & l && (y[R] |= l), S &= ~L;
    function Sb(i, l) {
      var m = Bu(l), y;
      switch (m) {
        case wa:
          y = Fu;
        case lo:
          y = Ci;
        case Wc:
        case Gc:
        case rf:
        case of:
        case zp:
        case sg:
        case qc:
        case ag:
        case Hp:
        case lg:
        case ug:
          y = Wl;
        case Kc:
          y = Up;
          y = Jn;
      return (y & (i.suspendedLanes | l)) !== Jn ? Jn : y;
    function Xp(i, l, m) {
      if (os)
        for (var y = i.pendingUpdatersLaneMap; m > 0; ) {
          var S = ri(m), R = 1 << S, L = y[S];
          L.add(l), m &= ~R;
    function O0(i, l) {
      if (os)
        for (var m = i.pendingUpdatersLaneMap, y = i.memoizedUpdaters; l > 0; ) {
          var S = ri(l), R = 1 << S, L = m[S];
          L.size > 0 && (L.forEach(function(W) {
            var Z = W.alternate;
            (Z === null || !y.has(Z)) && y.add(W);
    function Cb(i, l) {
    var Ai = cn, el = wa, Us = lo, Ws = Kc, Qp = Jn;
    function Gs() {
      return Qp;
    function Co(i) {
      Qp = i;
    function R0(i, l) {
      var m = Qp;
        return Qp = i, l();
        Qp = m;
    function k0(i, l) {
    function Jp(i, l) {
    function Uo(i, l) {
    function P0(i) {
      var l = Bu(i);
      return Uo(Ai, l) ? Uo(el, l) ? Gp(l) ? Us : Ws : el : Ai;
    function vg(i) {
    var Zp;
    function xi(i) {
      Zp = i;
    function G1(i) {
      Zp(i);
    function af(i) {
    var yg;
    function M0(i) {
      yg = i;
    var I0;
    function eh(i) {
      I0 = i;
    var th;
    function xb(i) {
      th = i;
    var bg = !1, nh = [], Gl = null, tl = null, nl = null, uo = /* @__PURE__ */ new Map(), Ni = /* @__PURE__ */ new Map(), $i = [], D0 = [
    function A0(i) {
      return D0.indexOf(i) > -1;
    function Ca(i, l, m, y, S) {
        eventSystemFlags: m,
        targetContainers: [y]
    function Eb(i, l) {
          Gl = null;
          tl = null;
          nl = null;
          var m = l.pointerId;
          uo.delete(m);
          var y = l.pointerId;
          Ni.delete(y);
    function as(i, l, m, y, S, R) {
        var L = Ca(l, m, y, S, R);
          var W = gf(l);
          W !== null && Nt(W);
      i.eventSystemFlags |= y;
    function q1(i, l, m, y, S) {
          return Gl = as(Gl, i, l, m, y, R), !0;
          return tl = as(tl, i, l, m, y, L), !0;
          var W = S;
          return nl = as(nl, i, l, m, y, W), !0;
          return uo.set(ae, as(uo.get(ae) || null, i, l, m, y, Z)), !0;
          return Ni.set(Te, as(Ni.get(Te) || null, i, l, m, y, le)), !0;
    function Tb(i) {
      var l = hh(i.target);
        var m = ws(l);
        if (m !== null) {
          var y = m.tag;
          if (y === k) {
            var S = Qa(m);
              i.blockedOn = S, th(i.priority, function() {
                yg(m);
          } else if (y === v) {
            var R = m.stateNode;
            if (vg(R)) {
              i.blockedOn = Ja(m);
    function N0(i) {
      for (var l = I0(), m = {
      }, y = 0; y < $i.length && Uo(l, $i[y].priority); y++)
      $i.splice(y, 0, m), y === 0 && Tb(m);
    function rh(i) {
        var m = l[0], y = uf(i.domEventName, i.eventSystemFlags, m, i.nativeEvent);
        if (y === null) {
          B1(R), S.target.dispatchEvent(R), H1();
          var L = gf(y);
          return L !== null && Nt(L), i.blockedOn = y, !1;
    function _b(i, l, m) {
      rh(i) && m.delete(l);
    function K1() {
      bg = !1, Gl !== null && rh(Gl) && (Gl = null), tl !== null && rh(tl) && (tl = null), nl !== null && rh(nl) && (nl = null), uo.forEach(_b), Ni.forEach(_b);
    function Hu(i, l) {
      i.blockedOn === l && (i.blockedOn = null, bg || (bg = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, K1)));
    function Jc(i) {
      if (nh.length > 0) {
        Hu(nh[0], i);
        for (var l = 1; l < nh.length; l++) {
          var m = nh[l];
          m.blockedOn === i && (m.blockedOn = null);
      Gl !== null && Hu(Gl, i), tl !== null && Hu(tl, i), nl !== null && Hu(nl, i);
      var y = function(W) {
        return Hu(W, i);
      uo.forEach(y), Ni.forEach(y);
      for (var S = 0; S < $i.length; S++) {
        var R = $i[S];
      for (; $i.length > 0; ) {
        var L = $i[0];
        Tb(L), L.blockedOn === null && $i.shift();
    var oi = n.ReactCurrentBatchConfig, Wn = !0;
    function $o(i) {
      Wn = !!i;
    function xo() {
      return Wn;
    function ii(i, l, m) {
      var y = wg(l), S;
      switch (y) {
        case Ai:
          S = Es;
        case el:
          S = lf;
        case Us:
          S = co;
      return S.bind(null, l, m, i);
    function Es(i, l, m, y) {
      var S = Gs(), R = oi.transition;
      oi.transition = null;
        Co(Ai), co(i, l, m, y);
        Co(S), oi.transition = R;
    function lf(i, l, m, y) {
      var S = Gs(), R = oi.transition;
      oi.transition = null;
        Co(el), co(i, l, m, y);
        Co(S), oi.transition = R;
    function co(i, l, m, y) {
      Wn && oh(i, l, m, y);
    function oh(i, l, m, y) {
      var S = uf(i, l, m, y);
        dO(i, l, y, rl, m), Eb(i, y);
      if (q1(S, i, l, m, y)) {
        y.stopPropagation();
      if (Eb(i, y), l & js && A0(i)) {
          var R = gf(S);
          R !== null && G1(R);
          var L = uf(i, l, m, y);
          if (L === null && dO(i, l, y, rl, m), L === S)
        S !== null && y.stopPropagation();
      dO(i, l, y, null, m);
    var rl = null;
    function uf(i, l, m, y) {
      rl = null;
      var S = Jy(y), R = hh(S);
        var L = ws(R);
          var W = L.tag;
          if (W === k) {
            var Z = Qa(L);
          } else if (W === v) {
            if (vg(ae))
              return Ja(L);
      return rl = R, null;
    function wg(i) {
          return Ai;
          return el;
          var l = Um();
            case Dp:
              return Ai;
            case Lu:
              return el;
            case Vl:
            case W1:
            case Fc:
              return Ws;
              return Us;
          return Us;
    function ih(i, l, m) {
      return i.addEventListener(l, m, !1), m;
    function ls(i, l, m) {
      return i.addEventListener(l, m, !0), m;
    function Ob(i, l, m, y) {
      return i.addEventListener(l, m, {
        passive: y
      }), m;
    }
    function cf(i, l, m, y) {
      return i.addEventListener(l, m, {
        passive: y
      }), m;
    }
    var Ts = null, df = null, Zc = null;
    function Vu(i) {
      return Ts = i, df = sh(), !0;
    }
    function Sg() {
      Ts = null, df = null, Zc = null;
    }
    function ql() {
      if (Zc)
        return Zc;
      var i, l = df, m = l.length, y, S = sh(), R = S.length;
      for (i = 0; i < m && l[i] === S[i]; i++)
      var L = m - i;
      for (y = 1; y <= L && l[m - y] === S[R - y]; y++)
      var W = y > 1 ? 1 - y : void 0;
      return Zc = S.slice(i, W), Zc;
    function sh() {
      return "value" in Ts ? Ts.value : Ts.textContent;
    function Uu(i) {
      var l, m = i.keyCode;
      return "charCode" in i ? (l = i.charCode, l === 0 && m === 13 && (l = 13)) : l = m, l === 10 && (l = 13), l >= 32 || l === 13 ? l : 0;
    function ff() {
    function ah() {
    function Ei(i) {
      function l(m, y, S, R, L) {
        this._reactName = m, this._targetInst = S, this.type = y, this.nativeEvent = R, this.target = L, this.currentTarget = null;
        for (var W in i)
          if (i.hasOwnProperty(W)) {
            var Z = i[W];
            Z ? this[W] = Z(R) : this[W] = R[W];
        return ae ? this.isDefaultPrevented = ff : this.isDefaultPrevented = ah, this.isPropagationStopped = ah, this;
      return xn(l.prototype, {
          var m = this.nativeEvent;
          m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = ff);
          var m = this.nativeEvent;
          m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = ff);
        isPersistent: ff
    var Eo = {
    }, ol = Ei(Eo), Li = xn({}, Eo, {
    }), us = Ei(Li), Cg, lh, ed;
    function Y1(i) {
      i !== ed && (ed && i.type === "mousemove" ? (Cg = i.screenX - ed.screenX, lh = i.screenY - ed.screenY) : (Cg = 0, lh = 0), ed = i);
    var xa = xn({}, Li, {
      getModifierState: Wr,
        return "movementX" in i ? i.movementX : (Y1(i), Cg);
        return "movementY" in i ? i.movementY : lh;
    }), Rb = Ei(xa), kb = xn({}, xa, {
    }), td = Ei(kb), Pb = xn({}, Li, {
    }), Kl = Ei(Pb), $0 = xn({}, Eo, {
    }), L0 = Ei($0), Mb = xn({}, Eo, {
    }), xg = Ei(Mb), X1 = xn({}, Eo, {
    }), j0 = Ei(X1), F0 = j0, z0 = {
    }, nd = {
    function Q1(i) {
        var l = z0[i.key] || i.key;
        var m = Uu(i);
        return m === 13 ? "Enter" : String.fromCharCode(m);
      return i.type === "keydown" || i.type === "keyup" ? nd[i.keyCode] || "Unidentified" : "";
    var pf = {
    function B0(i) {
      var l = this, m = l.nativeEvent;
      if (m.getModifierState)
        return m.getModifierState(i);
      var y = pf[i];
      return y ? !!m[y] : !1;
    }
    function Wr(i) {
      return B0;
    }
    var J1 = xn({}, Li, {
      key: Q1,
      getModifierState: Wr,
        return i.type === "keypress" ? Uu(i) : 0;
        return i.type === "keypress" ? Uu(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    }), H0 = Ei(J1), Z1 = xn({}, xa, {
    }), V0 = Ei(Z1), U0 = xn({}, Li, {
      getModifierState: Wr
    }), W0 = Ei(U0), eO = xn({}, Eo, {
    }), qs = Ei(eO), Ib = xn({}, xa, {
    }), tO = Ei(Ib), Wu = [9, 13, 27, 32], uh = 229, Yl = _e && "CompositionEvent" in window, Gu = null;
    _e && "documentMode" in document && (Gu = document.documentMode);
    var Db = _e && "TextEvent" in window && !Gu, Eg = _e && (!Yl || Gu && Gu > 8 && Gu <= 11), G0 = 32, Tg = String.fromCharCode(G0);
    function nO() {
    var Ab = !1;
    function q0(i) {
    function _g(i) {
    function Og(i, l) {
      return i === "keydown" && l.keyCode === uh;
    function Nb(i, l) {
          return Wu.indexOf(l.keyCode) !== -1;
          return l.keyCode !== uh;
    function Rg(i) {
    function K0(i) {
    var rd = !1;
    function $b(i, l, m, y, S) {
      if (Yl ? R = _g(l) : rd ? Nb(l, y) && (R = "onCompositionEnd") : Og(l, y) && (R = "onCompositionStart"), !R)
      Eg && !K0(y) && (!rd && R === "onCompositionStart" ? rd = Vu(S) : R === "onCompositionEnd" && rd && (L = ql()));
      var W = tx(m, R);
      if (W.length > 0) {
        var Z = new j0(R, l, null, y, S);
          listeners: W
          var ae = Rg(y);
    function kg(i, l) {
          return Rg(l);
          var m = l.which;
          return m !== G0 ? null : (Ab = !0, Tg);
          var y = l.data;
          return y === Tg && Ab ? null : y;
    function Lb(i, l) {
      if (rd) {
        if (i === "compositionend" || !Yl && Nb(i, l)) {
          var m = ql();
          return Sg(), rd = !1, m;
          if (!q0(l)) {
          return Eg && !K0(l) ? null : l.data;
    function Pg(i, l, m, y, S) {
      if (Db ? R = kg(l, y) : R = Lb(l, y), !R)
      var L = tx(m, "onBeforeInput");
        var W = new F0("onBeforeInput", "beforeinput", null, y, S);
          event: W,
        }), W.data = R;
    function Y0(i, l, m, y, S, R, L) {
      $b(i, l, m, y, S), Pg(i, l, m, y, S);
    var rO = {
    function ch(i) {
      return l === "input" ? !!rO[i.type] : l === "textarea";
    function oO(i) {
      var l = "on" + i, m = l in document;
      if (!m) {
        var y = document.createElement("div");
        y.setAttribute(l, "return;"), m = typeof y[l] == "function";
      return m;
    function dh() {
    function X0(i, l, m, y) {
      Yd(y);
      var S = tx(l, "onChange");
        var R = new ol("onChange", "change", null, m, y);
    var qu = null, d = null;
      X0(l, d, i, Jy(i)), l0(_, l);
      xA(i, 0);
    function N(i) {
      var l = $g(i);
      if (Wa(l))
    function z(i, l) {
    _e && (oe = oO("input") && (!document.documentMode || document.documentMode > 9));
      qu = i, d = l, qu.attachEvent("onpropertychange", Fe);
      qu && (qu.detachEvent("onpropertychange", Fe), qu = null, d = null);
      i.propertyName === "value" && N(d) && b(i);
    function at(i, l, m) {
      i === "focusin" ? (Se(), me(l, m)) : i === "focusout" && Se();
        return N(d);
        return N(l);
        return N(l);
    function fo(i, l, m, y, S, R, L) {
      var W = m ? $g(m) : window, Z, ae;
      if (p(W) ? Z = z : ch(W) ? oe ? Z = Ht : (Z = ct, ae = at) : st(W) && (Z = Mt), Z) {
        var le = Z(l, m);
          X0(i, le, y, S);
      ae && ae(l, W, m), l === "focusout" && Gt(W);
    function Ee(i, l, m, y, S, R, L) {
      var W = l === "mouseover" || l === "pointerover", Z = l === "mouseout" || l === "pointerout";
      if (W && !Op(y)) {
        var ae = y.relatedTarget || y.fromElement;
        if (ae && (hh(ae) || Qb(ae)))
      if (!(!Z && !W)) {
        var xe, $e;
          var ze = y.relatedTarget || y.toElement;
          if (xe = m, $e = ze ? hh(ze) : null, $e !== null) {
            var Ge = ws($e);
            ($e !== Ge || $e.tag !== C && $e.tag !== T) && ($e = null);
          xe = null, $e = m;
        if (xe !== $e) {
          var kt = Rb, nn = "onMouseLeave", Yt = "onMouseEnter", qn = "mouse";
          (l === "pointerout" || l === "pointerover") && (kt = V0, nn = "onPointerLeave", Yt = "onPointerEnter", qn = "pointer");
          var zn = xe == null ? le : $g(xe), Pe = $e == null ? le : $g($e), qe = new kt(nn, qn + "leave", xe, y, S);
          qe.target = zn, qe.relatedTarget = Pe;
          var Me = null, dt = hh(S);
          if (dt === m) {
            var Dt = new kt(Yt, qn + "enter", $e, y, S);
            Dt.target = Pe, Dt.relatedTarget = zn, Me = Dt;
          RG(i, qe, Me, xe, $e);
      var m = Object.keys(i), y = Object.keys(l);
      if (m.length !== y.length)
      for (var S = 0; S < m.length; S++) {
        var R = m[S];
    function on(i) {
    function an(i) {
    function vn(i, l) {
      for (var m = on(i), y = 0, S = 0; m; ) {
        if (m.nodeType === jl) {
          if (S = y + m.textContent.length, y <= l && S >= l)
              node: m,
              offset: l - y
          y = S;
        m = on(an(m));
    function Wo(i) {
      var l = i.ownerDocument, m = l && l.defaultView || window, y = m.getSelection && m.getSelection();
      if (!y || y.rangeCount === 0)
      var S = y.anchorNode, R = y.anchorOffset, L = y.focusNode, W = y.focusOffset;
      return rr(i, S, R, L, W);
    function rr(i, l, m, y, S) {
      var R = 0, L = -1, W = -1, Z = 0, ae = 0, le = i, Te = null;
        for (var xe = null; le === l && (m === 0 || le.nodeType === jl) && (L = R + m), le === y && (S === 0 || le.nodeType === jl) && (W = R + S), le.nodeType === jl && (R += le.nodeValue.length), (xe = le.firstChild) !== null; )
          if (Te === l && ++Z === m && (L = R), Te === y && ++ae === S && (W = R), (xe = le.nextSibling) !== null)
      return L === -1 || W === -1 ? null : {
        end: W
    function Ku(i, l) {
      var m = i.ownerDocument || document, y = m && m.defaultView || window;
      if (y.getSelection) {
        var S = y.getSelection(), R = i.textContent.length, L = Math.min(l.start, R), W = l.end === void 0 ? L : Math.min(l.end, R);
        if (!S.extend && L > W) {
          var Z = W;
          W = L, L = Z;
        var ae = vn(i, L), le = vn(i, W);
          var Te = m.createRange();
          Te.setStart(ae.node, ae.offset), S.removeAllRanges(), L > W ? (S.addRange(Te), S.extend(le.node, le.offset)) : (Te.setEnd(le.node, le.offset), S.addRange(Te));
    function Q0(i) {
      return i && i.nodeType === jl;
    function fA(i, l) {
      return !i || !l ? !1 : i === l ? !0 : Q0(i) ? !1 : Q0(l) ? fA(i, l.parentNode) : "contains" in i ? i.contains(l) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(l) & 16) : !1;
    function cG(i) {
      return i && i.ownerDocument && fA(i.ownerDocument.documentElement, i);
    function dG(i) {
    function pA() {
        if (dG(l))
    function iO(i) {
    function fG() {
      var i = pA();
        selectionRange: iO(i) ? hG(i) : null
    function pG(i) {
      var l = pA(), m = i.focusedElem, y = i.selectionRange;
      if (l !== m && cG(m)) {
        y !== null && iO(m) && mG(m, y);
        for (var S = [], R = m; R = R.parentNode; )
          R.nodeType === Zi && S.push({
        typeof m.focus == "function" && m.focus();
          var W = S[L];
          W.element.scrollLeft = W.left, W.element.scrollTop = W.top;
    function hG(i) {
      } : l = Wo(i), l || {
    function mG(i, l) {
      var m = l.start, y = l.end;
      y === void 0 && (y = m), "selectionStart" in i ? (i.selectionStart = m, i.selectionEnd = Math.min(y, i.value.length)) : Ku(i, l);
    var gG = _e && "documentMode" in document && document.documentMode <= 11;
    function vG() {
    var Mg = null, sO = null, jb = null, aO = !1;
    function yG(i) {
      if ("selectionStart" in i && iO(i))
      var l = i.ownerDocument && i.ownerDocument.defaultView || window, m = l.getSelection();
        anchorNode: m.anchorNode,
        anchorOffset: m.anchorOffset,
        focusNode: m.focusNode,
        focusOffset: m.focusOffset
    function bG(i) {
      return i.window === i ? i.document : i.nodeType === Fl ? i : i.ownerDocument;
    function hA(i, l, m) {
      var y = bG(m);
      if (!(aO || Mg == null || Mg !== Ls(y))) {
        var S = yG(Mg);
        if (!jb || !Vt(jb, S)) {
          jb = S;
          var R = tx(sO, "onSelect");
            var L = new ol("onSelect", "select", null, l, m);
            }), L.target = Mg;
    function wG(i, l, m, y, S, R, L) {
      var W = m ? $g(m) : window;
          (ch(W) || W.contentEditable === "true") && (Mg = W, sO = m, jb = null);
          Mg = null, sO = null, jb = null;
          aO = !0;
          aO = !1, hA(i, y, S);
          if (gG)
          hA(i, y, S);
    function J0(i, l) {
      var m = {};
      return m[i.toLowerCase()] = l.toLowerCase(), m["Webkit" + i] = "webkit" + l, m["Moz" + i] = "moz" + l, m;
    }
    var Ig = {
      animationend: J0("Animation", "AnimationEnd"),
      animationiteration: J0("Animation", "AnimationIteration"),
      animationstart: J0("Animation", "AnimationStart"),
      transitionend: J0("Transition", "TransitionEnd")
    }, lO = {}, mA = {};
    _e && (mA = document.createElement("div").style, "AnimationEvent" in window || (delete Ig.animationend.animation, delete Ig.animationiteration.animation, delete Ig.animationstart.animation), "TransitionEvent" in window || delete Ig.transitionend.transition);
    function Z0(i) {
      if (lO[i])
        return lO[i];
      if (!Ig[i])
      var l = Ig[i];
      for (var m in l)
        if (l.hasOwnProperty(m) && m in mA)
          return lO[i] = l[m];
    var gA = Z0("animationend"), vA = Z0("animationiteration"), yA = Z0("animationstart"), bA = Z0("transitionend"), wA = /* @__PURE__ */ new Map(), SA = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function hf(i, l) {
      wA.set(i, l), be(l, [i]);
    function SG() {
      for (var i = 0; i < SA.length; i++) {
        var l = SA[i], m = l.toLowerCase(), y = l[0].toUpperCase() + l.slice(1);
        hf(m, "on" + y);
      hf(gA, "onAnimationEnd"), hf(vA, "onAnimationIteration"), hf(yA, "onAnimationStart"), hf("dblclick", "onDoubleClick"), hf("focusin", "onFocus"), hf("focusout", "onBlur"), hf(bA, "onTransitionEnd");
    function CG(i, l, m, y, S, R, L) {
      var W = wA.get(l);
      if (W !== void 0) {
        var Z = ol, ae = l;
            if (Uu(y) === 0)
            Z = H0;
            ae = "focus", Z = Kl;
            ae = "blur", Z = Kl;
            Z = Kl;
            if (y.button === 2)
            Z = Rb;
            Z = td;
            Z = W0;
          case gA:
          case vA:
          case yA:
            Z = L0;
          case bA:
            Z = qs;
            Z = us;
            Z = tO;
            Z = xg;
            Z = V0;
        var le = (R & js) !== 0;
          l === "scroll", xe = _G(m, W, y.type, le, Te);
            var $e = new Z(W, ae, null, y, S);
              event: $e,
    SG(), ke(), dh(), vG(), nO();
    function xG(i, l, m, y, S, R, L) {
      CG(i, l, m, y, S, R);
      var W = (R & Qy) === 0;
      W && (Ee(i, l, m, y, S), fo(i, l, m, y, S), wG(i, l, m, y, S), Y0(i, l, m, y, S));
    var Fb = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], uO = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Fb));
    function CA(i, l, m) {
      var y = i.type || "unknown-event";
      i.currentTarget = m, Ka(y, l, void 0, i), i.currentTarget = null;
    function EG(i, l, m) {
      var y;
      if (m)
          var R = l[S], L = R.instance, W = R.currentTarget, Z = R.listener;
          if (L !== y && i.isPropagationStopped())
          CA(i, Z, W), y = L;
          var le = l[ae], Te = le.instance, xe = le.currentTarget, $e = le.listener;
          if (Te !== y && i.isPropagationStopped())
          CA(i, $e, xe), y = Te;
    function xA(i, l) {
      for (var m = (l & js) !== 0, y = 0; y < i.length; y++) {
        var S = i[y], R = S.event, L = S.listeners;
        EG(R, L, m);
      Pp();
    function TG(i, l, m, y, S) {
      var R = Jy(m), L = [];
      xG(L, i, y, m, R, l), xA(L, l);
    function eo(i, l) {
      uO.has(i) || a('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', i);
      var m = !1, y = t6(l), S = kG(i);
      y.has(S) || (EA(l, i, Mm, m), y.add(S));
    function cO(i, l, m) {
      uO.has(i) && !l && a('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', i);
      var y = 0;
      l && (y |= js), EA(m, i, y, l);
    var ex = "_reactListening" + Math.random().toString(36).slice(2);
    function zb(i) {
      if (!i[ex]) {
        i[ex] = !0, ge.forEach(function(m) {
          m !== "selectionchange" && (uO.has(m) || cO(m, !1, i), cO(m, !0, i));
        var l = i.nodeType === Fl ? i : i.ownerDocument;
        l !== null && (l[ex] || (l[ex] = !0, cO("selectionchange", !1, l)));
    function EA(i, l, m, y, S) {
      var R = ii(i, l, m), L = void 0;
      kp && (l === "touchstart" || l === "touchmove" || l === "wheel") && (L = !0), i = i, y ? L !== void 0 ? Ob(i, l, R, L) : ls(i, l, R) : L !== void 0 ? cf(i, l, R, L) : ih(i, l, R);
    function TA(i, l) {
      return i === l || i.nodeType === vo && i.parentNode === l;
    function dO(i, l, m, y, S) {
      var R = y;
      if (!(l & Xy) && !(l & Mm)) {
        if (y !== null) {
          var W = y;
            if (W === null)
            var Z = W.tag;
            if (Z === v || Z === w) {
              var ae = W.stateNode.containerInfo;
              if (TA(ae, L))
                for (var le = W.return; le !== null; ) {
                  if (Te === v || Te === w) {
                    if (TA(xe, L))
                var $e = hh(ae);
                if ($e === null)
                var ze = $e.tag;
                  W = R = $e;
            W = W.return;
      l0(function() {
        return TG(i, l, m, R);
    function Bb(i, l, m) {
        currentTarget: m
    function _G(i, l, m, y, S, R) {
      for (var L = l !== null ? l + "Capture" : null, W = y ? L : l, Z = [], ae = i, le = null; ae !== null; ) {
        var Te = ae, xe = Te.stateNode, $e = Te.tag;
        if ($e === C && xe !== null && (le = xe, W !== null)) {
          var ze = Mu(ae, W);
          ze != null && Z.push(Bb(ae, ze, le));
    function tx(i, l) {
      for (var m = l + "Capture", y = [], S = i; S !== null; ) {
        var R = S, L = R.stateNode, W = R.tag;
        if (W === C && L !== null) {
          var Z = L, ae = Mu(S, m);
          ae != null && y.unshift(Bb(S, ae, Z));
          var le = Mu(S, l);
          le != null && y.push(Bb(S, le, Z));
      return y;
    function Dg(i) {
    function OG(i, l) {
      for (var m = i, y = l, S = 0, R = m; R; R = Dg(R))
      for (var L = 0, W = y; W; W = Dg(W))
        m = Dg(m), S--;
        y = Dg(y), L--;
        if (m === y || y !== null && m === y.alternate)
          return m;
        m = Dg(m), y = Dg(y);
    function _A(i, l, m, y, S) {
      for (var R = l._reactName, L = [], W = m; W !== null && W !== y; ) {
        var Z = W, ae = Z.alternate, le = Z.stateNode, Te = Z.tag;
        if (ae !== null && ae === y)
            var $e = Mu(W, R);
            $e != null && L.unshift(Bb(W, $e, xe));
            var ze = Mu(W, R);
            ze != null && L.push(Bb(W, ze, xe));
        W = W.return;
    function RG(i, l, m, y, S) {
      var R = y && S ? OG(y, S) : null;
      y !== null && _A(i, l, y, R, !1), S !== null && m !== null && _A(i, m, S, R, !0);
    function kG(i, l) {
    var Ks = !1, Hb = "dangerouslySetInnerHTML", nx = "suppressContentEditableWarning", mf = "suppressHydrationWarning", OA = "autoFocus", fh = "children", ph = "style", rx = "__html", fO, ox, Vb, RA, ix, kA, PA;
    fO = {
    }, ox = function(i, l) {
      qy(i, l), km(i, l), i0(i, l, {
    }, kA = _e && !document.documentMode, Vb = function(i, l, m) {
      if (!Ks) {
        var y = sx(m), S = sx(l);
        S !== y && (Ks = !0, a("Prop `%s` did not match. Server: %s Client: %s", i, JSON.stringify(S), JSON.stringify(y)));
      }
    }, RA = function(i) {
      if (!Ks) {
        Ks = !0;
        i.forEach(function(m) {
          l.push(m);
    }, ix = function(i, l) {
    }, PA = function(i, l) {
      var m = i.namespaceURI === Ll ? i.ownerDocument.createElement(i.tagName) : i.ownerDocument.createElementNS(i.namespaceURI, i.tagName);
      return m.innerHTML = l, m.innerHTML;
    var PG = /\r\n?/g, MG = /\u0000|\uFFFD/g;
    function sx(i) {
      return l.replace(PG, `
`).replace(MG, "");
    function ax(i, l, m, y) {
      var S = sx(l), R = sx(i);
      if (R !== S && (y && (Ks || (Ks = !0, a('Text content did not match. Server: "%s" Client: "%s"', R, S))), m && X))
    function MA(i) {
      return i.nodeType === Fl ? i : i.ownerDocument;
    }
    function IG() {
    }
    function lx(i) {
      i.onclick = IG;
    }
    function DG(i, l, m, y, S) {
      for (var R in y)
        if (y.hasOwnProperty(R)) {
          var L = y[R];
          if (R === ph)
            L && Object.freeze(L), ZC(l, L);
          else if (R === Hb) {
            var W = L ? L[rx] : void 0;
            W != null && BC(l, W);
          } else if (R === fh)
              Z && Wd(l, L);
            } else typeof L == "number" && Wd(l, "" + L);
          else R === nx || R === mf || R === OA || (fe.hasOwnProperty(R) ? L != null && (typeof L != "function" && ix(R, L), R === "onScroll" && eo("scroll", l)) : L != null && Kr(l, R, L, S));
    function AG(i, l, m, y) {
        R === ph ? ZC(i, L) : R === Hb ? BC(i, L) : R === fh ? Wd(i, L) : Kr(i, R, L, y);
    function NG(i, l, m, y) {
      var S, R = MA(m), L, W = y;
      if (W === Ll && (W = zy(i)), W === Ll) {
        if (S = ku(i, l), !S && i !== i.toLowerCase() && a("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", i), i === "script") {
        L = R.createElementNS(W, i);
      return W === Ll && !S && Object.prototype.toString.call(L) === "[object HTMLUnknownElement]" && !ce.call(fO, i) && (fO[i] = !0, a("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", i)), L;
    function $G(i, l) {
      return MA(l).createTextNode(i);
    function LG(i, l, m, y) {
      var S = ku(l, m);
      ox(l, m);
          eo("cancel", i), eo("close", i), R = m;
          eo("load", i), R = m;
          for (var L = 0; L < Fb.length; L++)
            eo(Fb[L], i);
          R = m;
          eo("error", i), R = m;
          eo("error", i), eo("load", i), R = m;
          eo("toggle", i), R = m;
          va(i, m), R = Ud(i, m), eo("invalid", i);
          Xn(i, m), R = m;
          Mc(i, m), R = wp(i, m), eo("invalid", i);
          Ly(i, m), R = $y(i, m), eo("invalid", i);
          R = m;
      switch (Om(l, R), DG(l, i, y, R, S), l) {
          ga(i), je(i, m, !1);
          ga(i), FC(i);
          Dr(i, m);
          Ay(i, m);
          typeof R.onClick == "function" && lx(i);
    function jG(i, l, m, y, S) {
      ox(l, y);
      var R = null, L, W;
          L = Ud(i, m), W = Ud(i, y), R = [];
          L = wp(i, m), W = wp(i, y), R = [];
          L = $y(i, m), W = $y(i, y), R = [];
          L = m, W = y, typeof L.onClick != "function" && typeof W.onClick == "function" && lx(i);
      Om(l, W);
        if (!(W.hasOwnProperty(Z) || !L.hasOwnProperty(Z) || L[Z] == null))
          if (Z === ph) {
          } else Z === Hb || Z === fh || Z === nx || Z === mf || Z === OA || (fe.hasOwnProperty(Z) ? R || (R = []) : (R = R || []).push(Z, null));
      for (Z in W) {
        var xe = W[Z], $e = L != null ? L[Z] : void 0;
        if (!(!W.hasOwnProperty(Z) || xe === $e || xe == null && $e == null))
          if (Z === ph)
            if (xe && Object.freeze(xe), $e) {
              for (ae in $e)
                $e.hasOwnProperty(ae) && (!xe || !xe.hasOwnProperty(ae)) && (le || (le = {}), le[ae] = "");
                xe.hasOwnProperty(ae) && $e[ae] !== xe[ae] && (le || (le = {}), le[ae] = xe[ae]);
          else if (Z === Hb) {
            var ze = xe ? xe[rx] : void 0, Ge = $e ? $e[rx] : void 0;
          } else Z === fh ? (typeof xe == "string" || typeof xe == "number") && (R = R || []).push(Z, "" + xe) : Z === nx || Z === mf || (fe.hasOwnProperty(Z) ? (xe != null && (typeof xe != "function" && ix(Z, xe), Z === "onScroll" && eo("scroll", i)), !R && $e !== xe && (R = [])) : (R = R || []).push(Z, xe));
      return le && (F1(le, W[ph]), (R = R || []).push(ph, le)), R;
    function FG(i, l, m, y, S) {
      m === "input" && S.type === "radio" && S.name != null && ne(i, S);
      var R = ku(m, y), L = ku(m, S);
      switch (AG(i, l, R, L), m) {
          jC(i, S);
          Em(i, S);
    function zG(i) {
        return Tp.hasOwnProperty(l) && Tp[l] || null;
    function BG(i, l, m, y, S, R, L) {
      var W, Z;
      switch (W = ku(l, m), ox(l, m), l) {
          eo("cancel", i), eo("close", i);
          eo("load", i);
          for (var ae = 0; ae < Fb.length; ae++)
            eo(Fb[ae], i);
          eo("error", i);
          eo("error", i), eo("load", i);
          eo("toggle", i);
          va(i, m), eo("invalid", i);
          Xn(i, m);
          Mc(i, m), eo("invalid", i);
          Ly(i, m), eo("invalid", i);
      Om(l, m);
      var $e = null;
      for (var ze in m)
        if (m.hasOwnProperty(ze)) {
          var Ge = m[ze];
          if (ze === fh)
            typeof Ge == "string" ? i.textContent !== Ge && (m[mf] !== !0 && ax(i.textContent, Ge, R, L), $e = [fh, Ge]) : typeof Ge == "number" && i.textContent !== "" + Ge && (m[mf] !== !0 && ax(i.textContent, Ge, R, L), $e = [fh, "" + Ge]);
            Ge != null && (typeof Ge != "function" && ix(ze, Ge), ze === "onScroll" && eo("scroll", i));
          typeof W == "boolean") {
            var kt = void 0, nn = Lt(ze);
            if (m[mf] !== !0) {
              if (!(ze === nx || ze === mf || // Controlled attributes are not validated
                if (ze === Hb) {
                  var Yt = i.innerHTML, qn = Ge ? Ge[rx] : void 0;
                  if (qn != null) {
                    var zn = PA(i, qn);
                    zn !== Yt && Vb(ze, Yt, zn);
                } else if (ze === ph) {
                  if (Z.delete(ze), kA) {
                    var Pe = L1(Ge);
                    kt = i.getAttribute("style"), Pe !== kt && Vb(ze, kt, Pe);
                } else if (W && !V)
                  Z.delete(ze.toLowerCase()), kt = Zo(i, ze, Ge), Ge !== kt && Vb(ze, kt, Ge);
                else if (!bt(ze, nn, W) && !St(ze, Ge, nn, W)) {
                    Z.delete(nn.attributeName), kt = gr(i, ze, Ge, nn);
                    var Me = y;
                    if (Me === Ll && (Me = zy(l)), Me === Ll)
                      var dt = zG(ze);
                    kt = Zo(i, ze, Ge);
                  var Dt = V;
                  !Dt && Ge !== kt && !qe && Vb(ze, kt, Ge);
      Z.size > 0 && m[mf] !== !0 && RA(Z), l) {
          ga(i), je(i, m, !0);
          ga(i), FC(i);
          typeof m.onClick == "function" && lx(i);
      return $e;
    function HG(i, l, m) {
      var y = i.nodeValue !== l;
      return y;
    function pO(i, l) {
        if (Ks)
        Ks = !0, a("Did not expect server HTML to contain a <%s> in <%s>.", l.nodeName.toLowerCase(), i.nodeName.toLowerCase());
    function hO(i, l) {
        if (Ks)
        Ks = !0, a('Did not expect server HTML to contain the text node "%s" in <%s>.', l.nodeValue, i.nodeName.toLowerCase());
    function mO(i, l, m) {
        if (Ks)
        Ks = !0, a("Expected server HTML to contain a matching <%s> in <%s>.", l, i.nodeName.toLowerCase());
    function gO(i, l) {
        if (l === "" || Ks)
        Ks = !0, a('Expected server HTML to contain a matching text node for "%s" in <%s>.', l, i.nodeName.toLowerCase());
    function VG(i, l, m) {
          Ve(i, m);
          D1(i, m);
          Ny(i, m);
    var Ub = function() {
    }, Wb = function() {
      var UG = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], IA = [
      ], WG = IA.concat(["button"]), GG = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], DA = {
      Wb = function(i, l) {
        var m = xn({}, i || DA), y = {
        return IA.indexOf(l) !== -1 && (m.aTagInScope = null, m.buttonTagInScope = null, m.nobrTagInScope = null), WG.indexOf(l) !== -1 && (m.pTagInButtonScope = null), UG.indexOf(l) !== -1 && l !== "address" && l !== "div" && l !== "p" && (m.listItemTagAutoclosing = null, m.dlItemTagAutoclosing = null), m.current = y, l === "form" && (m.formTag = y), l === "a" && (m.aTagInScope = y), l === "button" && (m.buttonTagInScope = y), l === "nobr" && (m.nobrTagInScope = y), l === "p" && (m.pTagInButtonScope = y), l === "li" && (m.listItemTagAutoclosing = y), (l === "dd" || l === "dt") && (m.dlItemTagAutoclosing = y), m;
      var qG = function(i, l) {
            return GG.indexOf(l) === -1;
      }, KG = function(i, l) {
      }, AA = {};
      Ub = function(i, l, m) {
        m = m || DA;
        var y = m.current, S = y && y.tag;
        var R = qG(i, S) ? null : y, L = R ? null : KG(i, m), W = R || L;
        if (W) {
          var Z = W.tag, ae = !!R + "|" + i + "|" + Z;
          if (!AA[ae]) {
            AA[ae] = !0;
    var ux = "suppressHydrationWarning", cx = "$", dx = "/$", Gb = "$?", qb = "$!", YG = "style", vO = null, yO = null;
    function XG(i) {
      var l, m, y = i.nodeType;
      switch (y) {
        case Fl:
        case Hy: {
          l = y === Fl ? "#document" : "#fragment";
          m = S ? S.namespaceURI : By(null, "");
          var R = y === vo ? i.parentNode : i, L = R.namespaceURI || null;
          l = R.tagName, m = By(L, l);
        var W = l.toLowerCase(), Z = Wb(null, W);
          namespace: m,
    function QG(i, l, m) {
        var y = i, S = By(y.namespace, l), R = Wb(y.ancestorInfo, l);
    function S0e(i) {
    function JG(i) {
      vO = xo(), yO = fG();
      return $o(!1), l;
    function ZG(i) {
      pG(yO), $o(vO), vO = null, yO = null;
    function e3(i, l, m, y, S) {
        var L = y;
        if (Ub(i, null, L.ancestorInfo), typeof l.children == "string" || typeof l.children == "number") {
          var W = "" + l.children, Z = Wb(L.ancestorInfo, i);
          Ub(null, W, Z);
      var ae = NG(i, l, m, R);
      return Xb(S, ae), _O(ae, l), ae;
    function t3(i, l) {
    function n3(i, l, m, y, S) {
      switch (LG(i, l, m, y), l) {
          return !!m.autoFocus;
    function r3(i, l, m, y, S, R) {
        if (typeof y.children != typeof m.children && (typeof y.children == "string" || typeof y.children == "number")) {
          var W = "" + y.children, Z = Wb(L.ancestorInfo, l);
          Ub(null, W, Z);
      return jG(i, l, m, y);
    function bO(i, l) {
    function o3(i, l, m, y) {
        var S = m;
        Ub(null, i, S.ancestorInfo);
      var R = $G(i, l);
      return Xb(y, R), R;
    function i3() {
      return i === void 0 ? Us : wg(i.type);
    var wO = typeof setTimeout == "function" ? setTimeout : void 0, s3 = typeof clearTimeout == "function" ? clearTimeout : void 0, SO = -1, NA = typeof Promise == "function" ? Promise : void 0, a3 = typeof queueMicrotask == "function" ? queueMicrotask : typeof NA < "u" ? function(i) {
      return NA.resolve(null).then(i).catch(l3);
    } : wO;
    function l3(i) {
    function u3(i, l, m, y) {
          m.autoFocus && i.focus();
          m.src && (i.src = m.src);
    function c3(i, l, m, y, S, R) {
      FG(i, l, m, y, S), _O(i, S);
    function $A(i) {
      Wd(i, "");
    function d3(i, l, m) {
      i.nodeValue = m;
    function f3(i, l) {
    function p3(i, l) {
      var m;
      i.nodeType === vo ? (m = i.parentNode, m.insertBefore(l, i)) : (m = i, m.appendChild(l));
      var y = i._reactRootContainer;
      y == null && m.onclick === null && lx(m);
    function h3(i, l, m) {
      i.insertBefore(l, m);
    function m3(i, l, m) {
      i.nodeType === vo ? i.parentNode.insertBefore(l, m) : i.insertBefore(l, m);
    function g3(i, l) {
    function v3(i, l) {
      i.nodeType === vo ? i.parentNode.removeChild(l) : i.removeChild(l);
    function CO(i, l) {
      var m = l, y = 0;
        var S = m.nextSibling;
        if (i.removeChild(m), S && S.nodeType === vo) {
          if (R === dx)
            if (y === 0) {
              i.removeChild(S), Jc(l);
              y--;
          else (R === cx || R === Gb || R === qb) && y++;
        m = S;
      } while (m);
      Jc(l);
    function y3(i, l) {
      i.nodeType === vo ? CO(i.parentNode, l) : i.nodeType === Zi && CO(i, l), Jc(i);
    function b3(i) {
    function w3(i) {
    function S3(i, l) {
      var m = l[YG], y = m != null && m.hasOwnProperty("display") ? m.display : null;
      i.style.display = _m("display", y);
    function C3(i, l) {
    function x3(i) {
      i.nodeType === Zi ? i.textContent = "" : i.nodeType === Fl && i.documentElement && i.removeChild(i.documentElement);
    function E3(i, l, m) {
      return i.nodeType !== Zi || l.toLowerCase() !== i.nodeName.toLowerCase() ? null : i;
    function T3(i, l) {
      return l === "" || i.nodeType !== jl ? null : i;
    function _3(i) {
      return i.nodeType !== vo ? null : i;
    function LA(i) {
      return i.data === Gb;
    function xO(i) {
      return i.data === qb;
    function O3(i) {
      var l = i.nextSibling && i.nextSibling.dataset, m, y, S;
      return l && (m = l.dgst, y = l.msg, S = l.stck), {
        message: y,
        digest: m,
    function R3(i, l) {
    function fx(i) {
        if (l === Zi || l === jl)
        if (l === vo) {
          var m = i.data;
          if (m === cx || m === qb || m === Gb)
          if (m === dx)
    function Kb(i) {
      return fx(i.nextSibling);
    function k3(i) {
      return fx(i.firstChild);
    function P3(i) {
      return fx(i.firstChild);
    function M3(i) {
      return fx(i.nextSibling);
    function I3(i, l, m, y, S, R, L) {
      Xb(R, i), _O(i, m);
      var W;
        W = Z.namespace;
      var ae = (R.mode & Mn) !== Jt;
      return BG(i, l, m, W, y, ae, L);
    function D3(i, l, m, y) {
      return Xb(m, i), m.mode & Mn, HG(i, l);
    function A3(i, l) {
      Xb(l, i);
    function N3(i) {
      for (var l = i.nextSibling, m = 0; l; ) {
        if (l.nodeType === vo) {
          var y = l.data;
          if (y === dx) {
            if (m === 0)
              return Kb(l);
            m--;
          } else (y === cx || y === qb || y === Gb) && m++;
    function jA(i) {
      for (var l = i.previousSibling, m = 0; l; ) {
        if (l.nodeType === vo) {
          var y = l.data;
          if (y === cx || y === qb || y === Gb) {
            if (m === 0)
            m--;
          } else y === dx && m++;
    function $3(i) {
      Jc(i);
    function L3(i) {
      Jc(i);
    function j3(i) {
    function F3(i, l, m, y) {
      ax(l.nodeValue, m, y, S);
    function z3(i, l, m, y, S, R) {
      if (l[ux] !== !0) {
        ax(y.nodeValue, S, R, L);
    function B3(i, l) {
      l.nodeType === Zi ? pO(i, l) : l.nodeType === vo || hO(i, l);
    function H3(i, l) {
        var m = i.parentNode;
        m !== null && (l.nodeType === Zi ? pO(m, l) : l.nodeType === vo || hO(m, l));
    function V3(i, l, m, y, S) {
      (S || l[ux] !== !0) && (y.nodeType === Zi ? pO(m, y) : y.nodeType === vo || hO(m, y));
    function U3(i, l, m) {
      mO(i, l);
    function W3(i, l) {
      gO(i, l);
    function G3(i, l, m) {
        var y = i.parentNode;
        y !== null && mO(y, l);
    function q3(i, l) {
        var m = i.parentNode;
        m !== null && gO(m, l);
    function K3(i, l, m, y, S, R) {
      (R || l[ux] !== !0) && mO(m, y);
    function Y3(i, l, m, y, S) {
      (S || l[ux] !== !0) && gO(m, y);
    function X3(i) {
    function Q3(i) {
      zb(i);
    var Ag = Math.random().toString(36).slice(2), Ng = "__reactFiber$" + Ag, EO = "__reactProps$" + Ag, Yb = "__reactContainer$" + Ag, TO = "__reactEvents$" + Ag, J3 = "__reactListeners$" + Ag, Z3 = "__reactHandles$" + Ag;
    function e6(i) {
      delete i[Ng], delete i[EO], delete i[TO], delete i[J3], delete i[Z3];
    function Xb(i, l) {
      l[Ng] = i;
    function px(i, l) {
      l[Yb] = i;
    function FA(i) {
      i[Yb] = null;
    function Qb(i) {
      return !!i[Yb];
    function hh(i) {
      var l = i[Ng];
      for (var m = i.parentNode; m; ) {
        if (l = m[Yb] || m[Ng], l) {
          var y = l.alternate;
          if (l.child !== null || y !== null && y.child !== null)
            for (var S = jA(i); S !== null; ) {
              var R = S[Ng];
              S = jA(S);
        i = m, m = i.parentNode;
    function gf(i) {
      var l = i[Ng] || i[Yb];
      return l && (l.tag === C || l.tag === T || l.tag === k || l.tag === v) ? l : null;
    function $g(i) {
    function hx(i) {
      return i[EO] || null;
    function _O(i, l) {
      i[EO] = l;
    function t6(i) {
      var l = i[TO];
      return l === void 0 && (l = i[TO] = /* @__PURE__ */ new Set()), l;
    var zA = {}, BA = n.ReactDebugCurrentFrame;
    function mx(i) {
        var l = i._owner, m = Al(i.type, i._source, l ? l.type : null);
        BA.setExtraStackFrame(m);
        BA.setExtraStackFrame(null);
    function Xl(i, l, m, y, S) {
            var W = void 0;
                var Z = Error((y || "React class") + ": " + m + " type `" + L + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[L] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
              W = i[L](l, L, y, m, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              W = ae;
            W && !(W instanceof Error) && (mx(S), a("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", y || "React class", m, L, typeof W), mx(null)), W instanceof Error && !(W.message in zA) && (zA[W.message] = !0, mx(S), a("Failed %s type: %s", m, W.message), mx(null));
    var OO = [], gx;
    gx = [];
    var od = -1;
    function vf(i) {
    function cs(i, l) {
      if (od < 0) {
      l !== gx[od] && a("Unexpected Fiber popped."), i.current = OO[od], OO[od] = null, gx[od] = null, od--;
    function ds(i, l, m) {
      od++, OO[od] = i.current, gx[od] = m, i.current = l;
    var RO;
    RO = {};
    var Ea = {};
    Object.freeze(Ea);
    var id = vf(Ea), Yu = vf(!1), kO = Ea;
    function Lg(i, l, m) {
      return m && Xu(l) ? kO : id.current;
    function HA(i, l, m) {
        var y = i.stateNode;
        y.__reactInternalMemoizedUnmaskedChildContext = l, y.__reactInternalMemoizedMaskedChildContext = m;
    function jg(i, l) {
        var m = i.type, y = m.contextTypes;
        if (!y)
          return Ea;
        for (var L in y)
          var W = yn(i) || "Unknown";
          Xl(y, R, "context", W);
        return S && HA(i, l, R), R;
    function vx() {
      return Yu.current;
    function Xu(i) {
    function yx(i) {
      cs(Yu, i), cs(id, i);
    function PO(i) {
      cs(Yu, i), cs(id, i);
    function VA(i, l, m) {
        if (id.current !== Ea)
        ds(id, l, i), ds(Yu, m, i);
    function UA(i, l, m) {
        var y = i.stateNode, S = l.childContextTypes;
        if (typeof y.getChildContext != "function") {
            var R = yn(i) || "Unknown";
            RO[R] || (RO[R] = !0, a("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", R, R));
          return m;
        var L = y.getChildContext();
        for (var W in L)
          if (!(W in S))
            throw new Error((yn(i) || "Unknown") + '.getChildContext(): key "' + W + '" is not defined in childContextTypes.');
          var Z = yn(i) || "Unknown";
          Xl(S, L, "child context", Z);
        return xn({}, m, L);
    function bx(i) {
        var l = i.stateNode, m = l && l.__reactInternalMemoizedMergedChildContext || Ea;
        return kO = id.current, ds(id, m, i), ds(Yu, Yu.current, i), !0;
    function WA(i, l, m) {
        var y = i.stateNode;
        if (!y)
        if (m) {
          var S = UA(i, l, kO);
          y.__reactInternalMemoizedMergedChildContext = S, cs(Yu, i), cs(id, i), ds(id, S, i), ds(Yu, m, i);
          cs(Yu, i), ds(Yu, m, i);
    function n6(i) {
        if (!jc(i) || i.tag !== h)
            case v:
            case h: {
              var m = l.type;
              if (Xu(m))
    var yf = 0, wx = 1, sd = null, MO = !1, IO = !1;
    function GA(i) {
      sd === null ? sd = [i] : sd.push(i);
    function r6(i) {
      MO = !0, GA(i);
    function qA() {
      MO && bf();
    function bf() {
      if (!IO && sd !== null) {
        IO = !0;
        var i = 0, l = Gs();
          var m = !0, y = sd;
          for (Co(Ai); i < y.length; i++) {
            var S = y[i];
              S = S(m);
          sd = null, MO = !1;
          throw sd !== null && (sd = sd.slice(i + 1)), eb(Dp, bf), R;
          Co(l), IO = !1;
    var Fg = [], zg = 0, Sx = null, Cx = 0, il = [], sl = 0, mh = null, ad = 1, ld = "";
    function o6(i) {
      return vh(), (i.flags & Ya) !== Qt;
    function i6(i) {
      return vh(), Cx;
    function s6() {
      var i = ld, l = ad, m = l & ~a6(l);
      return m.toString(32) + i;
    function gh(i, l) {
      vh(), Fg[zg++] = Cx, Fg[zg++] = Sx, Sx = i, Cx = l;
    function KA(i, l, m) {
      vh(), il[sl++] = ad, il[sl++] = ld, il[sl++] = mh, mh = i;
      var y = ad, S = ld, R = xx(y) - 1, L = y & ~(1 << R), W = m + 1, Z = xx(l) + R;
        var ae = R - R % 5, le = (1 << ae) - 1, Te = (L & le).toString(32), xe = L >> ae, $e = R - ae, ze = xx(l) + $e, Ge = W << $e, kt = Ge | xe, nn = Te + S;
        ad = 1 << ze | kt, ld = nn;
        var Yt = W << R, qn = Yt | L, zn = S;
        ad = 1 << Z | qn, ld = zn;
    function DO(i) {
      vh();
        var m = 1, y = 0;
        gh(i, m), KA(i, m, y);
    function xx(i) {
      return 32 - wo(i);
    function a6(i) {
      return 1 << xx(i) - 1;
    }
    function AO(i) {
      for (; i === Sx; )
        Sx = Fg[--zg], Fg[zg] = null, Cx = Fg[--zg], Fg[zg] = null;
      for (; i === mh; )
        mh = il[--sl], il[sl] = null, ld = il[--sl], il[sl] = null, ad = il[--sl], il[sl] = null;
    }
    function l6() {
      return vh(), mh !== null ? {
        id: ad,
        overflow: ld
    function u6(i, l) {
      vh(), il[sl++] = ad, il[sl++] = ld, il[sl++] = mh, ad = l.id, ld = l.overflow, mh = i;
    function vh() {
      Fi() || a("Expected to be hydrating. This is a bug in React. Please file an issue.");
    var ji = null, al = null, Ql = !1, yh = !1, wf = null;
    function c6() {
      Ql && a("We should not be hydrating here. This is a bug in React. Please file a bug.");
    function YA() {
      yh = !0;
    function d6() {
      return yh;
    function f6(i) {
      return al = P3(l), ji = i, Ql = !0, wf = null, yh = !1, !0;
    function p6(i, l, m) {
      return al = M3(l), ji = i, Ql = !0, wf = null, yh = !1, m !== null && u6(i, m), !0;
    function XA(i, l) {
        case v: {
          B3(i.stateNode.containerInfo, l);
          var m = (i.mode & Mn) !== Jt;
          V3(
            m
        case k: {
          var y = i.memoizedState;
          y.dehydrated !== null && H3(y.dehydrated, l);
    function QA(i, l) {
      XA(i, l);
      var m = v9();
      m.stateNode = l, m.return = i;
      var y = i.deletions;
      y === null ? (i.deletions = [m], i.flags |= Fs) : y.push(m);
    function NO(i, l) {
        if (yh)
          case v: {
            var m = i.stateNode.containerInfo;
                var y = l.type;
                l.pendingProps, U3(m, y);
                W3(m, S);
            var R = i.type, L = i.memoizedProps, W = i.stateNode;
                var Z = l.type, ae = l.pendingProps, le = (i.mode & Mn) !== Jt;
                K3(
                  W,
                var Te = l.pendingProps, xe = (i.mode & Mn) !== Jt;
                Y3(
                  W,
          case k: {
            var $e = i.memoizedState, ze = $e.dehydrated;
                l.pendingProps, G3(ze, Ge);
                q3(ze, kt);
    function JA(i, l) {
      l.flags = l.flags & ~ts | Qr, NO(i, l);
    function ZA(i, l) {
          var m = i.type;
          var y = E3(l, m);
          return y !== null ? (i.stateNode = y, ji = i, al = k3(y), !0) : !1;
          var S = i.pendingProps, R = T3(l, S);
          return R !== null ? (i.stateNode = R, ji = i, al = null, !0) : !1;
        case k: {
          var L = _3(l);
            var W = {
              treeContext: l6(),
              retryLane: is
            i.memoizedState = W;
            var Z = y9(L);
            return Z.return = i, i.child = Z, ji = i, al = null, !0;
    function $O(i) {
      return (i.mode & Mn) !== Jt && (i.flags & Xt) === Qt;
    function LO(i) {
    function jO(i) {
      if (Ql) {
        var l = al;
          $O(i) && (NO(ji, i), LO()), JA(ji, i), Ql = !1, ji = i;
        var m = l;
        if (!ZA(i, l)) {
          $O(i) && (NO(ji, i), LO()), l = Kb(m);
          var y = ji;
          if (!l || !ZA(i, l)) {
            JA(ji, i), Ql = !1, ji = i;
          QA(y, m);
    function h6(i, l, m) {
      var y = i.stateNode, S = !yh, R = I3(y, i.type, i.memoizedProps, l, m, i, S);
    function m6(i) {
      var l = i.stateNode, m = i.memoizedProps, y = D3(l, m, i);
      if (y) {
        var S = ji;
            case v: {
              var R = S.stateNode.containerInfo, L = (S.mode & Mn) !== Jt;
              F3(
                m,
              var W = S.type, Z = S.memoizedProps, ae = S.stateNode, le = (S.mode & Mn) !== Jt;
              z3(
                W,
                m,
      return y;
    function g6(i) {
      var l = i.memoizedState, m = l !== null ? l.dehydrated : null;
      if (!m)
      A3(m, i);
    function v6(i) {
      var l = i.memoizedState, m = l !== null ? l.dehydrated : null;
      if (!m)
      return N3(m);
    function eN(i) {
      for (var l = i.return; l !== null && l.tag !== C && l.tag !== v && l.tag !== k; )
      ji = l;
    function Ex(i) {
      if (i !== ji)
      if (!Ql)
        return eN(i), Ql = !0, !1;
      if (i.tag !== v && (i.tag !== C || j3(i.type) && !bO(i.type, i.memoizedProps))) {
        var l = al;
          if ($O(i))
            tN(i), LO();
              QA(i, l), l = Kb(l);
      return eN(i), i.tag === k ? al = v6(i) : al = ji ? Kb(i.stateNode) : null, !0;
    function y6() {
      return Ql && al !== null;
    function tN(i) {
      for (var l = al; l; )
        XA(i, l), l = Kb(l);
    function Bg() {
      ji = null, al = null, Ql = !1, yh = !1;
    function nN() {
      wf !== null && (Y$(wf), wf = null);
    function Fi() {
      return Ql;
    function FO(i) {
      wf === null ? wf = [i] : wf.push(i);
    var b6 = n.ReactCurrentBatchConfig, w6 = null;
    function S6() {
      return b6.transition;
    var Jl = {
      var C6 = function(i) {
        for (var l = null, m = i; m !== null; )
          m.mode & wr && (l = m), m = m.return;
      }, bh = function(i) {
        return i.forEach(function(m) {
          l.push(m);
      }, Jb = [], Zb = [], ew = [], tw = [], nw = [], rw = [], wh = /* @__PURE__ */ new Set();
      Jl.recordUnsafeLifecycleWarnings = function(i, l) {
        wh.has(i.type) || (typeof l.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        l.componentWillMount.__suppressDeprecationWarning !== !0 && Jb.push(i), i.mode & wr && typeof l.UNSAFE_componentWillMount == "function" && Zb.push(i), typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && ew.push(i), i.mode & wr && typeof l.UNSAFE_componentWillReceiveProps == "function" && tw.push(i), typeof l.componentWillUpdate == "function" && l.componentWillUpdate.__suppressDeprecationWarning !== !0 && nw.push(i), i.mode & wr && typeof l.UNSAFE_componentWillUpdate == "function" && rw.push(i));
      }, Jl.flushPendingUnsafeLifecycleWarnings = function() {
        Jb.length > 0 && (Jb.forEach(function(xe) {
          i.add(yn(xe) || "Component"), wh.add(xe.type);
        }), Jb = []);
        Zb.length > 0 && (Zb.forEach(function(xe) {
          l.add(yn(xe) || "Component"), wh.add(xe.type);
        }), Zb = []);
        var m = /* @__PURE__ */ new Set();
        ew.length > 0 && (ew.forEach(function(xe) {
          m.add(yn(xe) || "Component"), wh.add(xe.type);
        }), ew = []);
        var y = /* @__PURE__ */ new Set();
        tw.length > 0 && (tw.forEach(function(xe) {
          y.add(yn(xe) || "Component"), wh.add(xe.type);
        }), tw = []);
        nw.length > 0 && (nw.forEach(function(xe) {
          S.add(yn(xe) || "Component"), wh.add(xe.type);
        }), nw = []);
        if (rw.length > 0 && (rw.forEach(function(xe) {
          R.add(yn(xe) || "Component"), wh.add(xe.type);
        }), rw = []), l.size > 0) {
          var L = bh(l);
        if (y.size > 0) {
          var W = bh(y);
Please update the following components: %s`, W);
          var Z = bh(R);
          var ae = bh(i);
        if (m.size > 0) {
          var le = bh(m);
          var Te = bh(S);
      var Tx = /* @__PURE__ */ new Map(), rN = /* @__PURE__ */ new Set();
      Jl.recordLegacyContextWarning = function(i, l) {
        var m = C6(i);
        if (m === null) {
        if (!rN.has(i.type)) {
          var y = Tx.get(m);
          (i.type.contextTypes != null || i.type.childContextTypes != null || l !== null && typeof l.getChildContext == "function") && (y === void 0 && (y = [], Tx.set(m, y)), y.push(i));
      }, Jl.flushLegacyContextWarning = function() {
        Tx.forEach(function(i, l) {
            var m = i[0], y = /* @__PURE__ */ new Set();
              y.add(yn(R) || "Component"), rN.add(R.type);
            var S = bh(y);
              vr(m), a(`Legacy context API has been detected within a strict-mode tree.
              zr();
      }, Jl.discardPendingWarnings = function() {
        Jb = [], Zb = [], ew = [], tw = [], nw = [], rw = [], Tx = /* @__PURE__ */ new Map();
    var zO, BO, HO, VO, UO, oN = function(i, l) {
    zO = !1, BO = !1, HO = {}, VO = {}, UO = {}, oN = function(i, l) {
        var m = yn(l) || "Component";
        VO[m] || (VO[m] = !0, a('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
    function x6(i) {
    function ow(i, l, m) {
      var y = m.ref;
      if (y !== null && typeof y != "function" && typeof y != "object") {
        if ((i.mode & wr || ie) && // We warn in ReactElement.js if owner and self are equal for string refs
        !(m._owner && m._self && m._owner.stateNode !== m._self) && // Will already throw with "Function components cannot have string refs"
        !(m._owner && m._owner.tag !== h) && // Will already warn with "Function components cannot be given refs"
        !(typeof m.type == "function" && !x6(m.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        m._owner) {
          var S = yn(i) || "Component";
          HO[S] || (a('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', S, y), HO[S] = !0);
        }
        if (m._owner) {
          var R = m._owner, L;
            var W = R;
            if (W.tag !== h)
            L = W.stateNode;
            throw new Error("Missing owner for string ref " + y + ". This error is likely caused by a bug in React. Please file an issue.");
          rt(y, "ref");
          var ae = "" + y;
          if (typeof y != "string")
          if (!m._owner)
            throw new Error("Element ref was specified as a string (" + y + `) but no owner was set. This could happen for one of the following reasons:
      return y;
    function _x(i, l) {
      var m = Object.prototype.toString.call(l);
      throw new Error("Objects are not valid as a React child (found: " + (m === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : m) + "). If you meant to render a collection of children, use an array instead.");
    function Ox(i) {
        var l = yn(i) || "Component";
        if (UO[l])
        UO[l] = !0, a("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
    function iN(i) {
      var l = i._payload, m = i._init;
      return m(l);
    function sN(i) {
          Me === null ? (Pe.deletions = [qe], Pe.flags |= Fs) : Me.push(qe);
      function m(Pe, qe) {
      function y(Pe, qe) {
        var Me = kh(Pe, qe);
          return Pe.flags |= Ya, qe;
          return Dt < qe ? (Pe.flags |= Qr, qe) : Dt;
          return Pe.flags |= Qr, qe;
        return i && Pe.alternate === null && (Pe.flags |= Qr), Pe;
      function W(Pe, qe, Me, dt) {
          var Dt = Fk(Me, Pe.mode, dt);
        if (Dt === Yi)
        dL(qe, Me) || // Lazy types should reconcile their resolved type.
        typeof Dt == "object" && Dt !== null && Dt.$$typeof === De && iN(Dt) === qe.type)) {
          return Pt.ref = ow(Pe, qe, Me), Pt.return = Pe, Pt._debugSource = Me._source, Pt._debugOwner = Me._owner, Pt;
        var mn = jk(Me, Pe.mode, dt);
        return mn.ref = ow(Pe, qe, Me), mn.return = Pe, mn;
          var Dt = zk(Me, Pe.mode, dt);
          var Pt = Mf(Me, Pe.mode, dt, Dt);
          var mn = S(qe, Me);
          return mn.return = Pe, mn;
          var dt = Fk("" + qe, Pe.mode, Me);
            case so: {
              var Dt = jk(qe, Pe.mode, Me);
              return Dt.ref = ow(Pe, null, qe), Dt.return = Pe, Dt;
            case Yr: {
              var Pt = zk(qe, Pe.mode, Me);
              var mn = qe._payload, En = qe._init;
              return Te(Pe, En(mn), Me);
          if (Pn(qe) || wn(qe)) {
            var Cr = Mf(qe, Pe.mode, Me, null);
            return Cr.return = Pe, Cr;
          _x(Pe, qe);
        return typeof qe == "function" && Ox(Pe), null;
          return Dt !== null ? null : W(Pe, qe, "" + Me, dt);
            case so:
            case Yr:
              var Pt = Me._payload, mn = Me._init;
              return xe(Pe, qe, mn(Pt), dt);
          if (Pn(Me) || wn(Me))
          _x(Pe, Me);
        return typeof Me == "function" && Ox(Pe), null;
      function $e(Pe, qe, Me, dt, Dt) {
          return W(qe, Pt, "" + dt, Dt);
            case so: {
              var mn = Pe.get(dt.key === null ? Me : dt.key) || null;
              return Z(qe, mn, dt, Dt);
            case Yr: {
              var En = Pe.get(dt.key === null ? Me : dt.key) || null;
              return ae(qe, En, dt, Dt);
              var Cr = dt._payload, or = dt._init;
              return $e(Pe, qe, Me, or(Cr), Dt);
          if (Pn(dt) || wn(dt)) {
          _x(qe, dt);
        return typeof dt == "function" && Ox(qe), null;
            case so:
            case Yr:
              oN(Pe, Me);
          var mn = Me[Pt];
          Dt = ze(mn, Dt, Pe);
        }
        for (var En = null, Cr = null, or = qe, Lo = 0, ir = 0, To = null; or !== null && ir < Me.length; ir++) {
          or.index > ir ? (To = or, or = null) : To = or.sibling;
          var ps = xe(Pe, or, Me[ir], dt);
          if (ps === null) {
            or === null && (or = To);
          i && or && ps.alternate === null && l(Pe, or), Lo = R(ps, Lo, ir), Cr === null ? En = ps : Cr.sibling = ps, Cr = ps, or = To;
        if (ir === Me.length) {
          if (m(Pe, or), Fi()) {
            var Gi = ir;
            gh(Pe, Gi);
          return En;
        if (or === null) {
          for (; ir < Me.length; ir++) {
            var _a = Te(Pe, Me[ir], dt);
            _a !== null && (Lo = R(_a, Lo, ir), Cr === null ? En = _a : Cr.sibling = _a, Cr = _a);
          if (Fi()) {
            var ks = ir;
            gh(Pe, ks);
          return En;
        for (var Ps = y(Pe, or); ir < Me.length; ir++) {
          var hs = $e(Ps, Pe, ir, Me[ir], dt);
          hs !== null && (i && hs.alternate !== null && Ps.delete(hs.key === null ? ir : hs.key), Lo = R(hs, Lo, ir), Cr === null ? En = hs : Cr.sibling = hs, Cr = hs);
        if (i && Ps.forEach(function(sv) {
          return l(Pe, sv);
        }), Fi()) {
          var md = ir;
          gh(Pe, md);
        return En;
        var Dt = wn(Me);
          Me[Symbol.toStringTag] === "Generator" && (BO || a("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), BO = !0), Me.entries === Dt && (zO || a("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), zO = !0);
            for (var mn = null, En = Pt.next(); !En.done; En = Pt.next()) {
              var Cr = En.value;
              mn = ze(Cr, mn, Pe);
        var or = Dt.call(Me);
        if (or == null)
        for (var Lo = null, ir = null, To = qe, ps = 0, Gi = 0, _a = null, ks = or.next(); To !== null && !ks.done; Gi++, ks = or.next()) {
          To.index > Gi ? (_a = To, To = null) : _a = To.sibling;
          var Ps = xe(Pe, To, ks.value, dt);
          if (Ps === null) {
            To === null && (To = _a);
          i && To && Ps.alternate === null && l(Pe, To), ps = R(Ps, ps, Gi), ir === null ? Lo = Ps : ir.sibling = Ps, ir = Ps, To = _a;
        if (ks.done) {
          if (m(Pe, To), Fi()) {
            var hs = Gi;
            gh(Pe, hs);
        if (To === null) {
          for (; !ks.done; Gi++, ks = or.next()) {
            var md = Te(Pe, ks.value, dt);
            md !== null && (ps = R(md, ps, Gi), ir === null ? Lo = md : ir.sibling = md, ir = md);
          if (Fi()) {
            var sv = Gi;
            gh(Pe, sv);
        for (var $w = y(Pe, To); !ks.done; Gi++, ks = or.next()) {
          var oc = $e($w, Pe, Gi, ks.value, dt);
          oc !== null && (i && oc.alternate !== null && $w.delete(oc.key === null ? Gi : oc.key), ps = R(oc, ps, Gi), ir === null ? Lo = oc : ir.sibling = oc, ir = oc);
        if (i && $w.forEach(function(Y9) {
          return l(Pe, Y9);
        }), Fi()) {
          var K9 = Gi;
          gh(Pe, K9);
          m(Pe, qe.sibling);
        m(Pe, qe);
        var Pt = Fk(Me, Pe.mode, dt);
            var mn = Me.type;
            if (mn === Yi) {
                m(Pe, Pt.sibling);
                var En = S(Pt, Me.props.children);
                return En.return = Pe, En._debugSource = Me._source, En._debugOwner = Me._owner, En;
            } else if (Pt.elementType === mn || // Keep this check inline so it only runs on the false path:
            dL(Pt, Me) || // Lazy types should reconcile their resolved type.
            typeof mn == "object" && mn !== null && mn.$$typeof === De && iN(mn) === Pt.type) {
              m(Pe, Pt.sibling);
              var Cr = S(Pt, Me.props);
              return Cr.ref = ow(Pe, Pt, Me), Cr.return = Pe, Cr._debugSource = Me._source, Cr._debugOwner = Me._owner, Cr;
            m(Pe, Pt);
        if (Me.type === Yi) {
          var or = Mf(Me.props.children, Pe.mode, dt, Me.key);
          return or.return = Pe, or;
          var Lo = jk(Me, Pe.mode, dt);
          return Lo.ref = ow(Pe, qe, Me), Lo.return = Pe, Lo;
      function qn(Pe, qe, Me, dt) {
              m(Pe, Pt.sibling);
              var mn = S(Pt, Me.children || []);
              return mn.return = Pe, mn;
              m(Pe, Pt);
        var En = zk(Me, Pe.mode, dt);
        return En.return = Pe, En;
      function zn(Pe, qe, Me, dt) {
        var Dt = typeof Me == "object" && Me !== null && Me.type === Yi && Me.key === null;
            case so:
            case Yr:
              return L(qn(Pe, qe, Me, dt));
              var Pt = Me._payload, mn = Me._init;
              return zn(Pe, qe, mn(Pt), dt);
          if (Pn(Me))
          if (wn(Me))
          _x(Pe, Me);
        return typeof Me == "string" && Me !== "" || typeof Me == "number" ? L(nn(Pe, qe, "" + Me, dt)) : (typeof Me == "function" && Ox(Pe), m(Pe, qe));
      return zn;
    var Hg = sN(!0), aN = sN(!1);
    function E6(i, l) {
        var m = l.child, y = kh(m, m.pendingProps);
        for (l.child = y, y.return = l; m.sibling !== null; )
          m = m.sibling, y = y.sibling = kh(m, m.pendingProps), y.return = l;
        y.sibling = null;
    function T6(i, l) {
      for (var m = i.child; m !== null; )
        f9(m, l), m = m.sibling;
    var WO = vf(null), GO;
    GO = {};
    var Rx = null, Vg = null, qO = null, kx = !1;
    function Px() {
      Rx = null, Vg = null, qO = null, kx = !1;
    function lN() {
      kx = !0;
    function uN() {
      kx = !1;
    function cN(i, l, m) {
      ds(WO, l._currentValue, i), l._currentValue = m, l._currentRenderer !== void 0 && l._currentRenderer !== null && l._currentRenderer !== GO && a("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer = GO;
    function KO(i, l) {
      var m = WO.current;
      cs(WO, l), i._currentValue = m;
    function YO(i, l, m) {
      for (var y = i; y !== null; ) {
        var S = y.alternate;
        if (Qc(y.childLanes, l) ? S !== null && !Qc(S.childLanes, l) && (S.childLanes = _n(S.childLanes, l)) : (y.childLanes = _n(y.childLanes, l), S !== null && (S.childLanes = _n(S.childLanes, l))), y === m)
        y = y.return;
      y !== m && a("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    function _6(i, l, m) {
      O6(i, l, m);
    function O6(i, l, m) {
      var y = i.child;
      for (y !== null && (y.return = i); y !== null; ) {
        var S = void 0, R = y.dependencies;
          S = y.child;
              if (y.tag === h) {
                var W = qp(m), Z = ud(Pr, W);
                Z.tag = Ix;
                var ae = y.updateQueue;
              y.lanes = _n(y.lanes, m);
              var xe = y.alternate;
              xe !== null && (xe.lanes = _n(xe.lanes, m)), YO(y.return, m, i), R.lanes = _n(R.lanes, m);
        } else if (y.tag === I)
          S = y.type === i.type ? null : y.child;
        else if (y.tag === D) {
          var $e = y.return;
          if ($e === null)
          $e.lanes = _n($e.lanes, m);
          var ze = $e.alternate;
          ze !== null && (ze.lanes = _n(ze.lanes, m)), YO($e, m, i), S = y.sibling;
          S = y.child;
          S.return = y;
          for (S = y; S !== null; ) {
        y = S;
    function Ug(i, l) {
      Rx = i, Vg = null, qO = null;
      var m = i.dependencies;
      if (m !== null) {
        var y = m.firstContext;
        y !== null && (ss(m.lanes, l) && bw(), m.firstContext = null);
    function Go(i) {
      kx && a("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      if (qO !== i) {
        var m = {
        if (Vg === null) {
          if (Rx === null)
          Vg = m, Rx.dependencies = {
            firstContext: m
          Vg = Vg.next = m;
    var Sh = null;
    function XO(i) {
      Sh === null ? Sh = [i] : Sh.push(i);
    function R6() {
      if (Sh !== null) {
        for (var i = 0; i < Sh.length; i++) {
          var l = Sh[i], m = l.interleaved;
          if (m !== null) {
            var y = m.next, S = l.pending;
              S.next = y, m.next = R;
            l.pending = m;
        Sh = null;
    function dN(i, l, m, y) {
      return S === null ? (m.next = m, XO(l)) : (m.next = S.next, S.next = m), l.interleaved = m, Mx(i, y);
    function k6(i, l, m, y) {
      S === null ? (m.next = m, XO(l)) : (m.next = S.next, S.next = m), l.interleaved = m;
    function P6(i, l, m, y) {
      return S === null ? (m.next = m, XO(l)) : (m.next = S.next, S.next = m), l.interleaved = m, Mx(i, y);
    }
    function Ys(i, l) {
      return Mx(i, l);
    }
    var M6 = Mx;
    function Mx(i, l) {
      i.lanes = _n(i.lanes, l);
      var m = i.alternate;
      m !== null && (m.lanes = _n(m.lanes, l)), m === null && (i.flags & (Qr | ts)) !== Qt && aL(i);
      for (var y = i, S = i.return; S !== null; )
        S.childLanes = _n(S.childLanes, l), m = S.alternate, m !== null ? m.childLanes = _n(m.childLanes, l) : (S.flags & (Qr | ts)) !== Qt && aL(i), y = S, S = S.return;
      if (y.tag === v) {
        var R = y.stateNode;
    var fN = 0, pN = 1, Ix = 2, QO = 3, Dx = !1, JO, Ax;
    JO = !1, Ax = null;
    function ZO(i) {
    function hN(i, l) {
      var m = l.updateQueue, y = i.updateQueue;
      if (m === y) {
          baseState: y.baseState,
          firstBaseUpdate: y.firstBaseUpdate,
          lastBaseUpdate: y.lastBaseUpdate,
          shared: y.shared,
          effects: y.effects
    function ud(i, l) {
      var m = {
        tag: fN,
      return m;
    function Sf(i, l, m) {
      var y = i.updateQueue;
      if (y === null)
      var S = y.shared;
      if (Ax === S && !JO && (a("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), JO = !0), k8()) {
        return R === null ? l.next = l : (l.next = R.next, R.next = l), S.pending = l, M6(i, m);
        return P6(i, S, l, m);
    function Nx(i, l, m) {
      var y = l.updateQueue;
      if (y !== null) {
        var S = y.shared;
        if (vb(m)) {
          R = bb(R, i.pendingLanes);
          var L = _n(R, m);
          S.lanes = L, gg(i, L);
    function eR(i, l) {
      var m = i.updateQueue, y = i.alternate;
      if (y !== null) {
        var S = y.updateQueue;
        if (m === S) {
          var R = null, L = null, W = m.firstBaseUpdate;
          if (W !== null) {
            var Z = W;
          m = {
          }, i.updateQueue = m;
      var le = m.lastBaseUpdate;
      le === null ? m.firstBaseUpdate = l : le.next = l, m.lastBaseUpdate = l;
    function I6(i, l, m, y, S, R) {
      switch (m.tag) {
        case pN: {
          var L = m.payload;
            lN();
            var W = L.call(R, y, S);
              if (i.mode & wr) {
                Jr(!0);
                  L.call(R, y, S);
                  Jr(!1);
              uN();
            return W;
        case QO:
          i.flags = i.flags & ~Ho | Xt;
        case fN: {
          var Z = m.payload, ae;
            lN(), ae = Z.call(R, y, S);
              if (i.mode & wr) {
                Jr(!0);
                  Z.call(R, y, S);
                  Jr(!1);
              uN();
          return ae == null ? y : xn({}, y, ae);
        case Ix:
          return Dx = !0, y;
      return y;
    function $x(i, l, m, y) {
      Dx = !1, Ax = S.shared;
      var R = S.firstBaseUpdate, L = S.lastBaseUpdate, W = S.shared.pending;
      if (W !== null) {
        var Z = W, ae = Z.next;
        var $e = S.baseState, ze = it, Ge = null, kt = null, nn = null, Yt = R;
          var qn = Yt.lane, zn = Yt.eventTime;
          if (Qc(y, qn)) {
                eventTime: zn,
                lane: Jn,
            $e = I6(i, S, Yt, $e, l, m);
            Yt.lane !== Jn) {
              i.flags |= Ar;
              eventTime: zn,
              lane: qn,
            nn === null ? (kt = nn = Pe, Ge = $e) : nn = nn.next = Pe, ze = _n(ze, qn);
            if (W = S.shared.pending, W === null)
            var Dt = W, Pt = Dt.next;
        nn === null && (Ge = $e), S.baseState = Ge, S.firstBaseUpdate = kt, S.lastBaseUpdate = nn;
        var mn = S.shared.interleaved;
        if (mn !== null) {
          var En = mn;
            ze = _n(ze, En.lane), En = En.next;
          while (En !== mn);
        Mw(ze), i.lanes = ze, i.memoizedState = $e;
      Ax = null;
    function D6(i, l) {
    function mN() {
      Dx = !1;
    function Lx() {
      return Dx;
    function gN(i, l, m) {
      var y = l.effects;
      if (l.effects = null, y !== null)
        for (var S = 0; S < y.length; S++) {
          var R = y[S], L = R.callback;
          L !== null && (R.callback = null, D6(L, m));
    var iw = {}, Cf = vf(iw), sw = vf(iw), jx = vf(iw);
    function Fx(i) {
      if (i === iw)
    function vN() {
      var i = Fx(jx.current);
    function tR(i, l) {
      ds(jx, l, i), ds(sw, i, i), ds(Cf, iw, i);
      var m = XG(l);
      cs(Cf, i), ds(Cf, m, i);
    function Wg(i) {
      cs(Cf, i), cs(sw, i), cs(jx, i);
    function nR() {
      var i = Fx(Cf.current);
    function yN(i) {
      Fx(jx.current);
      var l = Fx(Cf.current), m = QG(l, i.type);
      l !== m && (ds(sw, i, i), ds(Cf, m, i));
    function rR(i) {
      sw.current === i && (cs(Cf, i), cs(sw, i));
    var A6 = 0, bN = 1, wN = 1, aw = 2, Zl = vf(A6);
    function oR(i, l) {
    function Gg(i) {
      return i & bN;
    function iR(i, l) {
      return i & bN | l;
    function N6(i, l) {
    function xf(i, l) {
      ds(Zl, l, i);
    function qg(i) {
      cs(Zl, i);
    function $6(i, l) {
      var m = i.memoizedState;
      return m !== null ? m.dehydrated !== null : (i.memoizedProps, !0);
    function zx(i) {
        if (l.tag === k) {
          var m = l.memoizedState;
          if (m !== null) {
            var y = m.dehydrated;
            if (y === null || LA(y) || xO(y))
    var Xs = (
    ), si = (
    ), Qu = (
    ), ai = (
    ), zi = (
    ), sR = [];
    function aR() {
      for (var i = 0; i < sR.length; i++) {
        var l = sR[i];
      sR.length = 0;
    function L6(i, l) {
      var m = l._getVersion, y = m(l._source);
      i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [l, y] : i.mutableSourceEagerHydrationData.push(l, y);
    var It = n.ReactCurrentDispatcher, lw = n.ReactCurrentBatchConfig, lR, Kg;
    lR = /* @__PURE__ */ new Set();
    var Ch = it, Sr = null, li = null, ui = null, Bx = !1, uw = !1, cw = 0, j6 = 0, F6 = 25, Qe = null, ll = null, Ef = -1, uR = !1;
    function cr() {
        ll === null ? ll = [i] : ll.push(i);
        ll !== null && (Ef++, ll[Ef] !== i && z6(i));
    function Yg(i) {
      i != null && !Pn(i) && a("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Qe, typeof i);
    function z6(i) {
        var l = yn(Sr);
        if (!lR.has(l) && (lR.add(l), ll !== null)) {
          for (var m = "", y = 30, S = 0; S <= Ef; S++) {
            for (var R = ll[S], L = S === Ef ? i : R, W = S + 1 + ". " + R; W.length < y; )
              W += " ";
            W += L + `
`, m += W;
`, l, m);
    function fs() {
    function cR(i, l) {
      if (uR)
      for (var m = 0; m < l.length && m < i.length; m++)
        if (!lt(i[m], l[m]))
    function Xg(i, l, m, y, S, R) {
      Ch = R, Sr = l, ll = i !== null ? i._debugHookTypes : null, Ef = -1, uR = i !== null && i.type !== l.type, l.memoizedState = null, l.updateQueue = null, l.lanes = it, i !== null && i.memoizedState !== null ? It.current = HN : ll !== null ? It.current = BN : It.current = zN;
      var L = m(y, S);
      if (uw) {
        var W = 0;
          if (uw = !1, cw = 0, W >= F6)
          W += 1, uR = !1, li = null, ui = null, l.updateQueue = null, Ef = -1, It.current = VN, L = m(y, S);
        } while (uw);
      It.current = eE, l._debugHookTypes = ll;
      var Z = li !== null && li.next !== null;
      if (Ch = it, Sr = null, li = null, ui = null, Qe = null, ll = null, Ef = -1, i !== null && (i.flags & bo) !== (l.flags & bo) && // Disable this warning in legacy mode, because legacy Suspense is weird
      (i.mode & Mn) !== Jt && a("Internal React error: Expected static flag was missing. Please notify the React team."), Bx = !1, Z)
    function Qg() {
      var i = cw !== 0;
      return cw = 0, i;
    function SN(i, l, m) {
      l.updateQueue = i.updateQueue, (l.mode & nr) !== Jt ? l.flags &= -50333701 : l.flags &= -2053, i.lanes = Kp(i.lanes, m);
    function CN() {
      if (It.current = eE, Bx) {
        for (var i = Sr.memoizedState; i !== null; ) {
        Bx = !1;
      Ch = it, Sr = null, li = null, ui = null, ll = null, Ef = -1, Qe = null, NN = !1, uw = !1, cw = 0;
    function Ju() {
      return ui === null ? Sr.memoizedState = ui = i : ui = ui.next = i, ui;
    function ul() {
      if (li === null) {
        var l = Sr.alternate;
        i = li.next;
      var m;
      if (ui === null ? m = Sr.memoizedState : m = ui.next, m !== null)
        ui = m, m = ui.next, li = i;
        li = i;
        var y = {
          memoizedState: li.memoizedState,
          baseState: li.baseState,
          baseQueue: li.baseQueue,
          queue: li.queue,
        ui === null ? Sr.memoizedState = ui = y : ui = ui.next = y;
      return ui;
    function xN() {
    function dR(i, l) {
    function fR(i, l, m) {
      var y = Ju(), S;
      m !== void 0 ? S = m(l) : S = l, y.memoizedState = y.baseState = S;
      y.queue = R;
      var L = R.dispatch = U6.bind(null, Sr, R);
      return [y.memoizedState, L];
    function pR(i, l, m) {
      var y = ul(), S = y.queue;
      var R = li, L = R.baseQueue, W = S.pending;
      if (W !== null) {
          var Z = L.next, ae = W.next;
          L.next = ae, W.next = Z;
        R.baseQueue !== L && a("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), R.baseQueue = L = W, S.pending = null;
        var le = L.next, Te = R.baseState, xe = null, $e = null, ze = null, Ge = le;
          if (Qc(Ch, kt)) {
                lane: Jn,
              var qn = Ge.action;
              Te = i(Te, qn);
            ze === null ? ($e = ze = nn, xe = Te) : ze = ze.next = nn, Sr.lanes = _n(Sr.lanes, kt), Mw(kt);
        ze === null ? xe = Te : ze.next = $e, lt(Te, y.memoizedState) || bw(), y.memoizedState = Te, y.baseState = xe, y.baseQueue = ze, S.lastRenderedState = Te;
      var zn = S.interleaved;
      if (zn !== null) {
        var Pe = zn;
          Sr.lanes = _n(Sr.lanes, qe), Mw(qe), Pe = Pe.next;
        } while (Pe !== zn);
      return [y.memoizedState, Me];
    function hR(i, l, m) {
      var y = ul(), S = y.queue;
      var R = S.dispatch, L = S.pending, W = y.memoizedState;
          W = i(W, le), ae = ae.next;
        lt(W, y.memoizedState) || bw(), y.memoizedState = W, y.baseQueue === null && (y.baseState = W), S.lastRenderedState = W;
      return [W, R];
    function C0e(i, l, m) {
    function x0e(i, l, m) {
    function mR(i, l, m) {
      var y = Sr, S = Ju(), R, L = Fi();
        if (m === void 0)
        R = m(), Kg || R !== m() && (a("The result of getServerSnapshot should be cached to avoid an infinite loop"), Kg = !0);
        if (R = l(), !Kg) {
          var W = l();
          lt(R, W) || (a("The result of getSnapshot should be cached to avoid an infinite loop"), Kg = !0);
        var Z = bE();
        hg(Z, Ch) || EN(y, l, R);
      return S.queue = ae, Gx(_N.bind(null, y, ae, i), [i]), y.flags |= es, dw(si | zi, TN.bind(null, y, ae, R, l), void 0, null), R;
    function Hx(i, l, m) {
      var y = Sr, S = ul(), R = l();
      if (!Kg) {
        lt(R, L) || (a("The result of getSnapshot should be cached to avoid an infinite loop"), Kg = !0);
      var W = S.memoizedState, Z = !lt(W, R);
      Z && (S.memoizedState = R, bw());
      if (pw(_N.bind(null, y, ae, i), [i]), ae.getSnapshot !== l || Z || // Check if the susbcribe function changed. We can save some memory by
      ui !== null && ui.memoizedState.tag & si) {
        y.flags |= es, dw(si | zi, TN.bind(null, y, ae, R, l), void 0, null);
        var le = bE();
        hg(le, Ch) || EN(y, l, R);
    function EN(i, l, m) {
      i.flags |= ef;
      var y = {
        value: m
      }, S = Sr.updateQueue;
        S = xN(), Sr.updateQueue = S, S.stores = [y];
        R === null ? S.stores = [y] : R.push(y);
    function TN(i, l, m, y) {
      l.value = m, l.getSnapshot = y, ON(l) && RN(i);
    function _N(i, l, m) {
      var y = function() {
        ON(l) && RN(i);
      return m(y);
    function ON(i) {
      var l = i.getSnapshot, m = i.value;
        var y = l();
        return !lt(m, y);
    function RN(i) {
      var l = Ys(i, cn);
      l !== null && pi(l, i, cn, Pr);
    function Vx(i) {
      var l = Ju();
      var m = {
        lastRenderedReducer: dR,
      l.queue = m;
      var y = m.dispatch = W6.bind(null, Sr, m);
      return [l.memoizedState, y];
    function gR(i) {
      return pR(dR);
    function vR(i) {
      return hR(dR);
    function dw(i, l, m, y) {
        destroy: m,
        deps: y,
      }, R = Sr.updateQueue;
        R = xN(), Sr.updateQueue = R, R.lastEffect = S.next = S;
          var W = L.next;
          L.next = S, S.next = W, R.lastEffect = S;
    function yR(i) {
      var l = Ju();
        var m = {
        return l.memoizedState = m, m;
    function Ux(i) {
      var l = ul();
    function fw(i, l, m, y) {
      var S = Ju(), R = y === void 0 ? null : y;
      Sr.flags |= i, S.memoizedState = dw(si | l, m, void 0, R);
    }
    function Wx(i, l, m, y) {
      var S = ul(), R = y === void 0 ? null : y, L = void 0;
      if (li !== null) {
        var W = li.memoizedState;
        if (L = W.destroy, R !== null) {
          var Z = W.deps;
          if (cR(R, Z)) {
            S.memoizedState = dw(l, m, L, R);
      Sr.flags |= i, S.memoizedState = dw(si | l, m, L, R);
    function Gx(i, l) {
      return (Sr.mode & nr) !== Jt ? fw(Xa | es | Bm, zi, i, l) : fw(es | Bm, zi, i, l);
    function pw(i, l) {
      return Wx(es, zi, i, l);
    function bR(i, l) {
      return fw(Un, Qu, i, l);
    function qx(i, l) {
      return Wx(Un, Qu, i, l);
    function wR(i, l) {
      var m = Un;
      return m |= Bl, (Sr.mode & nr) !== Jt && (m |= Du), fw(m, ai, i, l);
    function Kx(i, l) {
      return Wx(Un, ai, i, l);
    function kN(i, l) {
        var m = l, y = i();
        return m(y), function() {
          m(null);
    function SR(i, l, m) {
      var y = m != null ? m.concat([i]) : null, S = Un;
      return S |= Bl, (Sr.mode & nr) !== Jt && (S |= Du), fw(S, ai, kN.bind(null, l, i), y);
    function Yx(i, l, m) {
      var y = m != null ? m.concat([i]) : null;
      return Wx(Un, ai, kN.bind(null, l, i), y);
    function B6(i, l) {
    var Xx = B6;
    function CR(i, l) {
      var m = Ju(), y = l === void 0 ? null : l;
      return m.memoizedState = [i, y], i;
    function Qx(i, l) {
      var m = ul(), y = l === void 0 ? null : l, S = m.memoizedState;
      if (S !== null && y !== null) {
        if (cR(y, R))
      return m.memoizedState = [i, y], i;
    function xR(i, l) {
      var m = Ju(), y = l === void 0 ? null : l, S = i();
      return m.memoizedState = [S, y], S;
    function Jx(i, l) {
      var m = ul(), y = l === void 0 ? null : l, S = m.memoizedState;
      if (S !== null && y !== null) {
        if (cR(y, R))
      return m.memoizedState = [L, y], L;
    function ER(i) {
      var l = Ju();
    function PN(i) {
      var l = ul(), m = li, y = m.memoizedState;
      return IN(l, y, i);
    function MN(i) {
      var l = ul();
      if (li === null)
      var m = li.memoizedState;
      return IN(l, m, i);
    function IN(i, l, m) {
      var y = !mb(Ch);
      if (y) {
        if (!lt(m, l)) {
          var S = yb();
          Sr.lanes = _n(Sr.lanes, S), Mw(S), i.baseState = !0;
        return i.baseState && (i.baseState = !1, bw()), i.memoizedState = m, m;
    }
    function H6(i, l, m) {
      var y = Gs();
      Co(k0(y, el)), i(!0);
      var S = lw.transition;
      lw.transition = {};
      var R = lw.transition;
      lw.transition._updatedFibers = /* @__PURE__ */ new Set();
        if (Co(y), lw.transition = S, S === null && R._updatedFibers) {
    function TR() {
      var i = Vx(!1), l = i[0], m = i[1], y = H6.bind(null, m), S = Ju();
      return S.memoizedState = y, [l, y];
    }
    function DN() {
      var i = gR(), l = i[0], m = ul(), y = m.memoizedState;
      return [l, y];
    }
    function AN() {
      var i = vR(), l = i[0], m = ul(), y = m.memoizedState;
      return [l, y];
    }
    var NN = !1;
    function V6() {
      return NN;
    }
    function _R() {
      var i = Ju(), l = bE(), m = l.identifierPrefix, y;
      if (Fi()) {
        var S = s6();
        y = ":" + m + "R" + S;
        var R = cw++;
        R > 0 && (y += "H" + R.toString(32)), y += ":";
        var L = j6++;
        y = ":" + m + "r" + L.toString(32) + ":";
      return i.memoizedState = y, y;
    function Zx() {
      var i = ul(), l = i.memoizedState;
    function U6(i, l, m) {
      var y = kf(i), S = {
        lane: y,
        action: m,
      if ($N(i))
        LN(l, S);
        var R = dN(i, l, S, y);
          var L = Rs();
          pi(R, i, y, L), jN(R, l, y);
      FN(i, y);
    function W6(i, l, m) {
      var y = kf(i), S = {
        lane: y,
        action: m,
      if ($N(i))
        LN(l, S);
            var W;
            W = It.current, It.current = eu;
              var Z = l.lastRenderedState, ae = L(Z, m);
                k6(i, l, S, y);
              It.current = W;
        var le = dN(i, l, S, y);
          var Te = Rs();
          pi(le, i, y, Te), jN(le, l, y);
      FN(i, y);
    function $N(i) {
      return i === Sr || l !== null && l === Sr;
    }
    function LN(i, l) {
      uw = Bx = !0;
      var m = i.pending;
      m === null ? l.next = l : (l.next = m.next, m.next = l), i.pending = l;
    }
    function jN(i, l, m) {
      if (vb(m)) {
        var y = l.lanes;
        y = bb(y, i.pendingLanes);
        var S = _n(y, m);
        l.lanes = S, gg(i, S);
      }
    }
    function FN(i, l, m) {
      jp(i, l);
    }
    var eE = {
      readContext: Go,
      useCallback: fs,
      useContext: fs,
      useEffect: fs,
      useImperativeHandle: fs,
      useInsertionEffect: fs,
      useLayoutEffect: fs,
      useMemo: fs,
      useReducer: fs,
      useRef: fs,
      useState: fs,
      useDebugValue: fs,
      useDeferredValue: fs,
      useTransition: fs,
      useMutableSource: fs,
      useSyncExternalStore: fs,
      useId: fs,
    }, zN = null, BN = null, HN = null, VN = null, Zu = null, eu = null, tE = null;
      var OR = function() {
      }, Sn = function() {
      zN = {
          return Go(i);
          return Qe = "useCallback", cr(), Yg(l), CR(i, l);
          return Qe = "useContext", cr(), Go(i);
          return Qe = "useEffect", cr(), Yg(l), Gx(i, l);
        useImperativeHandle: function(i, l, m) {
          return Qe = "useImperativeHandle", cr(), Yg(m), SR(i, l, m);
          return Qe = "useInsertionEffect", cr(), Yg(l), bR(i, l);
          return Qe = "useLayoutEffect", cr(), Yg(l), wR(i, l);
          Qe = "useMemo", cr(), Yg(l);
          var m = It.current;
          It.current = Zu;
            return xR(i, l);
            It.current = m;
        useReducer: function(i, l, m) {
          Qe = "useReducer", cr();
          var y = It.current;
          It.current = Zu;
            return fR(i, l, m);
            It.current = y;
          return Qe = "useRef", cr(), yR(i);
          Qe = "useState", cr();
          It.current = Zu;
            return Vx(i);
          return Qe = "useDebugValue", cr(), void 0;
          return Qe = "useDeferredValue", cr(), ER(i);
          return Qe = "useTransition", cr(), TR();
        useMutableSource: function(i, l, m) {
          return Qe = "useMutableSource", cr(), void 0;
        useSyncExternalStore: function(i, l, m) {
          return Qe = "useSyncExternalStore", cr(), mR(i, l, m);
          return Qe = "useId", cr(), _R();
      }, BN = {
          return Go(i);
          return Qe = "useCallback", xt(), CR(i, l);
          return Qe = "useContext", xt(), Go(i);
          return Qe = "useEffect", xt(), Gx(i, l);
        useImperativeHandle: function(i, l, m) {
          return Qe = "useImperativeHandle", xt(), SR(i, l, m);
          return Qe = "useInsertionEffect", xt(), bR(i, l);
          return Qe = "useLayoutEffect", xt(), wR(i, l);
          var m = It.current;
          It.current = Zu;
            return xR(i, l);
            It.current = m;
        useReducer: function(i, l, m) {
          var y = It.current;
          It.current = Zu;
            return fR(i, l, m);
            It.current = y;
          return Qe = "useRef", xt(), yR(i);
          It.current = Zu;
            return Vx(i);
          return Qe = "useDeferredValue", xt(), ER(i);
          return Qe = "useTransition", xt(), TR();
        useMutableSource: function(i, l, m) {
        useSyncExternalStore: function(i, l, m) {
          return Qe = "useSyncExternalStore", xt(), mR(i, l, m);
          return Qe = "useId", xt(), _R();
      }, HN = {
          return Go(i);
          return Qe = "useCallback", xt(), Qx(i, l);
          return Qe = "useContext", xt(), Go(i);
          return Qe = "useEffect", xt(), pw(i, l);
        useImperativeHandle: function(i, l, m) {
          return Qe = "useImperativeHandle", xt(), Yx(i, l, m);
          return Qe = "useInsertionEffect", xt(), qx(i, l);
          return Qe = "useLayoutEffect", xt(), Kx(i, l);
          var m = It.current;
          It.current = eu;
            return Jx(i, l);
            It.current = m;
        useReducer: function(i, l, m) {
          var y = It.current;
          It.current = eu;
            return pR(i, l, m);
            It.current = y;
          return Qe = "useRef", xt(), Ux();
          It.current = eu;
            return gR(i);
          return Qe = "useDebugValue", xt(), Xx();
          return Qe = "useDeferredValue", xt(), PN(i);
          return Qe = "useTransition", xt(), DN();
        useMutableSource: function(i, l, m) {
        useSyncExternalStore: function(i, l, m) {
          return Qe = "useSyncExternalStore", xt(), Hx(i, l);
          return Qe = "useId", xt(), Zx();
      }, VN = {
          return Go(i);
          return Qe = "useCallback", xt(), Qx(i, l);
          return Qe = "useContext", xt(), Go(i);
          return Qe = "useEffect", xt(), pw(i, l);
        useImperativeHandle: function(i, l, m) {
          return Qe = "useImperativeHandle", xt(), Yx(i, l, m);
          return Qe = "useInsertionEffect", xt(), qx(i, l);
          return Qe = "useLayoutEffect", xt(), Kx(i, l);
          var m = It.current;
          It.current = tE;
            return Jx(i, l);
            It.current = m;
        useReducer: function(i, l, m) {
          var y = It.current;
          It.current = tE;
            return hR(i, l, m);
            It.current = y;
          return Qe = "useRef", xt(), Ux();
          It.current = tE;
            return vR(i);
          return Qe = "useDebugValue", xt(), Xx();
          return Qe = "useDeferredValue", xt(), MN(i);
          return Qe = "useTransition", xt(), AN();
        useMutableSource: function(i, l, m) {
        useSyncExternalStore: function(i, l, m) {
          return Qe = "useSyncExternalStore", xt(), Hx(i, l);
          return Qe = "useId", xt(), Zx();
      }, Zu = {
          return OR(), Go(i);
          return Qe = "useCallback", Sn(), cr(), CR(i, l);
          return Qe = "useContext", Sn(), cr(), Go(i);
          return Qe = "useEffect", Sn(), cr(), Gx(i, l);
        useImperativeHandle: function(i, l, m) {
          return Qe = "useImperativeHandle", Sn(), cr(), SR(i, l, m);
          return Qe = "useInsertionEffect", Sn(), cr(), bR(i, l);
          return Qe = "useLayoutEffect", Sn(), cr(), wR(i, l);
          Qe = "useMemo", Sn(), cr();
          var m = It.current;
          It.current = Zu;
            return xR(i, l);
            It.current = m;
        useReducer: function(i, l, m) {
          Qe = "useReducer", Sn(), cr();
          var y = It.current;
          It.current = Zu;
            return fR(i, l, m);
            It.current = y;
          return Qe = "useRef", Sn(), cr(), yR(i);
          Qe = "useState", Sn(), cr();
          It.current = Zu;
            return Vx(i);
          return Qe = "useDebugValue", Sn(), cr(), void 0;
          return Qe = "useDeferredValue", Sn(), cr(), ER(i);
          return Qe = "useTransition", Sn(), cr(), TR();
        useMutableSource: function(i, l, m) {
          return Qe = "useMutableSource", Sn(), cr(), void 0;
        useSyncExternalStore: function(i, l, m) {
          return Qe = "useSyncExternalStore", Sn(), cr(), mR(i, l, m);
          return Qe = "useId", Sn(), cr(), _R();
      }, eu = {
          return OR(), Go(i);
          return Qe = "useCallback", Sn(), xt(), Qx(i, l);
          return Qe = "useContext", Sn(), xt(), Go(i);
          return Qe = "useEffect", Sn(), xt(), pw(i, l);
        useImperativeHandle: function(i, l, m) {
          return Qe = "useImperativeHandle", Sn(), xt(), Yx(i, l, m);
          return Qe = "useInsertionEffect", Sn(), xt(), qx(i, l);
          return Qe = "useLayoutEffect", Sn(), xt(), Kx(i, l);
          Qe = "useMemo", Sn(), xt();
          var m = It.current;
          It.current = eu;
            return Jx(i, l);
            It.current = m;
        useReducer: function(i, l, m) {
          Qe = "useReducer", Sn(), xt();
          var y = It.current;
          It.current = eu;
            return pR(i, l, m);
            It.current = y;
          return Qe = "useRef", Sn(), xt(), Ux();
          Qe = "useState", Sn(), xt();
          It.current = eu;
            return gR(i);
          return Qe = "useDebugValue", Sn(), xt(), Xx();
          return Qe = "useDeferredValue", Sn(), xt(), PN(i);
          return Qe = "useTransition", Sn(), xt(), DN();
        useMutableSource: function(i, l, m) {
          return Qe = "useMutableSource", Sn(), xt(), void 0;
        useSyncExternalStore: function(i, l, m) {
          return Qe = "useSyncExternalStore", Sn(), xt(), Hx(i, l);
          return Qe = "useId", Sn(), xt(), Zx();
      }, tE = {
          return OR(), Go(i);
          return Qe = "useCallback", Sn(), xt(), Qx(i, l);
          return Qe = "useContext", Sn(), xt(), Go(i);
          return Qe = "useEffect", Sn(), xt(), pw(i, l);
        useImperativeHandle: function(i, l, m) {
          return Qe = "useImperativeHandle", Sn(), xt(), Yx(i, l, m);
          return Qe = "useInsertionEffect", Sn(), xt(), qx(i, l);
          return Qe = "useLayoutEffect", Sn(), xt(), Kx(i, l);
          Qe = "useMemo", Sn(), xt();
          var m = It.current;
          It.current = eu;
            return Jx(i, l);
            It.current = m;
        useReducer: function(i, l, m) {
          Qe = "useReducer", Sn(), xt();
          var y = It.current;
          It.current = eu;
            return hR(i, l, m);
            It.current = y;
          return Qe = "useRef", Sn(), xt(), Ux();
          Qe = "useState", Sn(), xt();
          It.current = eu;
            return vR(i);
          return Qe = "useDebugValue", Sn(), xt(), Xx();
          return Qe = "useDeferredValue", Sn(), xt(), MN(i);
          return Qe = "useTransition", Sn(), xt(), AN();
        useMutableSource: function(i, l, m) {
          return Qe = "useMutableSource", Sn(), xt(), void 0;
        useSyncExternalStore: function(i, l, m) {
          return Qe = "useSyncExternalStore", Sn(), xt(), Hx(i, l);
          return Qe = "useId", Sn(), xt(), Zx();
    var Tf = t.unstable_now, UN = 0, nE = -1, hw = -1, rE = -1, RR = !1, oE = !1;
    function WN() {
      return RR;
    function G6() {
      oE = !0;
    function q6() {
      RR = !1, oE = !1;
    function K6() {
      RR = oE, oE = !1;
    function GN() {
      return UN;
    function qN() {
      UN = Tf();
    function kR(i) {
      hw = Tf(), i.actualStartTime < 0 && (i.actualStartTime = Tf());
    function KN(i) {
      hw = -1;
    function iE(i, l) {
      if (hw >= 0) {
        var m = Tf() - hw;
        i.actualDuration += m, l && (i.selfBaseDuration = m), hw = -1;
    function ec(i) {
      if (nE >= 0) {
        var l = Tf() - nE;
        nE = -1;
        for (var m = i.return; m !== null; ) {
          switch (m.tag) {
            case v:
              var y = m.stateNode;
              y.effectDuration += l;
            case A:
              var S = m.stateNode;
          m = m.return;
    function PR(i) {
      if (rE >= 0) {
        var l = Tf() - rE;
        rE = -1;
        for (var m = i.return; m !== null; ) {
          switch (m.tag) {
            case v:
              var y = m.stateNode;
              y !== null && (y.passiveEffectDuration += l);
            case A:
              var S = m.stateNode;
          m = m.return;
    function tc() {
      nE = Tf();
    function MR() {
      rE = Tf();
    function IR(i) {
    function tu(i, l) {
        var m = xn({}, l), y = i.defaultProps;
        for (var S in y)
          m[S] === void 0 && (m[S] = y[S]);
        return m;
    var DR = {}, AR, NR, $R, LR, jR, YN, sE, FR, zR, BR, mw;
      AR = /* @__PURE__ */ new Set(), NR = /* @__PURE__ */ new Set(), $R = /* @__PURE__ */ new Set(), LR = /* @__PURE__ */ new Set(), FR = /* @__PURE__ */ new Set(), jR = /* @__PURE__ */ new Set(), zR = /* @__PURE__ */ new Set(), BR = /* @__PURE__ */ new Set(), mw = /* @__PURE__ */ new Set();
      var XN = /* @__PURE__ */ new Set();
      sE = function(i, l) {
          var m = l + "_" + i;
          XN.has(m) || (XN.add(m), a("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", l, i));
      }, YN = function(i, l) {
          var m = Yn(i) || "Component";
          jR.has(m) || (jR.add(m), a("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", m));
      }, Object.defineProperty(DR, "_processChildContext", {
      }), Object.freeze(DR);
    function HR(i, l, m, y) {
      var S = i.memoizedState, R = m(y, S);
        if (i.mode & wr) {
          Jr(!0);
            R = m(y, S);
            Jr(!1);
        YN(l, R);
      var L = R == null ? S : xn({}, S, R);
        var W = i.updateQueue;
        W.baseState = L;
    var VR = {
      isMounted: p0,
      enqueueSetState: function(i, l, m) {
        var y = Zd(i), S = Rs(), R = kf(y), L = ud(S, R);
        L.payload = l, m != null && (sE(m, "setState"), L.callback = m);
        var W = Sf(y, L, R);
        W !== null && (pi(W, y, R, S), Nx(W, y, R)), jp(y, R);
      enqueueReplaceState: function(i, l, m) {
        var y = Zd(i), S = Rs(), R = kf(y), L = ud(S, R);
        L.tag = pN, L.payload = l, m != null && (sE(m, "replaceState"), L.callback = m);
        var W = Sf(y, L, R);
        W !== null && (pi(W, y, R, S), Nx(W, y, R)), jp(y, R);
        var m = Zd(i), y = Rs(), S = kf(m), R = ud(y, S);
        R.tag = Ix, l != null && (sE(l, "forceUpdate"), R.callback = l);
        var L = Sf(m, R, S);
        L !== null && (pi(L, m, S, y), Nx(L, m, S)), Km(m, S);
    function QN(i, l, m, y, S, R, L) {
      var W = i.stateNode;
      if (typeof W.shouldComponentUpdate == "function") {
        var Z = W.shouldComponentUpdate(y, R, L);
          if (i.mode & wr) {
            Jr(!0);
              Z = W.shouldComponentUpdate(y, R, L);
              Jr(!1);
          Z === void 0 && a("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Yn(l) || "Component");
      return l.prototype && l.prototype.isPureReactComponent ? !Vt(m, y) || !Vt(S, R) : !0;
    function Y6(i, l, m) {
      var y = i.stateNode;
        var S = Yn(l) || "Component", R = y.render;
        R || (l.prototype && typeof l.prototype.render == "function" ? a("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", S) : a("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", S)), y.getInitialState && !y.getInitialState.isReactClassApproved && !y.state && a("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", S), y.getDefaultProps && !y.getDefaultProps.isReactClassApproved && a("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", S), y.propTypes && a("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", S), y.contextType && a("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", S), l.childContextTypes && !mw.has(l) && // Strict Mode has its own warning for legacy context, so we can skip
        (i.mode & wr) === Jt && (mw.add(l), a(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead
.Learn more about this warning here: https://reactjs.org/link/legacy-context`, S)), l.contextTypes && !mw.has(l) && // Strict Mode has its own warning for legacy context, so we can skip
        (i.mode & wr) === Jt && (mw.add(l), a(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.
Learn more about this warning here: https://reactjs.org/link/legacy-context`, S)), y.contextTypes && a("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", S), l.contextType && l.contextTypes && !zR.has(l) && (zR.add(l), a("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", S)), typeof y.componentShouldUpdate == "function" && a("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", S), l.prototype && l.prototype.isPureReactComponent && typeof y.shouldComponentUpdate < "u" && a("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Yn(l) || "A pure component"), typeof y.componentDidUnmount == "function" && a("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", S), typeof y.componentDidReceiveProps == "function" && a("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", S), typeof y.componentWillRecieveProps == "function" && a("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", S), typeof y.UNSAFE_componentWillRecieveProps == "function" && a("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", S);
        var L = y.props !== m;
        y.props !== void 0 && L && a("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", S, S), y.defaultProps && a("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", S, S), typeof y.getSnapshotBeforeUpdate == "function" && typeof y.componentDidUpdate != "function" && !$R.has(l) && ($R.add(l), a("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Yn(l))), typeof y.getDerivedStateFromProps == "function" && a("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", S), typeof y.getDerivedStateFromError == "function" && a("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", S), typeof l.getSnapshotBeforeUpdate == "function" && a("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", S);
        var W = y.state;
        W && (typeof W != "object" || Pn(W)) && a("%s.state: must be set to an object or null", S), typeof y.getChildContext == "function" && typeof l.childContextTypes != "object" && a("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", S);
    function JN(i, l) {
      l.updater = VR, i.stateNode = l, Lc(l, i), l._reactInternalInstance = DR;
    function ZN(i, l, m) {
      var y = !1, S = Ea, R = Ea, L = l.contextType;
        var W = (
        if (!W && !BR.has(l)) {
          BR.add(l);
          L === void 0 ? Z = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof L != "object" ? Z = " However, it is set to a " + typeof L + "." : L.$$typeof === Qi ? Z = " Did you accidentally pass the Context.Provider instead?" : L._context !== void 0 ? Z = " Did you accidentally pass the Context.Consumer instead?" : Z = " However, it is set to an object with keys {" + Object.keys(L).join(", ") + "}.", a("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Yn(l) || "Component", Z);
        R = Go(L);
        S = Lg(i, l, !0);
        y = ae != null, R = y ? jg(i, S) : Ea;
      var le = new l(m, R);
      if (i.mode & wr) {
        Jr(!0);
          le = new l(m, R);
          Jr(!1);
      JN(i, le);
          var xe = Yn(l) || "Component";
          NR.has(xe) || (NR.add(xe), a("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", xe, le.state === null ? "null" : "undefined", xe));
          var $e = null, ze = null, Ge = null;
          if (typeof le.componentWillMount == "function" && le.componentWillMount.__suppressDeprecationWarning !== !0 ? $e = "componentWillMount" : typeof le.UNSAFE_componentWillMount == "function" && ($e = "UNSAFE_componentWillMount"), typeof le.componentWillReceiveProps == "function" && le.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? ze = "componentWillReceiveProps" : typeof le.UNSAFE_componentWillReceiveProps == "function" && (ze = "UNSAFE_componentWillReceiveProps"), typeof le.componentWillUpdate == "function" && le.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Ge = "componentWillUpdate" : typeof le.UNSAFE_componentWillUpdate == "function" && (Ge = "UNSAFE_componentWillUpdate"), $e !== null || ze !== null || Ge !== null) {
            var kt = Yn(l) || "Component", nn = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            LR.has(kt) || (LR.add(kt), a(`Unsafe legacy lifecycles will not be called for components using new component APIs.
https://reactjs.org/link/unsafe-component-lifecycles`, kt, nn, $e !== null ? `
  ` + $e : "", ze !== null ? `
      return y && HA(i, S, R), le;
    function X6(i, l) {
      var m = l.state;
      typeof l.componentWillMount == "function" && l.componentWillMount(), typeof l.UNSAFE_componentWillMount == "function" && l.UNSAFE_componentWillMount(), m !== l.state && (a("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", yn(i) || "Component"), VR.enqueueReplaceState(l, l.state, null));
    function e$(i, l, m, y) {
      if (typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(m, y), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(m, y), l.state !== S) {
          var R = yn(i) || "Component";
          AR.has(R) || (AR.add(R), a("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", R));
        VR.enqueueReplaceState(l, l.state, null);
    function UR(i, l, m, y) {
      Y6(i, l, m);
      S.props = m, S.state = i.memoizedState, S.refs = {}, ZO(i);
        S.context = Go(R);
        var L = Lg(i, l, !0);
        S.context = jg(i, L);
        if (S.state === m) {
          var W = Yn(l) || "Component";
          FR.has(W) || (FR.add(W), a("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", W));
        i.mode & wr && Jl.recordLegacyContextWarning(i, S), Jl.recordUnsafeLifecycleWarnings(i, S);
      if (typeof Z == "function" && (HR(i, l, Z, m), S.state = i.memoizedState), typeof l.getDerivedStateFromProps != "function" && typeof S.getSnapshotBeforeUpdate != "function" && (typeof S.UNSAFE_componentWillMount == "function" || typeof S.componentWillMount == "function") && (X6(i, S), $x(i, m, S, y), S.state = i.memoizedState), typeof S.componentDidMount == "function") {
        var ae = Un;
        ae |= Bl, (i.mode & nr) !== Jt && (ae |= Du), i.flags |= ae;
    function Q6(i, l, m, y) {
      var L = S.context, W = l.contextType, Z = Ea;
      if (typeof W == "object" && W !== null)
        Z = Go(W);
        var ae = Lg(i, l, !0);
        Z = jg(i, ae);
      !Te && (typeof S.UNSAFE_componentWillReceiveProps == "function" || typeof S.componentWillReceiveProps == "function") && (R !== m || L !== Z) && e$(i, S, m, Z), mN();
      var xe = i.memoizedState, $e = S.state = xe;
      if ($x(i, m, S, y), $e = i.memoizedState, R === m && xe === $e && !vx() && !Lx()) {
          var ze = Un;
          ze |= Bl, (i.mode & nr) !== Jt && (ze |= Du), i.flags |= ze;
      typeof le == "function" && (HR(i, l, le, m), $e = i.memoizedState);
      var Ge = Lx() || QN(i, l, R, m, xe, $e, Z);
          var kt = Un;
          kt |= Bl, (i.mode & nr) !== Jt && (kt |= Du), i.flags |= kt;
          var nn = Un;
          nn |= Bl, (i.mode & nr) !== Jt && (nn |= Du), i.flags |= nn;
        i.memoizedProps = m, i.memoizedState = $e;
      return S.props = m, S.state = $e, S.context = Z, Ge;
    function J6(i, l, m, y, S) {
      hN(i, l);
      var L = l.memoizedProps, W = l.type === l.elementType ? L : tu(l.type, L);
      R.props = W;
      var Z = l.pendingProps, ae = R.context, le = m.contextType, Te = Ea;
        Te = Go(le);
        var xe = Lg(l, m, !0);
        Te = jg(l, xe);
      var $e = m.getDerivedStateFromProps, ze = typeof $e == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      !ze && (typeof R.UNSAFE_componentWillReceiveProps == "function" || typeof R.componentWillReceiveProps == "function") && (L !== Z || ae !== Te) && e$(l, R, y, Te), mN();
      if ($x(l, y, R, S), kt = l.memoizedState, L === Z && Ge === kt && !vx() && !Lx() && !re)
        return typeof R.componentDidUpdate == "function" && (L !== i.memoizedProps || Ge !== i.memoizedState) && (l.flags |= Un), typeof R.getSnapshotBeforeUpdate == "function" && (L !== i.memoizedProps || Ge !== i.memoizedState) && (l.flags |= Ao), !1;
      typeof $e == "function" && (HR(l, m, $e, y), kt = l.memoizedState);
      var nn = Lx() || QN(l, m, W, y, Ge, kt, Te) || // TODO: In some cases, we'll end up checking if context has changed twice,
      return nn ? (!ze && (typeof R.UNSAFE_componentWillUpdate == "function" || typeof R.componentWillUpdate == "function") && (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(y, kt, Te), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(y, kt, Te)), typeof R.componentDidUpdate == "function" && (l.flags |= Un), typeof R.getSnapshotBeforeUpdate == "function" && (l.flags |= Ao)) : (typeof R.componentDidUpdate == "function" && (L !== i.memoizedProps || Ge !== i.memoizedState) && (l.flags |= Un), typeof R.getSnapshotBeforeUpdate == "function" && (L !== i.memoizedProps || Ge !== i.memoizedState) && (l.flags |= Ao), l.memoizedProps = y, l.memoizedState = kt), R.props = y, R.state = kt, R.context = Te, nn;
    function xh(i, l) {
        stack: Nl(l),
    function WR(i, l, m) {
        stack: m ?? null,
    function Z6(i, l) {
    function GR(i, l) {
        var m = Z6(i, l);
        if (m === !1)
        var y = l.value, S = l.source, R = l.stack, L = R !== null ? R : "";
        if (y != null && y._suppressLogging) {
          if (i.tag === h)
          console.error(y);
        var W = S ? yn(S) : null, Z = W ? "The above error occurred in the <" + W + "> component:" : "The above error occurred in one of your React components:", ae;
        if (i.tag === v)
          var le = yn(i) || "Anonymous";
    var eq = typeof WeakMap == "function" ? WeakMap : Map;
    function t$(i, l, m) {
      var y = ud(Pr, m);
      y.tag = QO, y.payload = {
      return y.callback = function() {
        G8(S), GR(i, l);
      }, y;
    function qR(i, l, m) {
      var y = ud(Pr, m);
      y.tag = QO;
        y.payload = function() {
        }, y.callback = function() {
          fL(i), GR(i, l);
      return L !== null && typeof L.componentDidCatch == "function" && (y.callback = function() {
        fL(i), GR(i, l), typeof S != "function" && U8(this);
        }), typeof S != "function" && (ss(i.lanes, cn) || a("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", yn(i) || "Unknown"));
      }), y;
    function n$(i, l, m) {
      var y = i.pingCache, S;
      if (y === null ? (y = i.pingCache = new eq(), S = /* @__PURE__ */ new Set(), y.set(l, S)) : (S = y.get(l), S === void 0 && (S = /* @__PURE__ */ new Set(), y.set(l, S))), !S.has(m)) {
        S.add(m);
        var R = q8.bind(null, i, l, m);
        os && Iw(i, m), l.then(R, R);
    function tq(i, l, m, y) {
        R.add(m), i.updateQueue = R;
        S.add(m);
    function nq(i, l) {
      var m = i.tag;
      if ((i.mode & Mn) === Jt && (m === f || m === M || m === B)) {
        var y = i.alternate;
        y ? (i.updateQueue = y.updateQueue, i.memoizedState = y.memoizedState, i.lanes = y.lanes) : (i.updateQueue = null, i.memoizedState = null);
    function r$(i) {
        if (l.tag === k && $6(l))
    function o$(i, l, m, y, S) {
      if ((i.mode & Mn) === Jt) {
          i.flags |= Ho;
          if (i.flags |= Xt, m.flags |= zm, m.flags &= -52805, m.tag === h) {
            var R = m.alternate;
              m.tag = F;
              var L = ud(Pr, cn);
              L.tag = Ix, Sf(m, L, cn);
          m.lanes = _n(m.lanes, cn);
      return i.flags |= Ho, i.lanes = S, i;
    function rq(i, l, m, y, S) {
      if (m.flags |= Ip, os && Iw(i, S), y !== null && typeof y == "object" && typeof y.then == "function") {
        var R = y;
        nq(m), Fi() && m.mode & Mn && YA();
        var L = r$(l);
          L.flags &= ~Si, o$(L, l, m, i, S), L.mode & Mn && n$(i, R, S), tq(L, i, R);
          if (!S0(S)) {
            n$(i, R, S), _k();
          var W = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          y = W;
      } else if (Fi() && m.mode & Mn) {
        YA();
        var Z = r$(l);
          (Z.flags & Ho) === Qt && (Z.flags |= Si), o$(Z, l, m, i, S), FO(xh(y, m));
      y = xh(y, m), $8(y);
          case v: {
            var le = y;
            ae.flags |= Ho;
            var Te = qp(S);
            ae.lanes = _n(ae.lanes, Te);
            var xe = t$(ae, le, Te);
            eR(ae, xe);
          case h:
            var $e = y, ze = ae.type, Ge = ae.stateNode;
            if ((ae.flags & Xt) === Qt && (typeof ze.getDerivedStateFromError == "function" || Ge !== null && typeof Ge.componentDidCatch == "function" && !rL(Ge))) {
              ae.flags |= Ho;
              var kt = qp(S);
              ae.lanes = _n(ae.lanes, kt);
              var nn = qR(ae, $e, kt);
              eR(ae, nn);
    function oq() {
    var gw = n.ReactCurrentOwner, nu = !1, KR, vw, YR, XR, QR, Eh, JR, aE, yw;
    KR = {}, vw = {}, YR = {}, XR = {}, QR = {}, Eh = !1, JR = {}, aE = {}, yw = {};
    function _s(i, l, m, y) {
      i === null ? l.child = aN(l, null, m, y) : l.child = Hg(l, i.child, m, y);
    function iq(i, l, m, y) {
      l.child = Hg(l, i.child, null, y), l.child = Hg(l, null, m, y);
    function i$(i, l, m, y, S) {
        var R = m.propTypes;
        R && Xl(
          y,
          Yn(m)
      var L = m.render, W = l.ref, Z, ae;
      Ug(l, S), Cs(l);
        if (gw.current = l, Do(!0), Z = Xg(i, l, L, y, W, S), ae = Qg(), l.mode & wr) {
          Jr(!0);
            Z = Xg(i, l, L, y, W, S), ae = Qg();
            Jr(!1);
        Do(!1);
      return xs(), i !== null && !nu ? (SN(i, l, S), cd(i, l, S)) : (Fi() && ae && DO(l), l.flags |= ba, _s(i, l, Z, S), l.child);
    function s$(i, l, m, y, S) {
        var R = m.type;
        if (c9(R) && m.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        m.defaultProps === void 0) {
          return L = iv(R), l.tag = B, l.type = L, tk(l, R), a$(i, l, L, y, S);
          var W = R.propTypes;
          if (W && Xl(
            W,
            y,
            Yn(R)
          ), m.defaultProps !== void 0) {
            var Z = Yn(R) || "Unknown";
            yw[Z] || (a("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", Z), yw[Z] = !0);
        var ae = Lk(m.type, null, y, l, l.mode, S);
        var le = m.type, Te = le.propTypes;
        Te && Xl(
          y,
          Yn(le)
      var xe = i.child, $e = ak(i, S);
      if (!$e) {
        var ze = xe.memoizedProps, Ge = m.compare;
        if (Ge = Ge !== null ? Ge : Vt, Ge(ze, y) && i.ref === l.ref)
          return cd(i, l, S);
      l.flags |= ba;
      var kt = kh(xe, y);
    function a$(i, l, m, y, S) {
          var L = R, W = L._payload, Z = L._init;
            R = Z(W);
          ae && Xl(
            y,
            Yn(R)
        if (Vt(le, y) && i.ref === l.ref && // Prevent bailout if the implementation changed due to hot reload.
          if (nu = !1, l.pendingProps = y = le, ak(i, S))
            (i.flags & zm) !== Qt && (nu = !0);
          else return l.lanes = i.lanes, cd(i, l, S);
      return ZR(i, l, m, y, S);
    function l$(i, l, m) {
      var y = l.pendingProps, S = y.children, R = i !== null ? i.memoizedState : null;
      if (y.mode === "hidden" || Q)
        if ((l.mode & Mn) === Jt) {
          l.memoizedState = L, wE(l, m);
        } else if (ss(m, is)) {
          var xe = R !== null ? R.baseLanes : m;
          wE(l, xe);
          var W = null, Z;
            Z = _n(ae, m);
            Z = m;
          l.lanes = l.childLanes = is;
            cachePool: W,
          return l.memoizedState = le, l.updateQueue = null, wE(l, Z), null;
        var $e;
        R !== null ? ($e = _n(R.baseLanes, m), l.memoizedState = null) : $e = m, wE(l, $e);
      return _s(i, l, S, m), l.child;
    function sq(i, l, m) {
      var y = l.pendingProps;
      return _s(i, l, y, m), l.child;
    function aq(i, l, m) {
      var y = l.pendingProps.children;
      return _s(i, l, y, m), l.child;
    function lq(i, l, m) {
        l.flags |= Un;
          var y = l.stateNode;
          y.effectDuration = 0, y.passiveEffectDuration = 0;
      return _s(i, l, R, m), l.child;
    function u$(i, l) {
      var m = l.ref;
      (i === null && m !== null || i !== null && i.ref !== m) && (l.flags |= oo, l.flags |= tf);
    function ZR(i, l, m, y, S) {
        var R = m.propTypes;
        R && Xl(
          y,
          Yn(m)
        var W = Lg(l, m, !0);
        L = jg(l, W);
      Ug(l, S), Cs(l);
        if (gw.current = l, Do(!0), Z = Xg(i, l, m, y, L, S), ae = Qg(), l.mode & wr) {
          Jr(!0);
            Z = Xg(i, l, m, y, L, S), ae = Qg();
            Jr(!1);
        Do(!1);
      return xs(), i !== null && !nu ? (SN(i, l, S), cd(i, l, S)) : (Fi() && ae && DO(l), l.flags |= ba, _s(i, l, Z, S), l.child);
    function c$(i, l, m, y, S) {
        switch (T9(l)) {
            var R = l.stateNode, L = l.type, W = new L(l.memoizedProps, R.context), Z = W.state;
            l.flags |= Xt, l.flags |= Ho;
            var ae = new Error("Simulated error coming from DevTools"), le = qp(S);
            l.lanes = _n(l.lanes, le);
            var Te = qR(l, xh(ae, l), le);
            eR(l, Te);
          var xe = m.propTypes;
          xe && Xl(
            y,
            Yn(m)
      var $e;
      Xu(m) ? ($e = !0, bx(l)) : $e = !1, Ug(l, S);
      ze === null ? (uE(i, l), ZN(l, m, y), UR(l, m, y, S), Ge = !0) : i === null ? Ge = Q6(l, m, y, S) : Ge = J6(i, l, m, y, S);
      var kt = ek(i, l, m, Ge, $e, S);
        Ge && nn.props !== y && (Eh || a("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", yn(l) || "a component"), Eh = !0);
    function ek(i, l, m, y, S, R) {
      u$(i, l);
      if (!y && !L)
        return S && WA(l, m, !1), cd(i, l, R);
      var W = l.stateNode;
      gw.current = l;
      if (L && typeof m.getDerivedStateFromError != "function")
        Z = null, KN();
        Cs(l);
          if (Do(!0), Z = W.render(), l.mode & wr) {
            Jr(!0);
              W.render();
              Jr(!1);
          Do(!1);
        xs();
      return l.flags |= ba, i !== null && L ? iq(i, l, Z, R) : _s(i, l, Z, R), l.memoizedState = W.state, S && WA(l, m, !0), l.child;
    function d$(i) {
      l.pendingContext ? VA(i, l.pendingContext, l.pendingContext !== l.context) : l.context && VA(i, l.context, !1), tR(i, l.containerInfo);
    function uq(i, l, m) {
      if (d$(l), i === null)
      var y = l.pendingProps, S = l.memoizedState, R = S.element;
      hN(i, l), $x(l, y, null, m);
      var W = L.element;
          element: W,
        if (ae.baseState = Z, l.memoizedState = Z, l.flags & Si) {
          var le = xh(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), l);
          return f$(i, l, W, m, le);
        } else if (W !== R) {
          var Te = xh(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), l);
          return f$(i, l, W, m, Te);
          f6(l);
          var xe = aN(l, null, W, m);
          for (var $e = xe; $e; )
            $e.flags = $e.flags & ~Qr | ts, $e = $e.sibling;
        if (Bg(), W === R)
          return cd(i, l, m);
        _s(i, l, W, m);
    function f$(i, l, m, y, S) {
      return Bg(), FO(S), l.flags |= Si, _s(i, l, m, y), l.child;
    function cq(i, l, m) {
      yN(l), i === null && jO(l);
      var y = l.type, S = l.pendingProps, R = i !== null ? i.memoizedProps : null, L = S.children, W = bO(y, S);
      return W ? L = null : R !== null && bO(y, R) && (l.flags |= zs), u$(i, l), _s(i, l, L, m), l.child;
    function dq(i, l) {
      return i === null && jO(l), null;
    function fq(i, l, m, y) {
      uE(i, l);
      var S = l.pendingProps, R = m, L = R._payload, W = R._init, Z = W(L);
      var ae = l.tag = d9(Z), le = tu(Z, S), Te;
          return tk(l, Z), l.type = Z = iv(Z), Te = ZR(null, l, Z, le, y), Te;
        case h:
          return l.type = Z = Mk(Z), Te = c$(null, l, Z, le, y), Te;
          return l.type = Z = Ik(Z), Te = i$(null, l, Z, le, y), Te;
        case j: {
            xe && Xl(
              Yn(Z)
          return Te = s$(
            tu(Z.type, le),
            y
      var $e = "";
      throw Z !== null && typeof Z == "object" && Z.$$typeof === De && ($e = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + Z + ". " + ("Lazy element type must resolve to a class or function." + $e));
    function pq(i, l, m, y, S) {
      uE(i, l), l.tag = h;
      return Xu(m) ? (R = !0, bx(l)) : R = !1, Ug(l, S), ZN(l, m, y), UR(l, m, y, S), ek(null, l, m, !0, R, S);
    function hq(i, l, m, y) {
      uE(i, l);
        var L = Lg(l, m, !1);
        R = jg(l, L);
      Ug(l, y);
      var W, Z;
      Cs(l);
        if (m.prototype && typeof m.prototype.render == "function") {
          var ae = Yn(m) || "Unknown";
          KR[ae] || (a("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", ae, ae), KR[ae] = !0);
        l.mode & wr && Jl.recordLegacyContextWarning(l, null), Do(!0), gw.current = l, W = Xg(null, l, m, S, R, y), Z = Qg(), Do(!1);
      if (xs(), l.flags |= ba, typeof W == "object" && W !== null && typeof W.render == "function" && W.$$typeof === void 0) {
        var le = Yn(m) || "Unknown";
        vw[le] || (a("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", le, le, le), vw[le] = !0);
        typeof W == "object" && W !== null && typeof W.render == "function" && W.$$typeof === void 0
          var Te = Yn(m) || "Unknown";
          vw[Te] || (a("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Te, Te, Te), vw[Te] = !0);
        l.tag = h, l.memoizedState = null, l.updateQueue = null;
        return Xu(m) ? (xe = !0, bx(l)) : xe = !1, l.memoizedState = W.state !== null && W.state !== void 0 ? W.state : null, ZO(l), JN(l, W), UR(l, m, S, y), ek(null, l, m, !0, xe, y);
        if (l.tag = f, l.mode & wr) {
          Jr(!0);
            W = Xg(null, l, m, S, R, y), Z = Qg();
            Jr(!1);
        return Fi() && Z && DO(l), _s(null, l, W, y), tk(l, m), l.child;
    function tk(i, l) {
          var m = "", y = Ii();
          y && (m += `
Check the render method of \`` + y + "`.");
          var S = y || "", R = i._debugSource;
          R && (S = R.fileName + ":" + R.lineNumber), QR[S] || (QR[S] = !0, a("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", m));
          var L = Yn(l) || "Unknown";
          yw[L] || (a("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", L), yw[L] = !0);
          var W = Yn(l) || "Unknown";
          XR[W] || (a("%s: Function components do not support getDerivedStateFromProps.", W), XR[W] = !0);
          var Z = Yn(l) || "Unknown";
          YR[Z] || (a("%s: Function components do not support contextType.", Z), YR[Z] = !0);
    var nk = {
      retryLane: Jn
    function rk(i) {
        cachePool: oq(),
    function mq(i, l) {
      var m = null;
        baseLanes: _n(i.baseLanes, l),
        cachePool: m,
    function gq(i, l, m, y) {
      return oR(i, aw);
    function vq(i, l) {
      return Kp(i.childLanes, l);
    function p$(i, l, m) {
      var y = l.pendingProps;
      _9(l) && (l.flags |= Xt);
      var S = Zl.current, R = !1, L = (l.flags & Xt) !== Qt;
      if (L || gq(S, i) ? (R = !0, l.flags &= ~Xt) : (i === null || i.memoizedState !== null) && (S = N6(S, wN)), S = Gg(S), xf(l, S), i === null) {
        jO(l);
        var W = l.memoizedState;
        if (W !== null) {
          var Z = W.dehydrated;
            return Cq(l, Z);
        var ae = y.children, le = y.fallback;
          var Te = yq(l, ae, le, m), xe = l.child;
          return xe.memoizedState = rk(m), l.memoizedState = nk, Te;
          return ok(l, ae);
        var $e = i.memoizedState;
        if ($e !== null) {
          var ze = $e.dehydrated;
            return xq(i, l, L, y, ze, $e, m);
          var Ge = y.fallback, kt = y.children, nn = wq(i, l, kt, Ge, m), Yt = l.child, qn = i.child.memoizedState;
          return Yt.memoizedState = qn === null ? rk(m) : mq(qn, m), Yt.childLanes = vq(i, m), l.memoizedState = nk, nn;
          var zn = y.children, Pe = bq(i, l, zn, m);
    function ok(i, l, m) {
      var y = i.mode, S = {
      }, R = ik(S, y);
    function yq(i, l, m, y) {
      }, W, Z;
      return (S & Mn) === Jt && R !== null ? (W = R, W.childLanes = it, W.pendingProps = L, i.mode & tr && (W.actualDuration = 0, W.actualStartTime = -1, W.selfBaseDuration = 0, W.treeBaseDuration = 0), Z = Mf(m, S, y, null)) : (W = ik(L, S), Z = Mf(m, S, y, null)), W.return = i, Z.return = i, W.sibling = Z, i.child = W, Z;
    function ik(i, l, m) {
      return hL(i, l, it, null);
    function h$(i, l) {
      return kh(i, l);
    function bq(i, l, m, y) {
      var S = i.child, R = S.sibling, L = h$(S, {
        children: m
      if ((l.mode & Mn) === Jt && (L.lanes = y), L.return = l, L.sibling = null, R !== null) {
        var W = l.deletions;
        W === null ? (l.deletions = [R], l.flags |= Fs) : W.push(R);
    function wq(i, l, m, y, S) {
      var R = l.mode, L = i.child, W = L.sibling, Z = {
        children: m
        (R & Mn) === Jt && // Make sure we're on the second pass, i.e. the primary child fragment was
        ae = le, ae.childLanes = it, ae.pendingProps = Z, l.mode & tr && (ae.actualDuration = 0, ae.actualStartTime = -1, ae.selfBaseDuration = L.selfBaseDuration, ae.treeBaseDuration = L.treeBaseDuration), l.deletions = null;
        ae = h$(L, Z), ae.subtreeFlags = L.subtreeFlags & bo;
      return W !== null ? Te = kh(W, y) : (Te = Mf(y, R, S, null), Te.flags |= Qr), Te.return = l, ae.return = l, ae.sibling = Te, l.child = ae, Te;
    function lE(i, l, m, y) {
      y !== null && FO(y), Hg(l, i.child, null, m);
      var S = l.pendingProps, R = S.children, L = ok(l, R);
      return L.flags |= Qr, l.memoizedState = null, L;
    function Sq(i, l, m, y, S) {
        children: m
      }, W = ik(L, R), Z = Mf(y, R, S, null);
      return Z.flags |= Qr, W.return = l, Z.return = l, W.sibling = Z, l.child = W, (l.mode & Mn) !== Jt && Hg(l, i.child, null, S), Z;
    }
    function Cq(i, l, m) {
      return (i.mode & Mn) === Jt ? (a("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), i.lanes = cn) : xO(l) ? i.lanes = Ci : i.lanes = is, null;
    }
    function xq(i, l, m, y, S, R, L) {
      if (m)
        if (l.flags & Si) {
          l.flags &= ~Si;
          var Pe = WR(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return lE(i, l, L, Pe);
          var qe = y.children, Me = y.fallback, dt = Sq(i, l, qe, Me, L), Dt = l.child;
          return Dt.memoizedState = rk(L), l.memoizedState = nk, dt;
        if (c6(), (l.mode & Mn) === Jt)
          return lE(
        if (xO(S)) {
          var W, Z, ae;
            var le = O3(S);
            W = le.digest, Z = le.message, ae = le.stack;
          var xe = WR(Te, W, ae);
          return lE(i, l, L, xe);
        var $e = ss(L, i.childLanes);
        if (nu || $e) {
          var ze = bE();
            var Ge = Sb(ze, L);
            if (Ge !== Jn && Ge !== R.retryLane) {
              var kt = Pr;
              Ys(i, Ge), pi(ze, i, Ge, kt);
          _k();
          var nn = WR(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return lE(i, l, L, nn);
        } else if (LA(S)) {
          var Yt = K8.bind(null, i);
          return R3(S, Yt), null;
          p6(l, S, R.treeContext);
          var qn = y.children, zn = ok(l, qn);
          return zn.flags |= ts, zn;
        }
      }
    }
    function m$(i, l, m) {
      i.lanes = _n(i.lanes, l);
      var y = i.alternate;
      y !== null && (y.lanes = _n(y.lanes, l)), YO(i.return, l, m);
    }
    function Eq(i, l, m) {
      for (var y = l; y !== null; ) {
        if (y.tag === k) {
          var S = y.memoizedState;
          S !== null && m$(y, m, i);
        } else if (y.tag === q)
          m$(y, m, i);
        else if (y.child !== null) {
          y.child.return = y, y = y.child;
        if (y === i)
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === i)
          y = y.return;
        y.sibling.return = y.return, y = y.sibling;
    function Tq(i) {
      for (var l = i, m = null; l !== null; ) {
        var y = l.alternate;
        y !== null && zx(y) === null && (m = l), l = l.sibling;
      return m;
    function _q(i) {
      if (i !== void 0 && i !== "forwards" && i !== "backwards" && i !== "together" && !JR[i])
        if (JR[i] = !0, typeof i == "string")
    function Oq(i, l) {
      i !== void 0 && !aE[i] && (i !== "collapsed" && i !== "hidden" ? (aE[i] = !0, a('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', i)) : l !== "forwards" && l !== "backwards" && (aE[i] = !0, a('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', i)));
    function g$(i, l) {
        var m = Pn(i), y = !m && typeof wn(i) == "function";
        if (m || y) {
          var S = m ? "array" : "iterable";
    function Rq(i, l) {
        if (Pn(i)) {
          for (var m = 0; m < i.length; m++)
            if (!g$(i[m], m))
          var y = wn(i);
          if (typeof y == "function") {
            var S = y.call(i);
                if (!g$(R.value, L))
    function sk(i, l, m, y, S) {
        last: y,
        tail: m,
      } : (R.isBackwards = l, R.rendering = null, R.renderingStartTime = 0, R.last = y, R.tail = m, R.tailMode = S);
    function v$(i, l, m) {
      var y = l.pendingProps, S = y.revealOrder, R = y.tail, L = y.children;
      _q(S), Oq(R, S), Rq(L, S), _s(i, l, L, m);
      var W = Zl.current, Z = oR(W, aw);
        W = iR(W, aw), l.flags |= Xt;
        ae && Eq(l, l.child, m), W = Gg(W);
      if (xf(l, W), (l.mode & Mn) === Jt)
            var le = Tq(l.child), Te;
            le === null ? (Te = l.child, l.child = null) : (Te = le.sibling, le.sibling = null), sk(
            var xe = null, $e = l.child;
            for (l.child = null; $e !== null; ) {
              var ze = $e.alternate;
              if (ze !== null && zx(ze) === null) {
                l.child = $e;
              var Ge = $e.sibling;
              $e.sibling = xe, xe = $e, $e = Ge;
            sk(
            sk(
    function kq(i, l, m) {
      tR(l, l.stateNode.containerInfo);
      var y = l.pendingProps;
      return i === null ? l.child = Hg(l, null, y, m) : _s(i, l, y, m), l.child;
    var y$ = !1;
    function Pq(i, l, m) {
      var y = l.type, S = y._context, R = l.pendingProps, L = l.memoizedProps, W = R.value;
        "value" in R || y$ || (y$ = !0, a("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        Z && Xl(Z, R, "prop", "Context.Provider");
      if (cN(l, S, W), L !== null) {
        if (lt(ae, W)) {
          if (L.children === R.children && !vx())
            return cd(i, l, m);
          _6(l, S, m);
      return _s(i, l, le, m), l.child;
    var b$ = !1;
    function Mq(i, l, m) {
      var y = l.type;
      y._context === void 0 ? y !== y.Consumer && (b$ || (b$ = !0, a("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : y = y._context;
      typeof R != "function" && a("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Ug(l, m);
      var L = Go(y);
      Cs(l);
      var W;
      return gw.current = l, Do(!0), W = R(L), Do(!1), xs(), l.flags |= ba, _s(i, l, W, m), l.child;
    function bw() {
      nu = !0;
    function uE(i, l) {
      (l.mode & Mn) === Jt && i !== null && (i.alternate = null, l.alternate = null, l.flags |= Qr);
    function cd(i, l, m) {
      return i !== null && (l.dependencies = i.dependencies), KN(), Mw(l.lanes), ss(m, l.childLanes) ? (E6(i, l), l.child) : null;
    function Iq(i, l, m) {
        var y = l.return;
        if (y === null)
        if (i.alternate = null, l.alternate = null, m.index = l.index, m.sibling = l.sibling, m.return = l.return, m.ref = l.ref, l === y.child)
          y.child = m;
          var S = y.child;
          S.sibling = m;
        var R = y.deletions;
        return R === null ? (y.deletions = [i], y.flags |= Fs) : R.push(i), m.flags |= Qr, m;
    function ak(i, l) {
      var m = i.lanes;
      return !!ss(m, l);
    function Dq(i, l, m) {
        case v:
          d$(l), l.stateNode, Bg();
          yN(l);
        case h: {
          var y = l.type;
          Xu(y) && bx(l);
          tR(l, l.stateNode.containerInfo);
          cN(l, R, S);
        case A:
            var L = ss(m, l.childLanes);
            L && (l.flags |= Un);
              var W = l.stateNode;
              W.effectDuration = 0, W.passiveEffectDuration = 0;
        case k: {
              return xf(l, Gg(Zl.current)), l.flags |= Xt, null;
            if (ss(m, le))
              return p$(i, l, m);
            xf(l, Gg(Zl.current));
            var Te = cd(i, l, m);
            xf(l, Gg(Zl.current));
          var xe = (i.flags & Xt) !== Qt, $e = ss(m, l.childLanes);
            if ($e)
              return v$(i, l, m);
          if (ze !== null && (ze.rendering = null, ze.tail = null, ze.lastEffect = null), xf(l, Zl.current), $e)
        case K:
          return l.lanes = it, l$(i, l, m);
      return cd(i, l, m);
    function w$(i, l, m) {
        return Iq(i, l, Lk(l.type, l.key, l.pendingProps, l._debugOwner || null, l.mode, l.lanes));
        var y = i.memoizedProps, S = l.pendingProps;
        if (y !== S || vx() || // Force a re-render if the implementation changed due to hot reload:
          nu = !0;
          var R = ak(i, m);
            return nu = !1, Dq(i, l, m);
          (i.flags & zm) !== Qt ? nu = !0 : nu = !1;
      } else if (nu = !1, Fi() && o6(l)) {
        var L = l.index, W = i6();
        KA(l, W, L);
          return hq(i, l, l.type, m);
        case H: {
          return fq(i, l, Z, m);
          var ae = l.type, le = l.pendingProps, Te = l.elementType === ae ? le : tu(ae, le);
          return ZR(i, l, ae, Te, m);
        case h: {
          var xe = l.type, $e = l.pendingProps, ze = l.elementType === xe ? $e : tu(xe, $e);
          return c$(i, l, xe, ze, m);
        case v:
          return uq(i, l, m);
          return cq(i, l, m);
          return dq(i, l);
        case k:
          return p$(i, l, m);
          return kq(i, l, m);
          var Ge = l.type, kt = l.pendingProps, nn = l.elementType === Ge ? kt : tu(Ge, kt);
          return i$(i, l, Ge, nn, m);
          return sq(i, l, m);
          return aq(i, l, m);
        case A:
          return lq(i, l, m);
          return Pq(i, l, m);
        case P:
          return Mq(i, l, m);
        case j: {
          var Yt = l.type, qn = l.pendingProps, zn = tu(Yt, qn);
            Pe && Xl(
              zn,
              Yn(Yt)
          return zn = tu(Yt.type, zn), s$(i, l, Yt, zn, m);
        case B:
          return a$(i, l, l.type, l.pendingProps, m);
        case F: {
          var qe = l.type, Me = l.pendingProps, dt = l.elementType === qe ? Me : tu(qe, Me);
          return pq(i, l, qe, dt, m);
          return v$(i, l, m);
        case U:
        case K:
          return l$(i, l, m);
    function Jg(i) {
      i.flags |= Un;
    function S$(i) {
      i.flags |= oo, i.flags |= tf;
    var C$, lk, x$, E$;
    C$ = function(i, l, m, y) {
          t3(i, S.stateNode);
    }, lk = function(i, l) {
    }, x$ = function(i, l, m, y, S) {
      if (R !== y) {
        var L = l.stateNode, W = nR(), Z = r3(L, m, R, y, S, W);
        l.updateQueue = Z, Z && Jg(l);
    }, E$ = function(i, l, m, y) {
      m !== y && Jg(l);
    function ww(i, l) {
      if (!Fi())
            for (var m = i.tail, y = null; m !== null; )
              m.alternate !== null && (y = m), m = m.sibling;
            y === null ? i.tail = null : y.sibling = null;
    function Bi(i) {
      var l = i.alternate !== null && i.alternate.child === i.child, m = it, y = Qt;
        if ((i.mode & tr) !== Jt) {
            m = _n(m, _n(ae.lanes, ae.childLanes)), y |= ae.subtreeFlags & bo, y |= ae.flags & bo, Z += ae.treeBaseDuration, ae = ae.sibling;
            m = _n(m, _n(le.lanes, le.childLanes)), y |= le.subtreeFlags & bo, y |= le.flags & bo, le.return = i, le = le.sibling;
        i.subtreeFlags |= y;
        if ((i.mode & tr) !== Jt) {
            m = _n(m, _n(L.lanes, L.childLanes)), y |= L.subtreeFlags, y |= L.flags, S += L.actualDuration, R += L.treeBaseDuration, L = L.sibling;
          for (var W = i.child; W !== null; )
            m = _n(m, _n(W.lanes, W.childLanes)), y |= W.subtreeFlags, y |= W.flags, W.return = i, W = W.sibling;
        i.subtreeFlags |= y;
      return i.childLanes = m, l;
    function Aq(i, l, m) {
      if (y6() && (l.mode & Mn) !== Jt && (l.flags & Xt) === Qt)
        return tN(l), Bg(), l.flags |= Si | Ip | Ho, !1;
      var y = Ex(l);
      if (m !== null && m.dehydrated !== null)
          if (!y)
          if (g6(l), Bi(l), (l.mode & tr) !== Jt) {
            var S = m !== null;
          if (Bg(), (l.flags & Xt) === Qt && (l.memoizedState = null), l.flags |= Un, Bi(l), (l.mode & tr) !== Jt) {
            var L = m !== null;
              var W = l.child;
              W !== null && (l.treeBaseDuration -= W.treeBaseDuration);
        return nN(), !0;
    function T$(i, l, m) {
      var y = l.pendingProps;
      switch (AO(l), l.tag) {
        case B:
        case A:
        case P:
        case j:
          return Bi(l), null;
        case h: {
          return Xu(S) && yx(l), Bi(l), null;
        case v: {
          if (Wg(l), PO(l), aR(), R.pendingContext && (R.context = R.pendingContext, R.pendingContext = null), i === null || i.child === null) {
            var L = Ex(l);
              Jg(l);
              var W = i.memoizedState;
              (!W.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (l.flags & Si) !== Qt) && (l.flags |= Ao, nN());
          return lk(i, l), Bi(l), null;
          rR(l);
          var Z = vN(), ae = l.type;
            x$(i, l, ae, y, Z), i.ref !== l.ref && S$(l);
            if (!y) {
              return Bi(l), null;
            var le = nR(), Te = Ex(l);
              h6(l, Z, le) && Jg(l);
              var xe = e3(ae, y, Z, le, l);
              C$(xe, l, !1, !1), l.stateNode = xe, n3(xe, ae, y, Z) && Jg(l);
            l.ref !== null && S$(l);
          return Bi(l), null;
          var $e = y;
            E$(i, l, ze, $e);
            if (typeof $e != "string" && l.stateNode === null)
            var Ge = vN(), kt = nR(), nn = Ex(l);
            nn ? m6(l) && Jg(l) : l.stateNode = o3($e, Ge, kt, l);
          return Bi(l), null;
        case k: {
          qg(l);
            var qn = Aq(i, l, Yt);
            if (!qn)
              return l.flags & Ho ? l : null;
            return l.lanes = m, (l.mode & tr) !== Jt && IR(l), l;
          var zn = Yt !== null, Pe = i !== null && i.memoizedState !== null;
          if (zn !== Pe && zn) {
            if (qe.flags |= yo, (l.mode & Mn) !== Jt) {
              Me || oR(Zl.current, wN) ? N8() : _k();
          if (dt !== null && (l.flags |= Un), Bi(l), (l.mode & tr) !== Jt && zn) {
          return Wg(l), lk(i, l), i === null && Q3(l.stateNode.containerInfo), Bi(l), null;
          return KO(Pt, l), Bi(l), null;
        case F: {
          var mn = l.type;
          return Xu(mn) && yx(l), Bi(l), null;
          qg(l);
          var En = l.memoizedState;
          if (En === null)
            return Bi(l), null;
          var Cr = (l.flags & Xt) !== Qt, or = En.rendering;
          if (or === null)
            if (Cr)
              ww(En, !1);
              var Lo = L8() && (i === null || (i.flags & Xt) === Qt);
                for (var ir = l.child; ir !== null; ) {
                  var To = zx(ir);
                  if (To !== null) {
                    Cr = !0, l.flags |= Xt, ww(En, !1);
                    var ps = To.updateQueue;
                    return ps !== null && (l.updateQueue = ps, l.flags |= Un), l.subtreeFlags = Qt, T6(l, m), xf(l, iR(Zl.current, aw)), l.child;
                  ir = ir.sibling;
              En.tail !== null && No() > G$() && (l.flags |= Xt, Cr = !0, ww(En, !1), l.lanes = fb);
            if (!Cr) {
              var Gi = zx(or);
              if (Gi !== null) {
                l.flags |= Xt, Cr = !0;
                var _a = Gi.updateQueue;
                if (_a !== null && (l.updateQueue = _a, l.flags |= Un), ww(En, !0), En.tail === null && En.tailMode === "hidden" && !or.alternate && !Fi())
                  return Bi(l), null;
              No() * 2 - En.renderingStartTime > G$() && m !== is && (l.flags |= Xt, Cr = !0, ww(En, !1), l.lanes = fb);
            if (En.isBackwards)
              or.sibling = l.child, l.child = or;
              var ks = En.last;
              ks !== null ? ks.sibling = or : l.child = or, En.last = or;
          if (En.tail !== null) {
            var Ps = En.tail;
            En.rendering = Ps, En.tail = Ps.sibling, En.renderingStartTime = No(), Ps.sibling = null;
            var hs = Zl.current;
            return Cr ? hs = iR(hs, aw) : hs = Gg(hs), xf(l, hs), Ps;
          return Bi(l), null;
        case U:
        case K:
          Tk(l);
          var md = l.memoizedState, sv = md !== null;
            var $w = i.memoizedState, oc = $w !== null;
            oc !== sv && // LegacyHidden doesn't do any hiding  it only pre-renders.
            !Q && (l.flags |= yo);
          return !sv || (l.mode & Mn) === Jt ? Bi(l) : ss(rc, is) && (Bi(l), l.subtreeFlags & (Qr | Un) && (l.flags |= yo)), null;
        case Y:
    function Nq(i, l, m) {
      switch (AO(l), l.tag) {
        case h: {
          var y = l.type;
          Xu(y) && yx(l);
          return S & Ho ? (l.flags = S & ~Ho | Xt, (l.mode & tr) !== Jt && IR(l), l) : null;
        case v: {
          l.stateNode, Wg(l), PO(l), aR();
          return (R & Ho) !== Qt && (R & Xt) === Qt ? (l.flags = R & ~Ho | Xt, l) : null;
          return rR(l), null;
        case k: {
          qg(l);
            Bg();
          var W = l.flags;
          return W & Ho ? (l.flags = W & ~Ho | Xt, (l.mode & tr) !== Jt && IR(l), l) : null;
          return qg(l), null;
          return Wg(l), null;
          return KO(Z, l), null;
        case K:
          return Tk(l), null;
    function _$(i, l, m) {
      switch (AO(l), l.tag) {
        case h: {
          var y = l.type.childContextTypes;
          y != null && yx(l);
        case v: {
          l.stateNode, Wg(l), PO(l), aR();
          rR(l);
          Wg(l);
        case k:
          qg(l);
          qg(l);
          KO(S, l);
        case K:
          Tk(l);
    var O$ = null;
    O$ = /* @__PURE__ */ new Set();
    var cE = !1, Hi = !1, $q = typeof WeakSet == "function" ? WeakSet : Set, Ut = null, Zg = null, ev = null;
    function Lq(i) {
      Iu(null, function() {
      }), Mp();
    var jq = function(i, l) {
      if (l.props = i.memoizedProps, l.state = i.memoizedState, i.mode & tr)
          tc(), l.componentWillUnmount();
          ec(i);
    function R$(i, l) {
        _f(ai, i);
      } catch (m) {
        Br(i, l, m);
    function uk(i, l, m) {
        jq(i, m);
      } catch (y) {
        Br(i, l, y);
    function Fq(i, l, m) {
        m.componentDidMount();
      } catch (y) {
        Br(i, l, y);
    function k$(i, l) {
        M$(i);
      } catch (m) {
        Br(i, l, m);
    function tv(i, l) {
      var m = i.ref;
      if (m !== null)
        if (typeof m == "function") {
          var y;
            if (ue && he && i.mode & tr)
                tc(), y = m(null);
                ec(i);
              y = m(null);
            Br(i, l, S);
          typeof y == "function" && a("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", yn(i));
          m.current = null;
    function dE(i, l, m) {
        m();
      } catch (y) {
        Br(i, l, y);
    var P$ = !1;
    function zq(i, l) {
      JG(i.containerInfo), Ut = l, Bq();
      var m = P$;
      return P$ = !1, m;
    function Bq() {
        (i.subtreeFlags & Au) !== Qt && l !== null ? (l.return = i, Ut = l) : Hq();
    function Hq() {
        vr(i);
          Vq(i);
        } catch (m) {
          Br(i, i.return, m);
        zr();
    function Vq(i) {
      var l = i.alternate, m = i.flags;
      if ((m & Ao) !== Qt) {
        switch (vr(i), i.tag) {
          case B:
          case h: {
              var y = l.memoizedProps, S = l.memoizedState, R = i.stateNode;
              i.type === i.elementType && !Eh && (R.props !== i.memoizedProps && a("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", yn(i) || "instance"), R.state !== i.memoizedState && a("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", yn(i) || "instance"));
              var L = R.getSnapshotBeforeUpdate(i.elementType === i.type ? y : tu(i.type, y), S);
                var W = O$;
                L === void 0 && !W.has(i.type) && (W.add(i.type), a("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", yn(i)));
          case v: {
              x3(Z.containerInfo);
          case F:
        zr();
    function ru(i, l, m) {
      var y = l.updateQueue, S = y !== null ? y.lastEffect : null;
            var W = L.destroy;
            L.destroy = void 0, W !== void 0 && ((i & zi) !== Xs ? Ul(l) : (i & ai) !== Xs && Ap(l), (i & Qu) !== Xs && Dw(!0), dE(l, m, W), (i & Qu) !== Xs && Dw(!1), (i & zi) !== Xs ? ju() : (i & ai) !== Xs && cb());
    function _f(i, l) {
      var m = l.updateQueue, y = m !== null ? m.lastEffect : null;
      if (y !== null) {
        var S = y.next, R = S;
            (i & zi) !== Xs ? ub(l) : (i & ai) !== Xs && Gm(l);
            (i & Qu) !== Xs && Dw(!0), R.destroy = L(), (i & Qu) !== Xs && Dw(!1), (i & zi) !== Xs ? g0() : (i & ai) !== Xs && v0();
              var W = R.destroy;
              if (W !== void 0 && typeof W != "function") {
                (R.tag & ai) !== Qt ? Z = "useLayoutEffect" : (R.tag & Qu) !== Qt ? Z = "useInsertionEffect" : Z = "useEffect";
                W === null ? ae = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof W.then == "function" ? ae = `
Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : ae = " You returned: " + W, a("%s must not return anything besides a function, which is used for clean-up.%s", Z, ae);
    function Uq(i, l) {
      if ((l.flags & Un) !== Qt)
          case A: {
            var m = l.stateNode.passiveEffectDuration, y = l.memoizedProps, S = y.id, R = y.onPostCommit, L = GN(), W = l.alternate === null ? "mount" : "update";
            WN() && (W = "nested-update"), typeof R == "function" && R(S, W, m, L);
                case v:
                  ae.passiveEffectDuration += m;
                case A:
                  le.passiveEffectDuration += m;
    function Wq(i, l, m, y) {
      if ((m.flags & $u) !== Qt)
        switch (m.tag) {
          case B: {
            if (!Hi)
              if (m.mode & tr)
                  tc(), _f(ai | si, m);
                  ec(m);
                _f(ai | si, m);
          case h: {
            var S = m.stateNode;
            if (m.flags & Un && !Hi)
                if (m.type === m.elementType && !Eh && (S.props !== m.memoizedProps && a("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", yn(m) || "instance"), S.state !== m.memoizedState && a("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", yn(m) || "instance")), m.mode & tr)
                    tc(), S.componentDidMount();
                    ec(m);
                var R = m.elementType === m.type ? l.memoizedProps : tu(m.type, l.memoizedProps), L = l.memoizedState;
                if (m.type === m.elementType && !Eh && (S.props !== m.memoizedProps && a("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", yn(m) || "instance"), S.state !== m.memoizedState && a("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", yn(m) || "instance")), m.mode & tr)
                    tc(), S.componentDidUpdate(R, L, S.__reactInternalSnapshotBeforeUpdate);
                    ec(m);
            var W = m.updateQueue;
            W !== null && (m.type === m.elementType && !Eh && (S.props !== m.memoizedProps && a("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", yn(m) || "instance"), S.state !== m.memoizedState && a("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", yn(m) || "instance")), gN(m, W, S));
          case v: {
            var Z = m.updateQueue;
              if (m.child !== null)
                switch (m.child.tag) {
                    ae = m.child.stateNode;
                  case h:
                    ae = m.child.stateNode;
              gN(m, Z, ae);
            var le = m.stateNode;
            if (l === null && m.flags & Un) {
              var Te = m.type, xe = m.memoizedProps;
              u3(le, Te, xe);
          case A: {
              var $e = m.memoizedProps, ze = $e.onCommit, Ge = $e.onRender, kt = m.stateNode.effectDuration, nn = GN(), Yt = l === null ? "mount" : "update";
              WN() && (Yt = "nested-update"), typeof Ge == "function" && Ge(m.memoizedProps.id, Yt, m.actualDuration, m.treeBaseDuration, m.actualStartTime, nn);
                typeof ze == "function" && ze(m.memoizedProps.id, Yt, kt, nn), H8(m);
                var qn = m.return;
                e: for (; qn !== null; ) {
                  switch (qn.tag) {
                    case v:
                      var zn = qn.stateNode;
                      zn.effectDuration += kt;
                    case A:
                      var Pe = qn.stateNode;
                  qn = qn.return;
          case k: {
            Zq(i, m);
          case F:
          case U:
          case ee:
          case Y:
      Hi || m.flags & oo && M$(m);
    function Gq(i) {
        case B: {
          if (i.mode & tr)
              tc(), R$(i, i.return);
              ec(i);
            R$(i, i.return);
        case h: {
          typeof l.componentDidMount == "function" && Fq(i, i.return, l), k$(i, i.return);
          k$(i, i.return);
    function qq(i, l) {
      for (var m = null, y = i; ; ) {
        if (y.tag === C) {
          if (m === null) {
            m = y;
              var S = y.stateNode;
              l ? b3(S) : S3(y.stateNode, y.memoizedProps);
              Br(i, i.return, L);
        } else if (y.tag === T) {
          if (m === null)
              var R = y.stateNode;
              l ? w3(R) : C3(R, y.memoizedProps);
              Br(i, i.return, L);
        } else if (!((y.tag === K || y.tag === ee) && y.memoizedState !== null && y !== i)) {
          if (y.child !== null) {
            y.child.return = y, y = y.child;
        if (y === i)
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === i)
          m === y && (m = null), y = y.return;
        m === y && (m = null), y.sibling.return = y.return, y = y.sibling;
    function M$(i) {
        var m = i.stateNode, y;
            y = m;
            y = m;
          if (i.mode & tr)
              tc(), S = l(y);
              ec(i);
            S = l(y);
          typeof S == "function" && a("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", yn(i));
          l.hasOwnProperty("current") || a("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", yn(i)), l.current = y;
    function Kq(i) {
    function I$(i) {
      l !== null && (i.alternate = null, I$(l));
          var m = i.stateNode;
          m !== null && e6(m);
    function Yq(i) {
        if (D$(l))
    function D$(i) {
      return i.tag === C || i.tag === v || i.tag === w;
    function A$(i) {
          if (l.return === null || D$(l.return))
        for (l.sibling.return = l.return, l = l.sibling; l.tag !== C && l.tag !== T && l.tag !== D; ) {
          if (l.flags & Qr || l.child === null || l.tag === w)
        if (!(l.flags & Qr))
    function Xq(i) {
      var l = Yq(i);
          var m = l.stateNode;
          l.flags & zs && ($A(m), l.flags &= ~zs);
          var y = A$(i);
          dk(i, y, m);
        case v:
          var S = l.stateNode.containerInfo, R = A$(i);
          ck(i, R, S);
    function ck(i, l, m) {
      var y = i.tag, S = y === C || y === T;
        l ? m3(m, R, l) : p3(m, R);
      } else if (y !== w) {
          ck(L, l, m);
          for (var W = L.sibling; W !== null; )
            ck(W, l, m), W = W.sibling;
    function dk(i, l, m) {
      var y = i.tag, S = y === C || y === T;
        l ? h3(m, R, l) : f3(m, R);
      } else if (y !== w) {
          dk(L, l, m);
          for (var W = L.sibling; W !== null; )
            dk(W, l, m), W = W.sibling;
    var Vi = null, ou = !1;
    function Qq(i, l, m) {
        var y = l;
        e: for (; y !== null; ) {
          switch (y.tag) {
              Vi = y.stateNode, ou = !1;
            case v: {
              Vi = y.stateNode.containerInfo, ou = !0;
              Vi = y.stateNode.containerInfo, ou = !0;
          y = y.return;
        if (Vi === null)
        N$(i, l, m), Vi = null, ou = !1;
      Kq(m);
    function Of(i, l, m) {
      for (var y = m.child; y !== null; )
        N$(i, l, y), y = y.sibling;
    function N$(i, l, m) {
      switch (sb(m), m.tag) {
          Hi || tv(m, l);
            var y = Vi, S = ou;
            Vi = null, Of(i, l, m), Vi = y, ou = S, Vi !== null && (ou ? v3(Vi, m.stateNode) : g3(Vi, m.stateNode));
        case D: {
          Vi !== null && (ou ? y3(Vi, m.stateNode) : CO(Vi, m.stateNode));
            var R = Vi, L = ou;
            Vi = m.stateNode.containerInfo, ou = !0, Of(i, l, m), Vi = R, ou = L;
        case j:
        case B: {
          if (!Hi) {
            var W = m.updateQueue;
            if (W !== null) {
              var Z = W.lastEffect;
                  var Te = le, xe = Te.destroy, $e = Te.tag;
                  xe !== void 0 && (($e & Qu) !== Xs ? dE(m, l, xe) : ($e & ai) !== Xs && (Ap(m), m.mode & tr ? (tc(), dE(m, l, xe), ec(m)) : dE(m, l, xe), cb())), le = le.next;
          Of(i, l, m);
        case h: {
          if (!Hi) {
            tv(m, l);
            var ze = m.stateNode;
            typeof ze.componentWillUnmount == "function" && uk(m, l, ze);
          Of(i, l, m);
        case U: {
          Of(i, l, m);
        case K: {
            m.mode & Mn
            var Ge = Hi;
            Hi = Ge || m.memoizedState !== null, Of(i, l, m), Hi = Ge;
            Of(i, l, m);
          Of(i, l, m);
    function Jq(i) {
    function Zq(i, l) {
      var m = l.memoizedState;
      if (m === null) {
        var y = l.alternate;
        if (y !== null) {
          var S = y.memoizedState;
            R !== null && L3(R);
    function $$(i) {
        var m = i.stateNode;
        m === null && (m = i.stateNode = new $q()), l.forEach(function(y) {
          var S = Y8.bind(null, i, y);
          if (!m.has(y)) {
            if (m.add(y), os)
              if (Zg !== null && ev !== null)
                Iw(ev, Zg);
            y.then(S, S);
    function e8(i, l, m) {
      Zg = m, ev = i, vr(l), L$(l, i), vr(l), Zg = null, ev = null;
    function iu(i, l, m) {
      var y = l.deletions;
      if (y !== null)
        for (var S = 0; S < y.length; S++) {
          var R = y[S];
            Qq(i, l, R);
            Br(R, l, Z);
      var L = Tu();
      if (l.subtreeFlags & Nu)
        for (var W = l.child; W !== null; )
          vr(W), L$(W, i), W = W.sibling;
      vr(L);
    function L$(i, l, m) {
      var y = i.alternate, S = i.flags;
        case j:
        case B: {
          if (iu(l, i), nc(i), S & Un) {
              ru(Qu | si, i, i.return), _f(Qu | si, i);
            } catch (mn) {
              Br(i, i.return, mn);
            if (i.mode & tr) {
                tc(), ru(ai | si, i, i.return);
              } catch (mn) {
                Br(i, i.return, mn);
              ec(i);
                ru(ai | si, i, i.return);
              } catch (mn) {
                Br(i, i.return, mn);
        case h: {
          iu(l, i), nc(i), S & oo && y !== null && tv(y, y.return);
          iu(l, i), nc(i), S & oo && y !== null && tv(y, y.return);
            if (i.flags & zs) {
                $A(R);
              } catch (mn) {
                Br(i, i.return, mn);
            if (S & Un) {
                var W = i.memoizedProps, Z = y !== null ? y.memoizedProps : W, ae = i.type, le = i.updateQueue;
                    c3(L, le, ae, Z, W, i);
                  } catch (mn) {
                    Br(i, i.return, mn);
          if (iu(l, i), nc(i), S & Un) {
            var Te = i.stateNode, xe = i.memoizedProps, $e = y !== null ? y.memoizedProps : xe;
              d3(Te, $e, xe);
            } catch (mn) {
              Br(i, i.return, mn);
        case v: {
          if (iu(l, i), nc(i), S & Un && y !== null) {
            var ze = y.memoizedState;
                $3(l.containerInfo);
              } catch (mn) {
                Br(i, i.return, mn);
          iu(l, i), nc(i);
        case k: {
          iu(l, i), nc(i);
          if (Ge.flags & yo) {
              var qn = Ge.alternate !== null && Ge.alternate.memoizedState !== null;
              qn || A8();
          if (S & Un) {
              Jq(i);
            } catch (mn) {
              Br(i, i.return, mn);
            $$(i);
        case K: {
          var zn = y !== null && y.memoizedState !== null;
            i.mode & Mn
            var Pe = Hi;
            Hi = Pe || zn, iu(l, i), Hi = Pe;
            iu(l, i);
          if (nc(i), S & yo) {
            if (qe.isHidden = dt, dt && !zn && (Dt.mode & Mn) !== Jt) {
                Ut = Pt, n8(Pt), Pt = Pt.sibling;
            qq(Dt, dt);
          iu(l, i), nc(i), S & Un && $$(i);
        case U:
          iu(l, i), nc(i);
    function nc(i) {
      if (l & Qr) {
          Xq(i);
        } catch (m) {
          Br(i, i.return, m);
        i.flags &= ~Qr;
      l & ts && (i.flags &= ~ts);
    function t8(i, l, m) {
      Zg = m, ev = l, Ut = i, j$(i, l, m), Zg = null, ev = null;
    function j$(i, l, m) {
      for (var y = (i.mode & Mn) !== Jt; Ut !== null; ) {
        if (S.tag === K && y) {
          var L = S.memoizedState !== null, W = L || cE;
          if (W) {
            fk(i, l, m);
            var Z = S.alternate, ae = Z !== null && Z.memoizedState !== null, le = ae || Hi, Te = cE, xe = Hi;
            cE = W, Hi = le, Hi && !xe && (Ut = S, r8(S));
            for (var $e = R; $e !== null; )
              Ut = $e, j$(
                $e,
                m
              ), $e = $e.sibling;
            Ut = S, cE = Te, Hi = xe, fk(i, l, m);
        (S.subtreeFlags & $u) !== Qt && R !== null ? (R.return = S, Ut = R) : fk(i, l, m);
    function fk(i, l, m) {
        var y = Ut;
        if ((y.flags & $u) !== Qt) {
          var S = y.alternate;
          vr(y);
            Wq(l, S, y, m);
            Br(y, y.return, L);
          zr();
        if (y === i) {
        var R = y.sibling;
          R.return = y.return, Ut = R;
        Ut = y.return;
    function n8(i) {
        var l = Ut, m = l.child;
          case j:
          case B: {
            if (l.mode & tr)
                tc(), ru(ai, l, l.return);
                ec(l);
              ru(ai, l, l.return);
          case h: {
            tv(l, l.return);
            var y = l.stateNode;
            typeof y.componentWillUnmount == "function" && uk(l, l.return, y);
            tv(l, l.return);
          case K: {
              F$(i);
        m !== null ? (m.return = l, Ut = m) : F$(i);
    function F$(i) {
        var m = l.sibling;
        if (m !== null) {
          m.return = l.return, Ut = m;
    function r8(i) {
        var l = Ut, m = l.child;
        if (l.tag === K) {
          var y = l.memoizedState !== null;
          if (y) {
            z$(i);
        m !== null ? (m.return = l, Ut = m) : z$(i);
    function z$(i) {
        vr(l);
          Gq(l);
        } catch (y) {
          Br(l, l.return, y);
        if (zr(), l === i) {
        var m = l.sibling;
        if (m !== null) {
          m.return = l.return, Ut = m;
    function o8(i, l, m, y) {
      Ut = l, i8(l, i, m, y);
    function i8(i, l, m, y) {
        (S.subtreeFlags & Hl) !== Qt && R !== null ? (R.return = S, Ut = R) : s8(i, l, m, y);
    function s8(i, l, m, y) {
        if ((S.flags & es) !== Qt) {
          vr(S);
            a8(l, S, m, y);
            Br(S, S.return, L);
          zr();
    function a8(i, l, m, y) {
        case B: {
          if (l.mode & tr) {
            MR();
              _f(zi | si, l);
              PR(l);
            _f(zi | si, l);
    function l8(i) {
      Ut = i, u8();
    function u8() {
        if ((Ut.flags & Fs) !== Qt) {
          var m = i.deletions;
          if (m !== null) {
            for (var y = 0; y < m.length; y++) {
              var S = m[y];
              Ut = S, f8(S, i);
                    var W = L.sibling;
                    L.sibling = null, L = W;
        (i.subtreeFlags & Hl) !== Qt && l !== null ? (l.return = i, Ut = l) : c8();
    function c8() {
        (i.flags & es) !== Qt && (vr(i), d8(i), zr());
    function d8(i) {
        case B: {
          i.mode & tr ? (MR(), ru(zi | si, i, i.return), PR(i)) : ru(zi | si, i, i.return);
    function f8(i, l) {
        var m = Ut;
        vr(m), h8(m, l), zr();
        var y = m.child;
        y !== null ? (y.return = m, Ut = y) : p8(i);
    function p8(i) {
        var l = Ut, m = l.sibling, y = l.return;
        if (I$(l), l === i) {
        if (m !== null) {
          m.return = y, Ut = m;
        Ut = y;
    function h8(i, l) {
        case B: {
          i.mode & tr ? (MR(), ru(zi, i, l), PR(i)) : ru(zi, i, l);
    function m8(i) {
        case B: {
            _f(ai | si, i);
          } catch (m) {
            Br(i, i.return, m);
        case h: {
          } catch (m) {
            Br(i, i.return, m);
    function g8(i) {
        case B: {
            _f(zi | si, i);
            Br(i, i.return, l);
    function v8(i) {
        case B: {
            ru(ai | si, i, i.return);
          } catch (m) {
            Br(i, i.return, m);
        case h: {
          typeof l.componentWillUnmount == "function" && uk(i, i.return, l);
    function y8(i) {
        case B:
            ru(zi | si, i, i.return);
            Br(i, i.return, l);
      var Sw = Symbol.for;
      Sw("selector.component"), Sw("selector.has_pseudo_class"), Sw("selector.role"), Sw("selector.test_id"), Sw("selector.text");
    var b8 = [];
    function w8() {
      b8.forEach(function(i) {
    var S8 = n.ReactCurrentActQueue;
    function C8(i) {
        ), m = typeof jest < "u";
        return m && l !== !1;
    function B$() {
        return !i && S8.current !== null && a("The current testing environment is not configured to support act(...)"), i;
    var x8 = Math.ceil, pk = n.ReactCurrentDispatcher, hk = n.ReactCurrentOwner, Ui = n.ReactCurrentBatchConfig, su = n.ReactCurrentActQueue, ci = (
    ), H$ = (
    ), Wi = (
    ), cl = (
    ), dd = 0, Cw = 1, Th = 2, fE = 3, xw = 4, V$ = 5, mk = 6, Gn = ci, Os = null, po = null, di = it, rc = it, gk = vf(it), fi = dd, Ew = null, pE = it, Tw = it, hE = it, _w = null, Qs = null, vk = 0, U$ = 500, W$ = 1 / 0, E8 = 500, fd = null;
    function Ow() {
      W$ = No() + E8;
    function G$() {
      return W$;
    var mE = !1, yk = null, nv = null, _h = !1, Rf = null, Rw = it, bk = [], wk = null, T8 = 50, kw = 0, Sk = null, Ck = !1, gE = !1, _8 = 50, rv = 0, vE = null, Pw = Pr, yE = it, q$ = !1;
    function bE() {
      return Os;
    function Rs() {
      return (Gn & (Wi | cl)) !== ci ? No() : (Pw !== Pr || (Pw = No()), Pw);
    function kf(i) {
      if ((l & Mn) === Jt)
        return cn;
      if ((Gn & Wi) !== ci && di !== it)
        return qp(di);
      var m = S6() !== w6;
      if (m) {
        if (Ui.transition !== null) {
          var y = Ui.transition;
          y._updatedFibers || (y._updatedFibers = /* @__PURE__ */ new Set()), y._updatedFibers.add(i);
        return yE === Jn && (yE = yb()), yE;
      var S = Gs();
      if (S !== Jn)
      var R = i3();
    function O8(i) {
      return (l & Mn) === Jt ? cn : x0();
    function pi(i, l, m, y) {
      Q8(), q$ && a("useInsertionEffect must not schedule updates."), Ck && (gE = !0), sf(i, m, y), (Gn & Wi) !== it && i === Os ? e9(l) : (os && Xp(i, l, m), t9(l), i === Os && ((Gn & Wi) === ci && (Tw = _n(Tw, m)), fi === xw && Pf(i, di)), Js(i, y), m === cn && Gn === ci && (l.mode & Mn) === Jt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !su.isBatchingLegacy && (Ow(), qA()));
    function R8(i, l, m) {
      var y = i.current;
      y.lanes = l, sf(i, l, m), Js(i, m);
    function k8(i) {
        (Gn & Wi) !== ci
    function Js(i, l) {
      var m = i.callbackNode;
      fg(i, l);
      var y = dg(i, i === Os ? di : it);
      if (y === it) {
        m !== null && uL(m), i.callbackNode = null, i.callbackPriority = Jn;
      var S = Bu(y), R = i.callbackPriority;
      !(su.current !== null && m !== kk)) {
        m == null && R !== cn && a("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
      m != null && uL(m);
      if (S === cn)
        i.tag === yf ? (su.isBatchingLegacy !== null && (su.didScheduleLegacyUpdate = !0), r6(X$.bind(null, i))) : GA(X$.bind(null, i)), su.current !== null ? su.current.push(bf) : a3(function() {
          (Gn & (Wi | cl)) === ci && bf();
        var W;
        switch (P0(y)) {
          case Ai:
            W = Dp;
          case el:
            W = Lu;
            W = Vl;
            break;
          case Ws:
            W = Fc;
            W = Vl;
        L = Pk(W, K$.bind(null, i));
    function K$(i, l) {
      if (q6(), Pw = Pr, yE = it, (Gn & (Wi | cl)) !== ci)
      var m = i.callbackNode, y = hd();
      if (y && i.callbackNode !== m)
      var S = dg(i, i === Os ? di : it);
      var R = !hg(i, S) && !C0(i, S) && !l, L = R ? F8(i, S) : SE(i, S);
      if (L !== dd) {
        if (L === Th) {
          var W = pg(i);
          W !== it && (S = W, L = xk(i, W));
        }
        if (L === Cw) {
          var Z = Ew;
          throw Oh(i, it), Pf(i, S), Js(i, No()), Z;
        }
        if (L === mk)
          Pf(i, S);
          var ae = !hg(i, S), le = i.current.alternate;
          if (ae && !M8(le)) {
            if (L = SE(i, S), L === Th) {
              var Te = pg(i);
              Te !== it && (S = Te, L = xk(i, Te));
            if (L === Cw) {
              var xe = Ew;
              throw Oh(i, it), Pf(i, S), Js(i, No()), xe;
          i.finishedWork = le, i.finishedLanes = S, P8(i, L, S);
      return Js(i, No()), i.callbackNode === m ? K$.bind(null, i) : null;
    function xk(i, l) {
      var m = _w;
      if (vg(i)) {
        var y = Oh(i, l);
        y.flags |= Si, X3(i.containerInfo);
      var S = SE(i, l);
      if (S !== Th) {
        var R = Qs;
        Qs = m, R !== null && Y$(R);
    function Y$(i) {
      Qs === null ? Qs = i : Qs.push.apply(Qs, i);
    function P8(i, l, m) {
        case dd:
        case Cw:
        case Th: {
          Rh(i, Qs, fd);
        case fE: {
          if (Pf(i, m), Xc(m) && // do not delay if we're inside an act() scope
          !cL()) {
            var y = vk + U$ - No();
            if (y > 10) {
              var S = dg(i, it);
              if (!Qc(R, m)) {
                Rs(), mg(i, R);
              i.timeoutHandle = wO(Rh.bind(null, i, Qs, fd), y);
          Rh(i, Qs, fd);
        case xw: {
          if (Pf(i, m), gb(m))
          if (!cL()) {
            var L = Sa(i, m), W = L, Z = No() - W, ae = X8(Z) - Z;
              i.timeoutHandle = wO(Rh.bind(null, i, Qs, fd), ae);
          Rh(i, Qs, fd);
        case V$: {
          Rh(i, Qs, fd);
    function M8(i) {
        if (l.flags & ef) {
          var m = l.updateQueue;
          if (m !== null) {
            var y = m.stores;
            if (y !== null)
              for (var S = 0; S < y.length; S++) {
                var R = y[S], L = R.getSnapshot, W = R.value;
                  if (!lt(L(), W))
        if (l.subtreeFlags & ef && Z !== null) {
    function Pf(i, l) {
      l = Kp(l, hE), l = Kp(l, Tw), _0(i, l);
    function X$(i) {
      if (K6(), (Gn & (Wi | cl)) !== ci)
      hd();
      var l = dg(i, it);
      if (!ss(l, cn))
        return Js(i, No()), null;
      var m = SE(i, l);
      if (i.tag !== yf && m === Th) {
        var y = pg(i);
        y !== it && (l = y, m = xk(i, y));
      }
      if (m === Cw) {
        var S = Ew;
        throw Oh(i, it), Pf(i, l), Js(i, No()), S;
      }
      if (m === mk)
      return i.finishedWork = R, i.finishedLanes = l, Rh(i, Qs, fd), Js(i, No()), null;
    function I8(i, l) {
      l !== it && (gg(i, _n(l, cn)), Js(i, No()), (Gn & (Wi | cl)) === ci && (Ow(), bf()));
    function Ek(i, l) {
      var m = Gn;
      Gn |= H$;
        Gn = m, Gn === ci && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !su.isBatchingLegacy && (Ow(), qA());
    function D8(i, l, m, y, S) {
      var R = Gs(), L = Ui.transition;
        return Ui.transition = null, Co(Ai), i(l, m, y, S);
        Co(R), Ui.transition = L, Gn === ci && Ow();
    function pd(i) {
      Rf !== null && Rf.tag === yf && (Gn & (Wi | cl)) === ci && hd();
      var l = Gn;
      Gn |= H$;
      var m = Ui.transition, y = Gs();
        return Ui.transition = null, Co(Ai), i ? i() : void 0;
        Co(y), Ui.transition = m, Gn = l, (Gn & (Wi | cl)) === ci && bf();
    function Q$() {
      return (Gn & (Wi | cl)) !== ci;
    function wE(i, l) {
      ds(gk, rc, i), rc = _n(rc, l);
    function Tk(i) {
      rc = gk.current, cs(gk, i);
    function Oh(i, l) {
      var m = i.timeoutHandle;
      if (m !== SO && (i.timeoutHandle = SO, s3(m)), po !== null)
        for (var y = po.return; y !== null; ) {
          var S = y.alternate;
          _$(S, y), y = y.return;
      Os = i;
      var R = kh(i.current, null);
      return po = R, di = rc = l, fi = dd, Ew = null, pE = it, Tw = it, hE = it, _w = null, Qs = null, R6(), Jl.discardPendingWarnings(), R;
    function J$(i, l) {
        var m = po;
          if (Px(), CN(), zr(), hk.current = null, m === null || m.return === null) {
            fi = Cw, Ew = l, po = null;
          if (ue && m.mode & tr && iE(m, !0), de)
            if (xs(), l !== null && typeof l == "object" && typeof l.then == "function") {
              var y = l;
              Za(m, y, di);
              Np(m, l, di);
          rq(i, m.return, m, l, di), nL(m);
          l = S, po === m && m !== null ? (m = m.return, po = m) : m = po;
    function Z$() {
      var i = pk.current;
      return pk.current = eE, i === null ? eE : i;
    function eL(i) {
      pk.current = i;
    function A8() {
      vk = No();
    function Mw(i) {
      pE = _n(i, pE);
    function N8() {
      fi === dd && (fi = fE);
    function _k() {
      (fi === dd || fi === fE || fi === Th) && (fi = xw), Os !== null && (Gp(pE) || Gp(Tw)) && Pf(Os, di);
    function $8(i) {
      fi !== xw && (fi = Th), _w === null ? _w = [i] : _w.push(i);
    function L8() {
      return fi === dd;
    }
    function SE(i, l) {
      var m = Gn;
      Gn |= Wi;
      var y = Z$();
      if (Os !== i || di !== l) {
        if (os) {
          S.size > 0 && (Iw(i, di), S.clear()), O0(i, l);
        fd = Cb(), Oh(i, l);
      Vc(l);
          j8();
          J$(i, R);
      if (Px(), Gn = m, eL(y), po !== null)
      return qm(), Os = null, di = it, fi;
    }
    function j8() {
      for (; po !== null; )
        tL(po);
    }
    function F8(i, l) {
      var m = Gn;
      Gn |= Wi;
      var y = Z$();
      if (Os !== i || di !== l) {
        if (os) {
          S.size > 0 && (Iw(i, di), S.clear()), O0(i, l);
        fd = Cb(), Ow(), Oh(i, l);
      Vc(l);
          z8();
          J$(i, R);
      return Px(), eL(y), Gn = m, po !== null ? (y0(), dd) : (qm(), Os = null, di = it, fi);
    function z8() {
      for (; po !== null && !tb(); )
        tL(po);
    function tL(i) {
      vr(i);
      var m;
      (i.mode & tr) !== Jt ? (kR(i), m = Ok(l, i, rc), iE(i, !0)) : m = Ok(l, i, rc), zr(), i.memoizedProps = i.pendingProps, m === null ? nL(i) : po = m, hk.current = null;
    function nL(i) {
        var m = l.alternate, y = l.return;
        if ((l.flags & Ip) === Qt) {
          vr(l);
          if ((l.mode & tr) === Jt ? S = T$(m, l, rc) : (kR(l), S = T$(m, l, rc), iE(l, !1)), zr(), S !== null) {
            po = S;
          var R = Nq(m, l);
            R.flags &= f0, po = R;
          if ((l.mode & tr) !== Jt) {
            iE(l, !1);
            for (var L = l.actualDuration, W = l.child; W !== null; )
              L += W.actualDuration, W = W.sibling;
          if (y !== null)
            y.flags |= Ip, y.subtreeFlags = Qt, y.deletions = null;
            fi = mk, po = null;
          po = Z;
        l = y, po = l;
      fi === dd && (fi = V$);
    function Rh(i, l, m) {
      var y = Gs(), S = Ui.transition;
        Ui.transition = null, Co(Ai), B8(i, l, m, y);
        Ui.transition = S, Co(y);
    function B8(i, l, m, y) {
        hd();
      while (Rf !== null);
      if (J8(), (Gn & (Wi | cl)) !== ci)
      if (ab(R), S === null)
        return lb(), null;
      i.callbackNode = null, i.callbackPriority = Jn;
      var L = _n(S.lanes, S.childLanes);
      wb(i, L), i === Os && (Os = null, po = null, di = it), ((S.subtreeFlags & Hl) !== Qt || (S.flags & Hl) !== Qt) && (_h || (_h = !0, wk = m, Pk(Vl, function() {
        return hd(), null;
      var W = (S.subtreeFlags & (Au | Nu | $u | Hl)) !== Qt, Z = (S.flags & (Au | Nu | $u | Hl)) !== Qt;
      if (W || Z) {
        var ae = Ui.transition;
        Ui.transition = null;
        var le = Gs();
        Co(Ai);
        var Te = Gn;
        Gn |= cl, hk.current = null, zq(i, S), qN(), e8(i, S, R), ZG(i.containerInfo), i.current = S, $p(R), t8(S, i, R), Lp(), nb(), Gn = Te, Co(le), Ui.transition = ae;
        i.current = S, qN();
      var xe = _h;
      if (_h ? (_h = !1, Rf = i, Rw = R) : (rv = 0, vE = null), L = i.pendingLanes, L === it && (nv = null), xe || sL(i.current, !1), ob(S.stateNode, y), os && i.memoizedUpdaters.clear(), w8(), Js(i, No()), l !== null)
        for (var $e = i.onRecoverableError, ze = 0; ze < l.length; ze++) {
          $e(Ge.value, {
      if (mE) {
        mE = !1;
        var Yt = yk;
        throw yk = null, Yt;
      return ss(Rw, cn) && i.tag !== yf && hd(), L = i.pendingLanes, ss(L, cn) ? (G6(), i === Sk ? kw++ : (kw = 0, Sk = i)) : kw = 0, bf(), lb(), null;
    function hd() {
      if (Rf !== null) {
        var i = P0(Rw), l = Jp(Us, i), m = Ui.transition, y = Gs();
          return Ui.transition = null, Co(l), V8();
          Co(y), Ui.transition = m;
    function H8(i) {
      bk.push(i), _h || (_h = !0, Pk(Vl, function() {
        return hd(), null;
    function V8() {
      if (Rf === null)
      var i = wk;
      wk = null;
      var l = Rf, m = Rw;
      if (Rf = null, Rw = it, (Gn & (Wi | cl)) !== ci)
      Ck = !0, gE = !1, Hc(m);
      var y = Gn;
      Gn |= cl, l8(l.current), o8(l, l.current, m, i);
        var S = bk;
        bk = [];
          Uq(l, L);
      db(), sL(l.current, !0), Gn = y, bf(), gE ? l === vE ? rv++ : (rv = 0, vE = l) : rv = 0, Ck = !1, gE = !1, ib(l);
        var W = l.current.stateNode;
        W.effectDuration = 0, W.passiveEffectDuration = 0;
    function rL(i) {
      return nv !== null && nv.has(i);
    function U8(i) {
      nv === null ? nv = /* @__PURE__ */ new Set([i]) : nv.add(i);
    function W8(i) {
      mE || (mE = !0, yk = i);
    var G8 = W8;
    function oL(i, l, m) {
      var y = xh(m, l), S = t$(i, y, cn), R = Sf(i, S, cn), L = Rs();
      R !== null && (sf(R, cn, L), Js(R, L));
    function Br(i, l, m) {
      if (Lq(m), Dw(!1), i.tag === v) {
        oL(i, i, m);
      var y = null;
      for (y = l; y !== null; ) {
        if (y.tag === v) {
          oL(y, i, m);
        } else if (y.tag === h) {
          var S = y.type, R = y.stateNode;
          if (typeof S.getDerivedStateFromError == "function" || typeof R.componentDidCatch == "function" && !rL(R)) {
            var L = xh(m, i), W = qR(y, L, cn), Z = Sf(y, W, cn), ae = Rs();
            Z !== null && (sf(Z, cn, ae), Js(Z, ae));
        y = y.return;
%s`, m);
    function q8(i, l, m) {
      var y = i.pingCache;
      y !== null && y.delete(l);
      var S = Rs();
      mg(i, m), n9(i), Os === i && Qc(di, m) && (fi === xw || fi === fE && Xc(di) && No() - vk < U$ ? Oh(i, it) : hE = _n(hE, m)), Js(i, S);
    function iL(i, l) {
      l === Jn && (l = O8(i));
      var m = Rs(), y = Ys(i, l);
      y !== null && (sf(y, l, m), Js(y, m));
    function K8(i) {
      var l = i.memoizedState, m = Jn;
      l !== null && (m = l.retryLane), iL(i, m);
    function Y8(i, l) {
      var m = Jn, y;
        case k:
          y = i.stateNode;
          S !== null && (m = S.retryLane);
          y = i.stateNode;
      y !== null && y.delete(l), iL(i, m);
    function X8(i) {
      return i < 120 ? 120 : i < 480 ? 480 : i < 1080 ? 1080 : i < 1920 ? 1920 : i < 3e3 ? 3e3 : i < 4320 ? 4320 : x8(i / 1960) * 1960;
    function Q8() {
      if (kw > T8)
        throw kw = 0, Sk = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      rv > _8 && (rv = 0, vE = null, a("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    function J8() {
      Jl.flushLegacyContextWarning(), Jl.flushPendingUnsafeLifecycleWarnings();
    function sL(i, l) {
      vr(i), CE(i, Du, v8), l && CE(i, Xa, y8), CE(i, Du, m8), l && CE(i, Xa, g8), zr();
    function CE(i, l, m) {
      for (var y = i, S = null; y !== null; ) {
        var R = y.subtreeFlags & l;
        y !== S && y.child !== null && R !== Qt ? y = y.child : ((y.flags & l) !== Qt && m(y), y.sibling !== null ? y = y.sibling : y = S = y.return);
    var xE = null;
    function aL(i) {
        if ((Gn & Wi) !== ci || !(i.mode & Mn))
        if (l !== g && l !== v && l !== h && l !== f && l !== M && l !== j && l !== B)
        var m = yn(i) || "ReactComponent";
        if (xE !== null) {
          if (xE.has(m))
          xE.add(m);
          xE = /* @__PURE__ */ new Set([m]);
        var y = ti;
          vr(i), a("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          y ? vr(i) : zr();
    var Ok;
      var Z8 = null;
      Ok = function(i, l, m) {
        var y = mL(Z8, l);
          return w$(i, l, m);
          if (d6() || R !== null && typeof R == "object" && typeof R.then == "function")
          if (Px(), CN(), _$(i, l), mL(l, y), l.mode & tr && kR(l), Iu(null, w$, null, i, l, m), zl()) {
            var S = Mp();
    var lL = !1, Rk;
    Rk = /* @__PURE__ */ new Set();
    function e9(i) {
      if (Va && !V6())
          case B: {
            var l = po && yn(po) || "Unknown", m = l;
            if (!Rk.has(m)) {
              Rk.add(m);
              var y = yn(i) || "Unknown";
              a("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", y, l, l);
          case h: {
            lL || (a("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), lL = !0);
    function Iw(i, l) {
      if (os) {
        var m = i.memoizedUpdaters;
        m.forEach(function(y) {
          Xp(i, y, l);
    var kk = {};
    function Pk(i, l) {
        var m = su.current;
        return m !== null ? (m.push(l), kk) : eb(i, l);
    function uL(i) {
      if (i !== kk)
        return h0(i);
    function cL() {
      return su.current !== null;
    function t9(i) {
        if (i.mode & Mn) {
          if (!B$())
        } else if (!C8() || Gn !== ci || i.tag !== f && i.tag !== M && i.tag !== B)
        if (su.current === null) {
          var l = ti;
            vr(i), a(`An update to %s inside a test was not wrapped in act(...).
This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, yn(i));
            l ? vr(i) : zr();
    function n9(i) {
      i.tag !== yf && B$() && su.current === null && a(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).
    function Dw(i) {
      q$ = i;
    var dl = null, ov = null, r9 = function(i) {
      dl = i;
    function iv(i) {
        if (dl === null)
        var l = dl(i);
    function Mk(i) {
      return iv(i);
    function Ik(i) {
        if (dl === null)
        var l = dl(i);
            var m = iv(i.render);
            if (i.render !== m) {
              var y = {
                render: m
              return i.displayName !== void 0 && (y.displayName = i.displayName), y;
    function dL(i, l) {
        if (dl === null)
        var m = i.elementType, y = l.type, S = !1, R = typeof y == "object" && y !== null ? y.$$typeof : null;
          case h: {
            typeof y == "function" && (S = !0);
            (typeof y == "function" || R === De) && (S = !0);
          case j:
          case B: {
            (R === hn || R === De) && (S = !0);
          var L = dl(m);
          if (L !== void 0 && L === dl(y))
    function fL(i) {
        if (dl === null || typeof WeakSet != "function")
        ov === null && (ov = /* @__PURE__ */ new WeakSet()), ov.add(i);
    var o9 = function(i, l) {
        if (dl === null)
        var m = l.staleFamilies, y = l.updatedFamilies;
        hd(), pd(function() {
          Dk(i.current, y, m);
    }, i9 = function(i, l) {
        if (i.context !== Ea)
        hd(), pd(function() {
          Aw(l, i, null, null);
    function Dk(i, l, m) {
        var y = i.alternate, S = i.child, R = i.sibling, L = i.tag, W = i.type, Z = null;
          case B:
          case h:
            Z = W;
            Z = W.render;
        if (dl === null)
          var Te = dl(Z);
          Te !== void 0 && (m.has(Te) ? le = !0 : l.has(Te) && (L === h ? le = !0 : ae = !0));
        if (ov !== null && (ov.has(i) || y !== null && ov.has(y)) && (le = !0), le && (i._debugNeedsRemount = !0), le || ae) {
          var xe = Ys(i, cn);
          xe !== null && pi(xe, i, cn, Pr);
        S !== null && !le && Dk(S, l, m), R !== null && Dk(R, l, m);
    var s9 = function(i, l) {
        var m = /* @__PURE__ */ new Set(), y = new Set(l.map(function(S) {
        return Ak(i.current, y, m), m;
    function Ak(i, l, m) {
        var y = i.child, S = i.sibling, R = i.tag, L = i.type, W = null;
          case B:
          case h:
            W = L;
            W = L.render;
        W !== null && l.has(W) && (Z = !0), Z ? a9(i, m) : y !== null && Ak(y, l, m), S !== null && Ak(S, l, m);
    function a9(i, l) {
        var m = l9(i, l);
        if (m)
        for (var y = i; ; ) {
          switch (y.tag) {
              l.add(y.stateNode);
              l.add(y.stateNode.containerInfo);
            case v:
              l.add(y.stateNode.containerInfo);
          if (y.return === null)
          y = y.return;
    function l9(i, l) {
      for (var m = i, y = !1; ; ) {
        if (m.tag === C)
          y = !0, l.add(m.stateNode);
        else if (m.child !== null) {
          m.child.return = m, m = m.child;
        if (m === i)
          return y;
        for (; m.sibling === null; ) {
          if (m.return === null || m.return === i)
            return y;
          m = m.return;
        m.sibling.return = m.return, m = m.sibling;
    var Nk;
      Nk = !1;
        var pL = Object.preventExtensions({});
        Nk = !0;
    function u9(i, l, m, y) {
      this.tag = i, this.key = m, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = l, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = y, this.flags = Qt, this.subtreeFlags = Qt, this.deletions = null, this.lanes = it, this.childLanes = it, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !Nk && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    var Ta = function(i, l, m, y) {
      return new u9(i, l, m, y);
    function $k(i) {
    function c9(i) {
      return typeof i == "function" && !$k(i) && i.defaultProps === void 0;
    function d9(i) {
        return $k(i) ? h : f;
        if (l === hn)
          return j;
    function kh(i, l) {
      var m = i.alternate;
      m === null ? (m = Ta(i.tag, l, i.key, i.mode), m.elementType = i.elementType, m.type = i.type, m.stateNode = i.stateNode, m._debugSource = i._debugSource, m._debugOwner = i._debugOwner, m._debugHookTypes = i._debugHookTypes, m.alternate = i, i.alternate = m) : (m.pendingProps = l, m.type = i.type, m.flags = Qt, m.subtreeFlags = Qt, m.deletions = null, m.actualDuration = 0, m.actualStartTime = -1), m.flags = i.flags & bo, m.childLanes = i.childLanes, m.lanes = i.lanes, m.child = i.child, m.memoizedProps = i.memoizedProps, m.memoizedState = i.memoizedState, m.updateQueue = i.updateQueue;
      var y = i.dependencies;
      switch (m.dependencies = y === null ? null : {
        lanes: y.lanes,
        firstContext: y.firstContext
      }, m.sibling = i.sibling, m.index = i.index, m.ref = i.ref, m.selfBaseDuration = i.selfBaseDuration, m.treeBaseDuration = i.treeBaseDuration, m._debugNeedsRemount = i._debugNeedsRemount, m.tag) {
        case B:
          m.type = iv(i.type);
        case h:
          m.type = Mk(i.type);
          m.type = Ik(i.type);
      return m;
    function f9(i, l) {
      i.flags &= bo | Qr;
      var m = i.alternate;
      if (m === null)
        i.childLanes = m.childLanes, i.lanes = m.lanes, i.child = m.child, i.subtreeFlags = Qt, i.deletions = null, i.memoizedProps = m.memoizedProps, i.memoizedState = m.memoizedState, i.updateQueue = m.updateQueue, i.type = m.type;
        var y = m.dependencies;
        i.dependencies = y === null ? null : {
          lanes: y.lanes,
          firstContext: y.firstContext
        }, i.selfBaseDuration = m.selfBaseDuration, i.treeBaseDuration = m.treeBaseDuration;
    function p9(i, l, m) {
      var y;
      return i === wx ? (y = Mn, l === !0 && (y |= wr, y |= nr)) : y = Jt, os && (y |= tr), Ta(v, null, null, y);
    function Lk(i, l, m, y, S, R) {
      var L = g, W = i;
        $k(i) ? (L = h, W = Mk(W)) : W = iv(W);
            return Mf(m.children, S, R, l);
          case ki:
            L = O, S |= wr, (S & Mn) !== Jt && (S |= nr);
            break;
          case Xi:
            return h9(m, S, R, l);
            return m9(m, S, R, l);
            return g9(m, S, R, l);
            return hL(m, S, R, l);
                case Qi:
                  L = P;
                  L = M, W = Ik(W);
                case hn:
                  L = j;
                  L = H, W = null;
              var ae = y ? yn(y) : null;
      var le = Ta(L, m, l, S);
      return le.elementType = i, le.type = W, le.lanes = R, le._debugOwner = y, le;
    function jk(i, l, m) {
      var y = null;
      y = i._owner;
      var S = i.type, R = i.key, L = i.props, W = Lk(S, R, L, y, l, m);
      return W._debugSource = i._source, W._debugOwner = i._owner, W;
    function Mf(i, l, m, y) {
      var S = Ta(E, i, y, l);
      return S.lanes = m, S;
    function h9(i, l, m, y) {
      var S = Ta(A, i, y, l | tr);
      return S.elementType = Xi, S.lanes = m, S.stateNode = {
    function m9(i, l, m, y) {
      var S = Ta(k, i, y, l);
      return S.elementType = ft, S.lanes = m, S;
    function g9(i, l, m, y) {
      var S = Ta(q, i, y, l);
      return S.elementType = Ct, S.lanes = m, S;
    function hL(i, l, m, y) {
      var S = Ta(K, i, y, l);
      S.elementType = Bt, S.lanes = m;
    function Fk(i, l, m) {
      var y = Ta(T, i, null, l);
      return y.lanes = m, y;
    function v9() {
      var i = Ta(C, null, null, Jt);
    function y9(i) {
      var l = Ta(D, null, null, Jt);
    function zk(i, l, m) {
      var y = i.children !== null ? i.children : [], S = Ta(w, y, i.key, l);
      return S.lanes = m, S.stateNode = {
    function mL(i, l) {
      return i === null && (i = Ta(g, null, null, Jt)), i.tag = l.tag, i.key = l.key, i.elementType = l.elementType, i.type = l.type, i.stateNode = l.stateNode, i.return = l.return, i.child = l.child, i.sibling = l.sibling, i.index = l.index, i.ref = l.ref, i.pendingProps = l.pendingProps, i.memoizedProps = l.memoizedProps, i.updateQueue = l.updateQueue, i.memoizedState = l.memoizedState, i.dependencies = l.dependencies, i.mode = l.mode, i.flags = l.flags, i.subtreeFlags = l.subtreeFlags, i.deletions = l.deletions, i.lanes = l.lanes, i.childLanes = l.childLanes, i.alternate = l.alternate, i.actualDuration = l.actualDuration, i.actualStartTime = l.actualStartTime, i.selfBaseDuration = l.selfBaseDuration, i.treeBaseDuration = l.treeBaseDuration, i._debugSource = l._debugSource, i._debugOwner = l._debugOwner, i._debugNeedsRemount = l._debugNeedsRemount, i._debugHookTypes = l._debugHookTypes, i;
    function b9(i, l, m, y, S) {
      this.tag = l, this.containerInfo = i, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = SO, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Jn, this.eventTimes = Yp(it), this.expirationTimes = Yp(Pr), this.pendingLanes = it, this.suspendedLanes = it, this.pingedLanes = it, this.expiredLanes = it, this.mutableReadLanes = it, this.finishedLanes = it, this.entangledLanes = it, this.entanglements = Yp(it), this.identifierPrefix = y, this.onRecoverableError = S, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
        for (var R = this.pendingUpdatersLaneMap = [], L = 0; L < Uc; L++)
        case wx:
          this._debugRootType = m ? "hydrateRoot()" : "createRoot()";
        case yf:
          this._debugRootType = m ? "hydrate()" : "render()";
    function gL(i, l, m, y, S, R, L, W, Z, ae) {
      var le = new b9(i, l, m, W, Z), Te = p9(l, R);
          element: y,
          isDehydrated: m,
      return ZO(Te), le;
    var Bk = "18.3.1";
    function w9(i, l, m) {
      var y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Le(y), {
        $$typeof: Yr,
        key: y == null ? null : "" + y,
        implementation: m
    var Hk, Vk;
    Hk = !1, Vk = {};
    function vL(i) {
        return Ea;
      var l = Zd(i), m = n6(l);
      if (l.tag === h) {
        var y = l.type;
        if (Xu(y))
          return UA(l, y, m);
      return m;
    function S9(i, l) {
        var m = Zd(i);
        if (m === void 0) {
          var y = Object.keys(i).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + y);
        var S = ns(m);
        if (S.mode & wr) {
          var R = yn(m) || "Component";
          if (!Vk[R]) {
            Vk[R] = !0;
            var L = ti;
              vr(S), m.mode & wr ? a("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", l, l, R) : a("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", l, l, R);
              L ? vr(L) : zr();
    function yL(i, l, m, y, S, R, L, W) {
      return gL(i, l, Z, ae, m, y, S, R, L);
    }
    function bL(i, l, m, y, S, R, L, W, Z, ae) {
      var le = !0, Te = gL(m, y, le, i, S, R, L, W, Z);
      Te.context = vL(null);
      var xe = Te.current, $e = Rs(), ze = kf(xe), Ge = ud($e, ze);
      return Ge.callback = l ?? null, Sf(xe, Ge, ze), R8(Te, ze, $e), Te;
    }
    function Aw(i, l, m, y) {
      rb(l, i);
      var S = l.current, R = Rs(), L = kf(S);
      Zr(L);
      var W = vL(m);
      l.context === null ? l.context = W : l.pendingContext = W, Va && ti !== null && !Hk && (Hk = !0, a(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.
Check the render method of %s.`, yn(ti) || "Unknown"));
      var Z = ud(R, L);
      }, y = y === void 0 ? null : y, y !== null && (typeof y != "function" && a("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", y), Z.callback = y);
      var ae = Sf(S, Z, L);
      return ae !== null && (pi(ae, S, L, R), Nx(ae, S, L)), L;
    function EE(i) {
    function C9(i) {
        case v: {
          if (vg(l)) {
            var m = w0(l);
            I8(l, m);
        case k: {
          pd(function() {
            var S = Ys(i, cn);
              var R = Rs();
              pi(S, i, cn, R);
          var y = cn;
          Uk(i, y);
    function wL(i, l) {
      var m = i.memoizedState;
      m !== null && m.dehydrated !== null && (m.retryLane = T0(m.retryLane, l));
    function Uk(i, l) {
      wL(i, l);
      var m = i.alternate;
      m && wL(m, l);
    function x9(i) {
      if (i.tag === k) {
        var l = Vp, m = Ys(i, l);
        if (m !== null) {
          var y = Rs();
          pi(m, i, l, y);
        Uk(i, l);
    function E9(i) {
      if (i.tag === k) {
        var l = kf(i), m = Ys(i, l);
        if (m !== null) {
          var y = Rs();
          pi(m, i, l, y);
        Uk(i, l);
    function SL(i) {
      var l = Ur(i);
    var CL = function(i) {
    function T9(i) {
      return CL(i);
    var xL = function(i) {
    function _9(i) {
      return xL(i);
    var EL = null, TL = null, _L = null, OL = null, RL = null, kL = null, PL = null, ML = null, IL = null;
      var DL = function(i, l, m) {
        var y = l[m], S = Pn(i) ? i.slice() : xn({}, i);
        return m + 1 === l.length ? (Pn(S) ? S.splice(y, 1) : delete S[y], S) : (S[y] = DL(i[y], l, m + 1), S);
      }, AL = function(i, l) {
        return DL(i, l, 0);
      }, NL = function(i, l, m, y) {
        var S = l[y], R = Pn(i) ? i.slice() : xn({}, i);
        if (y + 1 === l.length) {
          var L = m[y];
          R[L] = R[S], Pn(R) ? R.splice(S, 1) : delete R[S];
          R[S] = NL(
            m,
            y + 1
      }, $L = function(i, l, m) {
        if (l.length !== m.length) {
          for (var y = 0; y < m.length - 1; y++)
            if (l[y] !== m[y]) {
        return NL(i, l, m, 0);
      }, LL = function(i, l, m, y) {
        if (m >= l.length)
          return y;
        var S = l[m], R = Pn(i) ? i.slice() : xn({}, i);
        return R[S] = LL(i[S], l, m + 1, y), R;
      }, jL = function(i, l, m) {
        return LL(i, l, 0, m);
      }, Wk = function(i, l) {
        for (var m = i.memoizedState; m !== null && l > 0; )
          m = m.next, l--;
        return m;
      EL = function(i, l, m, y) {
        var S = Wk(i, l);
          var R = jL(S.memoizedState, m, y);
          S.memoizedState = R, S.baseState = R, i.memoizedProps = xn({}, i.memoizedProps);
          var L = Ys(i, cn);
          L !== null && pi(L, i, cn, Pr);
        }
      }, TL = function(i, l, m) {
        var y = Wk(i, l);
        if (y !== null) {
          var S = AL(y.memoizedState, m);
          y.memoizedState = S, y.baseState = S, i.memoizedProps = xn({}, i.memoizedProps);
          var R = Ys(i, cn);
          R !== null && pi(R, i, cn, Pr);
        }
      }, _L = function(i, l, m, y) {
        var S = Wk(i, l);
          var R = $L(S.memoizedState, m, y);
          S.memoizedState = R, S.baseState = R, i.memoizedProps = xn({}, i.memoizedProps);
          var L = Ys(i, cn);
          L !== null && pi(L, i, cn, Pr);
        }
      }, OL = function(i, l, m) {
        i.pendingProps = jL(i.memoizedProps, l, m), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var y = Ys(i, cn);
        y !== null && pi(y, i, cn, Pr);
      }, RL = function(i, l) {
        i.pendingProps = AL(i.memoizedProps, l), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var m = Ys(i, cn);
        m !== null && pi(m, i, cn, Pr);
      }, kL = function(i, l, m) {
        i.pendingProps = $L(i.memoizedProps, l, m), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var y = Ys(i, cn);
        y !== null && pi(y, i, cn, Pr);
      }, PL = function(i) {
        var l = Ys(i, cn);
        l !== null && pi(l, i, cn, Pr);
      }, ML = function(i) {
        CL = i;
      }, IL = function(i) {
        xL = i;
    function O9(i) {
      var l = ns(i);
    function R9(i) {
    function k9() {
      return ti;
    function P9(i) {
      var l = i.findFiberByHostInstance, m = n.ReactCurrentDispatcher;
      return nf({
        overrideHookState: EL,
        overrideHookStateDeletePath: TL,
        overrideHookStateRenamePath: _L,
        overrideProps: OL,
        overridePropsDeletePath: RL,
        overridePropsRenamePath: kL,
        setErrorHandler: ML,
        setSuspenseHandler: IL,
        scheduleUpdate: PL,
        currentDispatcherRef: m,
        findHostInstanceByFiber: O9,
        findFiberByHostInstance: l || R9,
        findHostInstancesForRefresh: s9,
        scheduleRefresh: o9,
        scheduleRoot: i9,
        setRefreshHandler: r9,
        getCurrentFiber: k9,
        reconcilerVersion: Bk
    var FL = typeof reportError == "function" ? (
    function Gk(i) {
    TE.prototype.render = Gk.prototype.render = function(i) {
        typeof arguments[1] == "function" ? a("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : _E(arguments[1]) ? a("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && a("You passed a second argument to root.render(...) but it only accepts one argument.");
        var m = l.containerInfo;
        if (m.nodeType !== vo) {
          var y = SL(l.current);
          y && y.parentNode !== m && a("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
      Aw(i, l, null, null);
    }, TE.prototype.unmount = Gk.prototype.unmount = function() {
        Q$() && a("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), pd(function() {
          Aw(null, i, null, null);
        }), FA(l);
    function M9(i, l) {
      if (!_E(i))
      zL(i);
      var m = !1, y = !1, S = "", R = FL;
      l != null && (l.hydrate ? s("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof l == "object" && l !== null && l.$$typeof === so && a(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:
  root.render(<App />);`), l.unstable_strictMode === !0 && (m = !0), l.identifierPrefix !== void 0 && (S = l.identifierPrefix), l.onRecoverableError !== void 0 && (R = l.onRecoverableError), l.transitionCallbacks !== void 0 && l.transitionCallbacks);
      var L = yL(i, wx, null, m, y, S, R);
      px(L.current, i);
      var W = i.nodeType === vo ? i.parentNode : i;
      return zb(W), new Gk(L);
    function TE(i) {
    function I9(i) {
      i && N0(i);
    TE.prototype.unstable_scheduleHydration = I9;
    function D9(i, l, m) {
      if (!_E(i))
      zL(i), l === void 0 && a("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var y = m ?? null, S = m != null && m.hydratedSources || null, R = !1, L = !1, W = "", Z = FL;
      m != null && (m.unstable_strictMode === !0 && (R = !0), m.identifierPrefix !== void 0 && (W = m.identifierPrefix), m.onRecoverableError !== void 0 && (Z = m.onRecoverableError));
      var ae = bL(l, null, i, wx, y, R, L, W, Z);
      if (px(ae.current, i), zb(i), S)
          L6(ae, Te);
      return new TE(ae);
    function _E(i) {
      return !!(i && (i.nodeType === Zi || i.nodeType === Fl || i.nodeType === Hy));
    function Nw(i) {
      return !!(i && (i.nodeType === Zi || i.nodeType === Fl || i.nodeType === Hy || i.nodeType === vo && i.nodeValue === " react-mount-point-unstable "));
    function zL(i) {
      i.nodeType === Zi && i.tagName && i.tagName.toUpperCase() === "BODY" && a("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Qb(i) && (i._reactRootContainer ? a("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : a("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    var A9 = n.ReactCurrentOwner, BL;
    BL = function(i) {
      if (i._reactRootContainer && i.nodeType !== vo) {
        var l = SL(i._reactRootContainer.current);
      var m = !!i._reactRootContainer, y = qk(i), S = !!(y && gf(y));
      S && !m && a("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), i.nodeType === Zi && i.tagName && i.tagName.toUpperCase() === "BODY" && a("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    function qk(i) {
      return i ? i.nodeType === Fl ? i.documentElement : i.firstChild : null;
    function HL() {
    function N9(i, l, m, y, S) {
        if (typeof y == "function") {
          var R = y;
          y = function() {
            var xe = EE(L);
        var L = bL(
          y,
          yf,
          HL
        i._reactRootContainer = L, px(L.current, i);
        var W = i.nodeType === vo ? i.parentNode : i;
        return zb(W), pd(), L;
        if (typeof y == "function") {
          var ae = y;
          y = function() {
            var xe = EE(le);
        var le = yL(
          yf,
          HL
        i._reactRootContainer = le, px(le.current, i);
        var Te = i.nodeType === vo ? i.parentNode : i;
        return zb(Te), pd(function() {
          Aw(l, le, m, y);
    function $9(i, l) {
    function OE(i, l, m, y, S) {
      BL(m), $9(S === void 0 ? null : S, "render");
      var R = m._reactRootContainer, L;
        L = N9(m, l, i, S, y);
          var W = S;
            var Z = EE(L);
            W.call(Z);
        Aw(l, L, i, S);
      return EE(L);
    var VL = !1;
    function L9(i) {
        VL || (VL = !0, a("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var l = A9.current;
          var m = l.stateNode._warnedAboutRefsInRender;
          m || a("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Yn(l.type) || "A component"), l.stateNode._warnedAboutRefsInRender = !0;
      return i == null ? null : i.nodeType === Zi ? i : S9(i, "findDOMNode");
    function j9(i, l, m) {
      if (a("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Nw(l))
        var y = Qb(l) && l._reactRootContainer === void 0;
        y && a("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      return OE(null, i, l, !0, m);
    function F9(i, l, m) {
      if (a("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Nw(l))
        var y = Qb(l) && l._reactRootContainer === void 0;
        y && a("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      return OE(null, i, l, !1, m);
    function z9(i, l, m, y) {
      if (a("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Nw(m))
      if (i == null || !U1(i))
      return OE(i, l, m, !1, y);
    var UL = !1;
    function B9(i) {
      if (UL || (UL = !0, a("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !Nw(i))
        var l = Qb(i) && i._reactRootContainer === void 0;
          var m = qk(i), y = m && !gf(m);
          y && a("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        return pd(function() {
          OE(null, null, i, !1, function() {
            i._reactRootContainer = null, FA(i);
          var S = qk(i), R = !!(S && gf(S)), L = i.nodeType === Zi && Nw(i.parentNode) && !!i.parentNode._reactRootContainer;
    xi(C9), af(x9), M0(E9), eh(Gs), xb(R0), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && a("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Am(VG), V1(Ek, D8, pd);
    function H9(i, l) {
      var m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!_E(l))
      return w9(i, l, null, m);
    function V9(i, l, m, y) {
      return z9(i, l, m, y);
    var Kk = {
      Events: [gf, $g, hx, Yd, Nm, Ek]
    function U9(i, l) {
      return Kk.usingClientEntryPoint || a('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), M9(i, l);
    function W9(i, l, m) {
      return Kk.usingClientEntryPoint || a('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), D9(i, l, m);
    function G9(i) {
      return Q$() && a("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), pd(i);
    var q9 = P9({
      findFiberByHostInstance: hh,
      version: Bk,
    if (!q9 && _e && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var WL = window.location.protocol;
      /^(https?|file):$/.test(WL) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (WL === "file:" ? `
    ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Kk, ea.createPortal = H9, ea.createRoot = U9, ea.findDOMNode = L9, ea.flushSync = G9, ea.hydrate = j9, ea.hydrateRoot = W9, ea.render = F9, ea.unmountComponentAtNode = B9, ea.unstable_batchedUpdates = Ek, ea.unstable_renderSubtreeIntoContainer = V9, ea.version = Bk, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), ea;
function ZB() {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ZB);
process.env.NODE_ENV === "production" ? (ZB(), JP.exports = sK()) : JP.exports = aK();
var E_ = JP.exports;
const kE = /* @__PURE__ */ vI(E_);
var Fw = E_;
  iS.createRoot = Fw.createRoot, iS.hydrateRoot = Fw.hydrateRoot;
  var PE = Fw.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  iS.createRoot = function(e, t) {
    PE.usingClientEntryPoint = !0;
      return Fw.createRoot(e, t);
      PE.usingClientEntryPoint = !1;
  }, iS.hydrateRoot = function(e, t, n) {
    PE.usingClientEntryPoint = !0;
      return Fw.hydrateRoot(e, t, n);
      PE.usingClientEntryPoint = !1;
function AS() {
  return AS = Object.assign ? Object.assign.bind() : function(e) {
  }, AS.apply(this, arguments);
var Bf;
})(Bf || (Bf = {}));
const tj = "popstate";
function lK(e) {
    return ZP(
    return typeof o == "string" ? o : NS(o);
  return cK(t, n, null, e);
function In(e, t) {
function bu(e, t) {
function uK() {
function nj(e, t) {
function ZP(e, t, n, r) {
  return n === void 0 && (n = null), AS({
  }, typeof t == "string" ? cy(t) : t, {
    key: t && t.key || r || uK()
function NS(e) {
function cy(e) {
function cK(e, t, n, r) {
  } = r, a = o.history, c = Bf.Pop, f = null, h = g();
  h == null && (h = 0, a.replaceState(AS({}, a.state, {
    idx: h
  function v() {
    c = Bf.Pop;
    let O = g(), P = O == null ? null : O - h;
    h = O, f && f({
      delta: P
  function w(O, P) {
    c = Bf.Push;
    let I = ZP(E.location, O, P);
    h = g() + 1;
    let M = nj(I, h), A = E.createHref(I);
      a.pushState(M, "", A);
    } catch (k) {
      if (k instanceof DOMException && k.name === "DataCloneError")
        throw k;
      o.location.assign(A);
  function C(O, P) {
    c = Bf.Replace;
    let I = ZP(E.location, O, P);
    h = g();
    let M = nj(I, h), A = E.createHref(I);
    a.replaceState(M, "", A), s && f && f({
    let P = o.location.origin !== "null" ? o.location.origin : o.location.href, I = typeof O == "string" ? O : NS(O);
    return I = I.replace(/ $/, "%20"), In(P, "No window.location.(origin|href) available to create URL for href: " + I), new URL(I, P);
      return o.addEventListener(tj, v), f = O, () => {
        o.removeEventListener(tj, v), f = null;
      let P = T(O);
        pathname: P.pathname,
        search: P.search,
        hash: P.hash
var rj;
})(rj || (rj = {}));
function dK(e, t, n) {
  return n === void 0 && (n = "/"), fK(e, t, n);
function fK(e, t, n, r) {
  let o = typeof t == "string" ? cy(t) : t, s = Jf(o.pathname || "/", n);
  let a = eH(e);
  pK(a);
    let h = EK(s);
    c = CK(a[f], h);
function eH(e, t, n, r) {
    f.relativePath.startsWith("/") && (In(f.relativePath.startsWith(r), 'Absolute route path "' + f.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), f.relativePath = f.relativePath.slice(r.length));
    let h = Td([r, f.relativePath]), g = n.concat(f);
    s.children && s.children.length > 0 && (In(
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + h + '".')
    ), eH(s.children, t, g, h)), !(s.path == null && !s.index) && t.push({
      path: h,
      score: wK(h, s.index),
      for (let f of tH(s.path))
function tH(e) {
  let a = tH(r.join("/")), c = [];
function pK(e) {
  e.sort((t, n) => t.score !== n.score ? n.score - t.score : SK(t.routesMeta.map((r) => r.childrenIndex), n.routesMeta.map((r) => r.childrenIndex)));
const hK = /^:[\w-]+$/, mK = 3, gK = 2, vK = 1, yK = 10, bK = -2, oj = (e) => e === "*";
function wK(e, t) {
  return n.some(oj) && (r += bK), t && (r += gK), n.filter((o) => !oj(o)).reduce((o, s) => o + (hK.test(s) ? mK : s === "" ? vK : yK), r);
function SK(e, t) {
function CK(e, t, n) {
    let f = r[c], h = c === r.length - 1, g = s === "/" ? t : t.slice(s.length) || "/", v = eM({
      end: h
    if (!v)
    Object.assign(o, v.params), a.push({
      pathname: Td([s, v.pathname]),
      pathnameBase: RK(Td([s, v.pathnameBase])),
    }), v.pathnameBase !== "/" && (s = Td([s, v.pathnameBase]));
function eM(e, t) {
  let [n, r] = xK(e.path, e.caseSensitive, e.end), o = t.match(n);
    params: r.reduce((h, g, v) => {
        let E = c[v] || "";
      const T = c[v];
      return C && !T ? h[w] = void 0 : h[w] = (T || "").replace(/%2F/g, "/"), h;
function xK(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !0), bu(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
function EK(e) {
    return bu(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e;
function Jf(e, t) {
function TK(e, t) {
  } = typeof e == "string" ? cy(e) : e;
    pathname: n ? n.startsWith("/") ? n : _K(n, t) : t,
    search: kK(r),
    hash: PK(o)
function _K(e, t) {
function Qk(e, t, n, r) {
function OK(e) {
function yI(e, t) {
  let n = OK(e);
function bI(e, t, n, r) {
  typeof e == "string" ? o = cy(e) : (o = AS({}, e), In(!o.pathname || !o.pathname.includes("?"), Qk("?", "pathname", "search", o)), In(!o.pathname || !o.pathname.includes("#"), Qk("#", "pathname", "hash", o)), In(!o.search || !o.search.includes("#"), Qk("#", "search", "hash", o)));
    let v = t.length - 1;
        w.shift(), v -= 1;
    c = v >= 0 ? t[v] : "/";
  let f = TK(o, c), h = a && a !== "/" && a.endsWith("/"), g = (s || a === ".") && n.endsWith("/");
  return !f.pathname.endsWith("/") && (h || g) && (f.pathname += "/"), f;
const Td = (e) => e.join("/").replace(/\/\/+/g, "/"), RK = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), kK = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, PK = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e;
function MK(e) {
const nH = ["post", "put", "patch", "delete"];
new Set(nH);
const IK = ["get", ...nH];
new Set(IK);
function $S() {
  return $S = Object.assign ? Object.assign.bind() : function(e) {
  }, $S.apply(this, arguments);
}
const aC = /* @__PURE__ */ x.createContext(null);
process.env.NODE_ENV !== "production" && (aC.displayName = "DataRouter");
const wI = /* @__PURE__ */ x.createContext(null);
process.env.NODE_ENV !== "production" && (wI.displayName = "DataRouterState");
const DK = /* @__PURE__ */ x.createContext(null);
process.env.NODE_ENV !== "production" && (DK.displayName = "Await");
const kl = /* @__PURE__ */ x.createContext(null);
process.env.NODE_ENV !== "production" && (kl.displayName = "Navigation");
const lC = /* @__PURE__ */ x.createContext(null);
process.env.NODE_ENV !== "production" && (lC.displayName = "Location");
const Ec = /* @__PURE__ */ x.createContext({
process.env.NODE_ENV !== "production" && (Ec.displayName = "Route");
const SI = /* @__PURE__ */ x.createContext(null);
process.env.NODE_ENV !== "production" && (SI.displayName = "RouteError");
function AK(e, t) {
  dy() || (process.env.NODE_ENV !== "production" ? In(
  ) : In(!1));
  } = x.useContext(kl), {
  } = uC(e, {
  return r !== "/" && (f = a === "/" ? r : Td([r, a])), o.createHref({
function dy() {
  return x.useContext(lC) != null;
function op() {
  return dy() || (process.env.NODE_ENV !== "production" ? In(
  ) : In(!1)), x.useContext(lC).location;
const rH = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function oH(e) {
  x.useContext(kl).static || x.useLayoutEffect(e);
function T_() {
  } = x.useContext(Ec);
  return e ? KK() : NK();
function NK() {
  dy() || (process.env.NODE_ENV !== "production" ? In(
  ) : In(!1));
  let e = x.useContext(aC), {
  } = x.useContext(kl), {
  } = x.useContext(Ec), {
  } = op(), a = JSON.stringify(yI(o, n.v7_relativeSplatPath)), c = x.useRef(!1);
  return oH(() => {
  }), x.useCallback(function(h, g) {
    if (g === void 0 && (g = {}), process.env.NODE_ENV !== "production" && bu(c.current, rH), !c.current) return;
    if (typeof h == "number") {
      r.go(h);
    let v = bI(h, JSON.parse(a), s, g.relative === "path");
    e == null && t !== "/" && (v.pathname = v.pathname === "/" ? t : Td([t, v.pathname])), (g.replace ? r.replace : r.push)(v, g.state, g);
function uC(e, t) {
  } = x.useContext(kl), {
  } = x.useContext(Ec), {
  } = op(), a = JSON.stringify(yI(o, r.v7_relativeSplatPath));
  return x.useMemo(() => bI(e, JSON.parse(a), s, n === "path"), [e, a, s, n]);
function $K(e, t) {
  return LK(e, t);
function LK(e, t, n, r) {
  dy() || (process.env.NODE_ENV !== "production" ? In(
  ) : In(!1));
  } = x.useContext(kl), {
  } = x.useContext(Ec), a = s[s.length - 1], c = a ? a.params : {}, f = a ? a.pathname : "/", h = a ? a.pathnameBase : "/", g = a && a.route;
    sH(f, !g || I.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + f + '" (under <Route path="' + I + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.
  let v = op(), w;
    let I = typeof t == "string" ? cy(t) : t;
    h === "/" || (C = I.pathname) != null && C.startsWith(h) || (process.env.NODE_ENV !== "production" ? In(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + h + '" ') + ('but pathname "' + I.pathname + '" was given in the `location` prop.')) : In(!1)), w = I;
    w = v;
  if (h !== "/") {
    let I = h.replace(/^\//, "").split("/");
  let O = dK(e, {
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && bu(g || O != null, 'No routes matched location "' + w.pathname + w.search + w.hash + '" '), process.env.NODE_ENV !== "production" && bu(O == null || O[O.length - 1].route.element !== void 0 || O[O.length - 1].route.Component !== void 0 || O[O.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + w.pathname + w.search + w.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let P = HK(O && O.map((I) => Object.assign({}, I, {
    pathname: Td([
      h,
    pathnameBase: I.pathnameBase === "/" ? h : Td([
      h,
  return t && P ? /* @__PURE__ */ x.createElement(lC.Provider, {
      location: $S({
      navigationType: Bf.Pop
  }, P) : P;
function jK() {
  let e = qK(), t = MK(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", o = {
const FK = /* @__PURE__ */ x.createElement(jK, null);
class zK extends x.Component {
    return this.state.error !== void 0 ? /* @__PURE__ */ x.createElement(Ec.Provider, {
    }, /* @__PURE__ */ x.createElement(SI.Provider, {
function BK(e) {
  } = e, o = x.useContext(aC);
  return o && o.static && o.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = n.route.id), /* @__PURE__ */ x.createElement(Ec.Provider, {
function HK(e, t, n, r) {
    let g = a.findIndex((v) => v.route.id && (c == null ? void 0 : c[v.route.id]) !== void 0);
    g >= 0 || (process.env.NODE_ENV !== "production" ? In(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(c).join(",")) : In(!1)), a = a.slice(0, Math.min(a.length, g + 1));
  let f = !1, h = -1;
      let v = a[g];
      if ((v.route.HydrateFallback || v.route.hydrateFallbackElement) && (h = g), v.route.id) {
        } = n, T = v.route.loader && w[v.route.id] === void 0 && (!C || C[v.route.id] === void 0);
        if (v.route.lazy || T) {
          f = !0, h >= 0 ? a = a.slice(0, h + 1) : a = [a[0]];
  return a.reduceRight((g, v, w) => {
    n && (C = c && v.route.id ? c[v.route.id] : void 0, E = v.route.errorElement || FK, f && (h < 0 && w === 0 ? (sH("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), T = !0, O = null) : h === w && (T = !0, O = v.route.hydrateFallbackElement || null)));
    let P = t.concat(a.slice(0, w + 1)), I = () => {
      return C ? M = E : T ? M = O : v.route.Component ? M = /* @__PURE__ */ x.createElement(v.route.Component, null) : v.route.element ? M = v.route.element : M = g, /* @__PURE__ */ x.createElement(BK, {
        match: v,
          matches: P,
    return n && (v.route.ErrorBoundary || v.route.errorElement || w === 0) ? /* @__PURE__ */ x.createElement(zK, {
        matches: P,
var iH = /* @__PURE__ */ function(e) {
}(iH || {}), LS = /* @__PURE__ */ function(e) {
}(LS || {});
function CI(e) {
function VK(e) {
  let t = x.useContext(aC);
  return t || (process.env.NODE_ENV !== "production" ? In(!1, CI(e)) : In(!1)), t;
function UK(e) {
  let t = x.useContext(wI);
  return t || (process.env.NODE_ENV !== "production" ? In(!1, CI(e)) : In(!1)), t;
function WK(e) {
  let t = x.useContext(Ec);
  return t || (process.env.NODE_ENV !== "production" ? In(!1, CI(e)) : In(!1)), t;
function xI(e) {
  let t = WK(e), n = t.matches[t.matches.length - 1];
  return n.route.id || (process.env.NODE_ENV !== "production" ? In(!1, e + ' can only be used on routes that contain a unique "id"') : In(!1)), n.route.id;
function GK() {
  return xI(LS.UseRouteId);
function qK() {
  let t = x.useContext(SI), n = UK(LS.UseRouteError), r = xI(LS.UseRouteError);
function KK() {
  } = VK(iH.UseNavigateStable), t = xI(LS.UseNavigateStable), n = x.useRef(!1);
  return oH(() => {
    s === void 0 && (s = {}), process.env.NODE_ENV !== "production" && bu(n.current, rH), n.current && (typeof o == "number" ? e.navigate(o) : e.navigate(o, $S({
const ij = {};
function sH(e, t, n) {
  !t && !ij[e] && (ij[e] = !0, process.env.NODE_ENV !== "production" && bu(!1, n));
const sj = {};
function YK(e, t) {
  process.env.NODE_ENV !== "production" && !sj[t] && (sj[t] = !0, console.warn(t));
const aj = (e, t, n) => YK(e, " React Router Future Flag Warning: " + t + ". " + ("You can use the `" + e + "` future flag to opt-in early. ") + ("For more information, see " + n + "."));
function XK(e, t) {
  (e == null ? void 0 : e.v7_startTransition) === void 0 && aj("v7_startTransition", "React Router will begin wrapping state updates in `React.startTransition` in v7", "https://reactrouter.com/v6/upgrading/future#v7_starttransition"), (e == null ? void 0 : e.v7_relativeSplatPath) === void 0 && aj("v7_relativeSplatPath", "Relative route resolution within Splat routes is changing in v7", "https://reactrouter.com/v6/upgrading/future#v7_relativesplatpath");
function ME(e) {
  dy() || (process.env.NODE_ENV !== "production" ? In(
  ) : In(!1));
  } = x.useContext(kl);
  process.env.NODE_ENV !== "production" && bu(!a, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  } = x.useContext(Ec), {
  } = op(), h = T_(), g = bI(t, yI(c, s.v7_relativeSplatPath), f, o === "path"), v = JSON.stringify(g);
  return x.useEffect(() => h(JSON.parse(v), {
  }), [h, v, o, n, r]), null;
function $h(e) {
  process.env.NODE_ENV !== "production" ? In(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : In(!1);
function QK(e) {
    navigationType: o = Bf.Pop,
  dy() && (process.env.NODE_ENV !== "production" ? In(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : In(!1));
  let f = t.replace(/^\/*/, "/"), h = x.useMemo(() => ({
    future: $S({
  typeof r == "string" && (r = cy(r));
    search: v = "",
    let O = Jf(g, f);
        search: v,
  }, [f, g, v, w, C, T, o]);
  return process.env.NODE_ENV !== "production" && bu(E != null, '<Router basename="' + f + '"> is not able to match the URL ' + ('"' + g + v + w + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), E == null ? null : /* @__PURE__ */ x.createElement(kl.Provider, {
    value: h
  }, /* @__PURE__ */ x.createElement(lC.Provider, {
function JK(e) {
  return $K(tM(t), n);
function tM(e, t) {
      n.push.apply(n, tM(r.props.children, s));
    r.type !== $h && (process.env.NODE_ENV !== "production" ? In(!1, "[" + (typeof r.type == "string" ? r.type : r.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : In(!1)), !r.props.index || !r.props.children || (process.env.NODE_ENV !== "production" ? In(!1, "An index route cannot have child routes.") : In(!1));
    r.props.children && (a.children = tM(r.props.children, s)), n.push(a);
function Vv() {
  return Vv = Object.assign ? Object.assign.bind() : function(e) {
  }, Vv.apply(this, arguments);
function EI(e, t) {
const cT = "get", dT = "application/x-www-form-urlencoded";
function __(e) {
function ZK(e) {
  return __(e) && e.tagName.toLowerCase() === "button";
function e7(e) {
  return __(e) && e.tagName.toLowerCase() === "form";
function t7(e) {
  return __(e) && e.tagName.toLowerCase() === "input";
function n7(e) {
function r7(e, t) {
  !n7(e);
let IE = null;
function o7() {
  if (IE === null)
      ), IE = !1;
      IE = !0;
  return IE;
const i7 = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function Jk(e) {
  return e != null && !i7.has(e) ? (process.env.NODE_ENV !== "production" && bu(!1, '"' + e + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + dT + '"')), null) : e;
function s7(e, t) {
  if (e7(e)) {
    r = c ? Jf(c, t) : null, n = e.getAttribute("method") || cT, o = Jk(e.getAttribute("enctype")) || dT, s = new FormData(e);
  } else if (ZK(e) || t7(e) && (e.type === "submit" || e.type === "image")) {
    if (r = f ? Jf(f, t) : null, n = e.getAttribute("formmethod") || c.getAttribute("method") || cT, o = Jk(e.getAttribute("formenctype")) || Jk(c.getAttribute("enctype")) || dT, s = new FormData(c, e), !o7()) {
        name: h,
        value: v
        let w = h ? h + "." : "";
      } else h && s.append(h, v);
    if (__(e))
    n = cT, r = null, o = dT, a = e;
const a7 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], l7 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], u7 = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"], c7 = "6";
  window.__reactRouterVersion = c7;
const aH = /* @__PURE__ */ x.createContext({
process.env.NODE_ENV !== "production" && (aH.displayName = "ViewTransition");
const d7 = /* @__PURE__ */ x.createContext(/* @__PURE__ */ new Map());
process.env.NODE_ENV !== "production" && (d7.displayName = "Fetchers");
const f7 = "startTransition", lj = RT[f7];
function p7(e) {
  s.current == null && (s.current = lK({
    v7_startTransition: h
  } = r || {}, g = x.useCallback((v) => {
    h && lj ? lj(() => f(v)) : f(v);
  }, [f, h]);
  return x.useLayoutEffect(() => a.listen(g), [a, g]), x.useEffect(() => XK(r), [r]), /* @__PURE__ */ x.createElement(QK, {
const h7 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", m7 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, lH = /* @__PURE__ */ x.forwardRef(function(t, n) {
    to: h,
    viewTransition: v
  } = t, w = EI(t, a7), {
  } = x.useContext(kl), T, E = !1;
  if (typeof h == "string" && m7.test(h) && (T = h, h7))
      let M = new URL(window.location.href), A = h.startsWith("//") ? new URL(M.protocol + h) : new URL(h), k = Jf(A.pathname, C);
      A.origin === M.origin && k != null ? h = k + A.search + A.hash : E = !0;
      process.env.NODE_ENV !== "production" && bu(!1, '<Link to="' + h + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
  let O = AK(h, {
  }), P = b7(h, {
    viewTransition: v
    r && r(M), M.defaultPrevented || P(M);
    /* @__PURE__ */ x.createElement("a", Vv({}, w, {
process.env.NODE_ENV !== "production" && (lH.displayName = "Link");
const g7 = /* @__PURE__ */ x.forwardRef(function(t, n) {
    viewTransition: h,
  } = t, v = EI(t, l7), w = uC(f, {
    relative: v.relative
  }), C = op(), T = x.useContext(wI), {
  } = x.useContext(kl), P = T != null && // Conditional usage is OK here because the usage of a data router is static
  T7(w) && h === !0, I = E.encodeLocation ? E.encodeLocation(w).pathname : w.pathname, M = C.pathname, A = T && T.navigation && T.navigation.location ? T.navigation.location.pathname : null;
  o || (M = M.toLowerCase(), A = A ? A.toLowerCase() : null, I = I.toLowerCase()), A && O && (A = Jf(A, O) || A);
  const k = I !== "/" && I.endsWith("/") ? I.length - 1 : I.length;
  let j = M === I || !a && M.startsWith(I) && M.charAt(k) === "/", B = A != null && (A === I || !a && A.startsWith(I) && A.charAt(I.length) === "/"), H = {
    isActive: j,
    isPending: B,
    isTransitioning: P
  }, F = j ? r : void 0, D;
  typeof s == "function" ? D = s(H) : D = [s, j ? "active" : null, B ? "pending" : null, P ? "transitioning" : null].filter(Boolean).join(" ");
  let q = typeof c == "function" ? c(H) : c;
  return /* @__PURE__ */ x.createElement(lH, Vv({}, v, {
    "aria-current": F,
    className: D,
    viewTransition: h
  }), typeof g == "function" ? g(H) : g);
process.env.NODE_ENV !== "production" && (g7.displayName = "NavLink");
const v7 = /* @__PURE__ */ x.forwardRef((e, t) => {
    method: c = cT,
    onSubmit: h,
    preventScrollReset: v,
  } = e, C = EI(e, u7), T = x7(), E = E7(f, {
  }), O = c.toLowerCase() === "get" ? "get" : "post", P = (I) => {
    if (h && h(I), I.defaultPrevented) return;
    let M = I.nativeEvent.submitter, A = (M == null ? void 0 : M.getAttribute("formmethod")) || c;
      method: A,
      preventScrollReset: v,
  return /* @__PURE__ */ x.createElement("form", Vv({
    onSubmit: o ? h : P
process.env.NODE_ENV !== "production" && (v7.displayName = "Form");
var kT;
})(kT || (kT = {}));
var uj;
})(uj || (uj = {}));
function y7(e) {
function uH(e) {
  let t = x.useContext(aC);
  return t || (process.env.NODE_ENV !== "production" ? In(!1, y7(e)) : In(!1)), t;
function b7(e, t) {
  } = t === void 0 ? {} : t, f = T_(), h = op(), g = uC(e, {
  return x.useCallback((v) => {
    if (r7(v, n)) {
      v.preventDefault();
      let w = r !== void 0 ? r : NS(h) === NS(g);
  }, [h, f, g, r, o, n, e, s, a, c]);
function w7() {
let S7 = 0, C7 = () => "__" + String(++S7) + "__";
function x7() {
  } = uH(kT.UseSubmit), {
  } = x.useContext(kl), n = GK();
    o === void 0 && (o = {}), w7();
      body: h
    } = s7(r, t);
      let g = o.fetcherKey || C7();
        body: h,
        body: h,
function E7(e, t) {
  } = x.useContext(kl), o = x.useContext(Ec);
  o || (process.env.NODE_ENV !== "production" ? In(!1, "useFormAction must be used inside a RouteContext") : In(!1));
  let [s] = o.matches.slice(-1), a = Vv({}, uC(e || ".", {
  })), c = op();
    let f = new URLSearchParams(a.search), h = f.getAll("index");
    if (h.some((v) => v === "")) {
      f.delete("index"), h.filter((w) => w).forEach((w) => f.append("index", w));
      let v = f.toString();
      a.search = v ? "?" + v : "";
  return (!e || e === ".") && s.route.index && (a.search = a.search ? a.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (a.pathname = a.pathname === "/" ? r : Td([r, a.pathname])), NS(a);
function T7(e, t) {
  let n = x.useContext(aH);
  n == null && (process.env.NODE_ENV !== "production" ? In(!1, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : In(!1));
  } = uH(kT.useViewTransitionState), o = uC(e, {
  let s = Jf(n.currentLocation.pathname, r) || n.currentLocation.pathname, a = Jf(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return eM(o.pathname, a) != null || eM(o.pathname, s) != null;
const jS = {
}, av = {
}, lv = {
}, uv = {
}, cv = {
}, dv = {
}, zw = {
}, _7 = {
function wc(e, ...t) {
const gc = "$$material";
function O7(e) {
function R7(e) {
var k7 = /* @__PURE__ */ function() {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(R7(this));
      var s = O7(o);
}(), ms = "-ms-", PT = "-moz-", dr = "-webkit-", cH = "comm", TI = "rule", _I = "decl", P7 = "@import", dH = "@keyframes", M7 = "@layer", I7 = Math.abs, O_ = String.fromCharCode, D7 = Object.assign;
function A7(e, t) {
  return qi(e, 0) ^ 45 ? (((t << 2 ^ qi(e, 0)) << 2 ^ qi(e, 1)) << 2 ^ qi(e, 2)) << 2 ^ qi(e, 3) : 0;
function fH(e) {
function N7(e, t) {
function pr(e, t, n) {
function nM(e, t) {
function qi(e, t) {
function FS(e, t, n) {
function fc(e) {
function OI(e) {
function DE(e, t) {
function $7(e, t) {
var R_ = 1, Uv = 1, pH = 0, da = 0, Yo = 0, fy = "";
function k_(e, t, n, r, o, s, a) {
  return { value: e, root: t, parent: n, type: r, props: o, children: s, line: R_, column: Uv, length: a, return: "" };
function Bw(e, t) {
  return D7(k_("", null, null, "", null, null, 0), e, { length: -e.length }, t);
function L7() {
  return Yo;
function j7() {
  return Yo = da > 0 ? qi(fy, --da) : 0, Uv--, Yo === 10 && (Uv = 1, R_--), Yo;
function Na() {
  return Yo = da < pH ? qi(fy, da++) : 0, Uv++, Yo === 10 && (Uv = 1, R_++), Yo;
function vc() {
  return qi(fy, da);
function fT() {
  return da;
function cC(e, t) {
  return FS(fy, e, t);
function zS(e) {
function hH(e) {
  return R_ = Uv = 1, pH = fc(fy = e), da = 0, [];
function mH(e) {
  return fy = "", e;
function pT(e) {
  return fH(cC(da - 1, rM(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
function F7(e) {
  for (; (Yo = vc()) && Yo < 33; )
    Na();
  return zS(e) > 2 || zS(Yo) > 3 ? "" : " ";
function z7(e, t) {
  for (; --t && Na() && !(Yo < 48 || Yo > 102 || Yo > 57 && Yo < 65 || Yo > 70 && Yo < 97); )
  return cC(e, fT() + (t < 6 && vc() == 32 && Na() == 32));
function rM(e) {
  for (; Na(); )
    switch (Yo) {
        return da;
        e !== 34 && e !== 39 && rM(Yo);
        e === 41 && rM(e);
        Na();
  return da;
function B7(e, t) {
  for (; Na() && e + Yo !== 57; )
    if (e + Yo === 84 && vc() === 47)
  return "/*" + cC(t, da - 1) + "*" + O_(e === 47 ? e : Na());
function H7(e) {
  for (; !zS(vc()); )
    Na();
  return cC(e, da);
function V7(e) {
  return mH(hT("", null, null, null, [""], e = hH(e), 0, [0], e));
function hT(e, t, n, r, o, s, a, c, f) {
  for (var h = 0, g = 0, v = a, w = 0, C = 0, T = 0, E = 1, O = 1, P = 1, I = 0, M = "", A = o, k = s, j = r, B = M; O; )
    switch (T = I, I = Na()) {
        if (T != 108 && qi(B, v - 1) == 58) {
          nM(B += pr(pT(I), "&", "&\f"), "&\f") != -1 && (P = -1);
        B += pT(I);
        B += F7(T);
        B += z7(fT() - 1, 7);
        switch (vc()) {
            DE(U7(B7(Na(), fT()), t, n), f);
            B += "/";
        c[h++] = fc(B) * P;
            P == -1 && (B = pr(B, /\f/g, "")), C > 0 && fc(B) - v && DE(C > 32 ? dj(B + ";", r, n, v - 1) : dj(pr(B, " ", "") + ";", r, n, v - 2), f);
            B += ";";
            if (DE(j = cj(B, t, n, h, g, o, c, M, A = [], k = [], v), s), I === 123)
                hT(B, t, j, j, A, s, v, c, k);
                switch (w === 99 && qi(B, 3) === 110 ? 100 : w) {
                    hT(e, j, j, r && DE(cj(e, j, j, 0, 0, o, c, M, o, A = [], v), k), o, k, v, c, r ? A : k);
                    hT(B, j, j, j, [""], k, 0, c, k);
        h = g = C = 0, E = P = 1, M = B = "", v = a;
        v = 1 + fc(B), C = T;
          else if (I == 125 && E++ == 0 && j7() == 125)
        switch (B += O_(I), I * E) {
            P = g > 0 ? 1 : (B += "\f", -1);
            c[h++] = (fc(B) - 1) * P, P = 1;
            vc() === 45 && (B += pT(Na())), w = vc(), g = v = fc(M = B += H7(fT())), I++;
            T === 45 && fc(B) == 2 && (E = 0);
function cj(e, t, n, r, o, s, a, c, f, h, g) {
  for (var v = o - 1, w = o === 0 ? s : [""], C = OI(w), T = 0, E = 0, O = 0; T < r; ++T)
    for (var P = 0, I = FS(e, v + 1, v = I7(E = a[T])), M = e; P < C; ++P)
      (M = fH(E > 0 ? w[P] + " " + I : pr(I, /&\f/g, w[P]))) && (f[O++] = M);
  return k_(e, t, n, o === 0 ? TI : c, f, h, g);
function U7(e, t, n) {
  return k_(e, t, n, cH, O_(L7()), FS(e, 2, -2), 0);
function dj(e, t, n, r) {
  return k_(e, t, n, _I, FS(e, 0, r), FS(e, r + 1, -1), r);
function Nv(e, t) {
  for (var n = "", r = OI(e), o = 0; o < r; o++)
function W7(e, t, n, r) {
    case M7:
    case P7:
    case _I:
    case cH:
    case dH:
      return e.return = e.value + "{" + Nv(e.children, r) + "}";
    case TI:
  return fc(n = Nv(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
function G7(e) {
  var t = OI(e);
function q7(e) {
function gH(e) {
var K7 = function(t, n, r) {
  for (var o = 0, s = 0; o = s, s = vc(), o === 38 && s === 12 && (n[r] = 1), !zS(s); )
    Na();
  return cC(t, da);
}, Y7 = function(t, n) {
    switch (zS(o)) {
        o === 38 && vc() === 12 && (n[r] = 1), t[r] += K7(da - 1, n, r);
        t[r] += pT(o);
          t[++r] = vc() === 58 ? "&\f" : "", n[r] = t[r].length;
        t[r] += O_(o);
  while (o = Na());
}, X7 = function(t, n) {
  return mH(Y7(hH(t), n));
}, fj = /* @__PURE__ */ new WeakMap(), Q7 = function(t) {
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !fj.get(r)) && !o) {
      fj.set(t, !0);
      for (var s = [], a = X7(n, s), c = r.props, f = 0, h = 0; f < a.length; f++)
        for (var g = 0; g < c.length; g++, h++)
          t.props[h] = s[f] ? a[f].replace(/&\f/g, c[g]) : c[g] + " " + a[f];
}, J7 = function(t) {
function vH(e, t) {
  switch (A7(e, t)) {
      return dr + "print-" + e + e;
      return dr + e + e;
      return dr + e + PT + e + ms + e + e;
      return dr + e + ms + e + e;
      return dr + e + ms + "flex-" + e + e;
      return dr + e + pr(e, /(\w+).+(:[^]+)/, dr + "box-$1$2" + ms + "flex-$1$2") + e;
      return dr + e + ms + "flex-item-" + pr(e, /flex-|-self/, "") + e;
      return dr + e + ms + "flex-line-pack" + pr(e, /align-content|flex-|-self/, "") + e;
      return dr + e + ms + pr(e, "shrink", "negative") + e;
      return dr + e + ms + pr(e, "basis", "preferred-size") + e;
      return dr + "box-" + pr(e, "-grow", "") + dr + e + ms + pr(e, "grow", "positive") + e;
      return dr + pr(e, /([^-])(transform)/g, "$1" + dr + "$2") + e;
      return pr(pr(pr(e, /(zoom-|grab)/, dr + "$1"), /(image-set)/, dr + "$1"), e, "") + e;
      return pr(e, /(image-set\([^]*)/, dr + "$1$`$1");
      return pr(pr(e, /(.+:)(flex-)?(.*)/, dr + "box-pack:$3" + ms + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + dr + e + e;
      return pr(e, /(.+)-inline(.+)/, dr + "$1$2") + e;
      if (fc(e) - 1 - t > 6) switch (qi(e, t + 1)) {
          if (qi(e, t + 4) !== 45) break;
          return pr(e, /(.+:)(.+)-([^]+)/, "$1" + dr + "$2-$3$1" + PT + (qi(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          return ~nM(e, "stretch") ? vH(pr(e, "stretch", "fill-available"), t) + e : e;
      if (qi(e, t + 1) !== 115) break;
      switch (qi(e, fc(e) - 3 - (~nM(e, "!important") && 10))) {
          return pr(e, ":", ":" + dr) + e;
          return pr(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + dr + (qi(e, 14) === 45 ? "inline-" : "") + "box$3$1" + dr + "$2$3$1" + ms + "$2box$3") + e;
      switch (qi(e, t + 11)) {
          return dr + e + ms + pr(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
          return dr + e + ms + pr(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
          return dr + e + ms + pr(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      return dr + e + ms + e + e;
var Z7 = function(t, n, r, o) {
    case _I:
      t.return = vH(t.value, t.length);
    case dH:
      return Nv([Bw(t, {
        value: pr(t.value, "@", "@" + dr)
    case TI:
      if (t.length) return $7(t.props, function(s) {
        switch (N7(s, /(::plac\w+|:read-\w+)/)) {
            return Nv([Bw(t, {
              props: [pr(s, /:(read-\w+)/, ":" + PT + "$1")]
            return Nv([Bw(t, {
              props: [pr(s, /:(plac\w+)/, ":" + dr + "input-$1")]
            }), Bw(t, {
              props: [pr(s, /:(plac\w+)/, ":" + PT + "$1")]
            }), Bw(t, {
              props: [pr(s, /:(plac\w+)/, ms + "input-$1")]
}, eY = [Z7], tY = function(t) {
  var o = t.stylisPlugins || eY, s = {}, a, c = [];
      for (var O = E.getAttribute("data-emotion").split(" "), P = 1; P < O.length; P++)
        s[O[P]] = !0;
  var f, h = [Q7, J7];
    var g, v = [W7, q7(function(E) {
    })], w = G7(h.concat(o, v)), C = function(O) {
      return Nv(V7(O), w);
    f = function(O, P, I, M) {
      g = I, C(O ? O + "{" + P.styles + "}" : P.styles), M && (T.inserted[P.name] = !0);
    sheet: new k7({
}, oM = { exports: {} }, xr = {};
var pj;
function nY() {
  if (pj) return xr;
  pj = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, c = e ? Symbol.for("react.context") : 60110, f = e ? Symbol.for("react.async_mode") : 60111, h = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, v = e ? Symbol.for("react.suspense") : 60113, w = e ? Symbol.for("react.suspense_list") : 60120, C = e ? Symbol.for("react.memo") : 60115, T = e ? Symbol.for("react.lazy") : 60116, E = e ? Symbol.for("react.block") : 60121, O = e ? Symbol.for("react.fundamental") : 60117, P = e ? Symbol.for("react.responder") : 60118, I = e ? Symbol.for("react.scope") : 60119;
  function M(k) {
    if (typeof k == "object" && k !== null) {
      var j = k.$$typeof;
      switch (j) {
          switch (k = k.type, k) {
            case h:
            case v:
              return k;
              switch (k = k && k.$$typeof, k) {
                  return k;
                  return j;
          return j;
      }
    }
  }
  function A(k) {
    return M(k) === h;
  }
  return xr.AsyncMode = f, xr.ConcurrentMode = h, xr.ContextConsumer = c, xr.ContextProvider = a, xr.Element = t, xr.ForwardRef = g, xr.Fragment = r, xr.Lazy = T, xr.Memo = C, xr.Portal = n, xr.Profiler = s, xr.StrictMode = o, xr.Suspense = v, xr.isAsyncMode = function(k) {
    return A(k) || M(k) === f;
  }, xr.isConcurrentMode = A, xr.isContextConsumer = function(k) {
    return M(k) === c;
  }, xr.isContextProvider = function(k) {
    return M(k) === a;
  }, xr.isElement = function(k) {
    return typeof k == "object" && k !== null && k.$$typeof === t;
  }, xr.isForwardRef = function(k) {
    return M(k) === g;
  }, xr.isFragment = function(k) {
    return M(k) === r;
  }, xr.isLazy = function(k) {
    return M(k) === T;
  }, xr.isMemo = function(k) {
    return M(k) === C;
  }, xr.isPortal = function(k) {
    return M(k) === n;
  }, xr.isProfiler = function(k) {
    return M(k) === s;
  }, xr.isStrictMode = function(k) {
    return M(k) === o;
  }, xr.isSuspense = function(k) {
    return M(k) === v;
  }, xr.isValidElementType = function(k) {
    return typeof k == "string" || typeof k == "function" || k === r || k === h || k === s || k === o || k === v || k === w || typeof k == "object" && k !== null && (k.$$typeof === T || k.$$typeof === C || k.$$typeof === a || k.$$typeof === c || k.$$typeof === g || k.$$typeof === O || k.$$typeof === P || k.$$typeof === I || k.$$typeof === E);
  }, xr.typeOf = M, xr;
}
var Er = {};
var hj;
function rY() {
  return hj || (hj = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, c = e ? Symbol.for("react.context") : 60110, f = e ? Symbol.for("react.async_mode") : 60111, h = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, v = e ? Symbol.for("react.suspense") : 60113, w = e ? Symbol.for("react.suspense_list") : 60120, C = e ? Symbol.for("react.memo") : 60115, T = e ? Symbol.for("react.lazy") : 60116, E = e ? Symbol.for("react.block") : 60121, O = e ? Symbol.for("react.fundamental") : 60117, P = e ? Symbol.for("react.responder") : 60118, I = e ? Symbol.for("react.scope") : 60119;
      ce === r || ce === h || ce === s || ce === o || ce === v || ce === w || typeof ce == "object" && ce !== null && (ce.$$typeof === T || ce.$$typeof === C || ce.$$typeof === a || ce.$$typeof === c || ce.$$typeof === g || ce.$$typeof === O || ce.$$typeof === P || ce.$$typeof === I || ce.$$typeof === E);
    function A(ce) {
              case h:
              case v:
    var k = f, j = h, B = c, H = a, F = t, D = g, q = r, U = T, K = C, ee = n, G = s, Y = o, X = v, te = !1;
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Q(ce) || A(ce) === f;
      return A(ce) === h;
    function V(ce) {
      return A(ce) === c;
      return A(ce) === a;
      return A(ce) === g;
      return A(ce) === r;
      return A(ce) === T;
      return A(ce) === C;
      return A(ce) === n;
      return A(ce) === s;
      return A(ce) === o;
      return A(ce) === v;
    Er.AsyncMode = k, Er.ConcurrentMode = j, Er.ContextConsumer = B, Er.ContextProvider = H, Er.Element = F, Er.ForwardRef = D, Er.Fragment = q, Er.Lazy = U, Er.Memo = K, Er.Portal = ee, Er.Profiler = G, Er.StrictMode = Y, Er.Suspense = X, Er.isAsyncMode = re, Er.isConcurrentMode = Q, Er.isContextConsumer = V, Er.isContextProvider = ie, Er.isElement = de, Er.isForwardRef = ue, Er.isFragment = he, Er.isLazy = ge, Er.isMemo = fe, Er.isPortal = pe, Er.isProfiler = be, Er.isStrictMode = we, Er.isSuspense = _e, Er.isValidElementType = M, Er.typeOf = A;
  }()), Er;
process.env.NODE_ENV === "production" ? oM.exports = nY() : oM.exports = rY();
var oY = oM.exports, yH = oY, iY = {
}, sY = {
}, bH = {};
bH[yH.ForwardRef] = iY;
bH[yH.Memo] = sY;
var aY = !0;
function wH(e, t, n) {
var RI = function(t, n, r) {
  aY === !1) && t.registered[o] === void 0 && (t.registered[o] = n.styles);
}, kI = function(t, n, r) {
  RI(t, n, r);
function lY(e) {
var uY = {
}, cY = /[A-Z]|^ms/g, dY = /_EMO_([^_]+?)_([^]*?)_EMO_/g, SH = function(t) {
}, mj = function(t) {
}, Zk = /* @__PURE__ */ gH(function(e) {
  return SH(e) ? e : e.replace(cY, "-$&").toLowerCase();
}), gj = function(t, n) {
        return n.replace(dY, function(r, o, s) {
          return pc = {
            next: pc
  return uY[t] !== 1 && !SH(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
function BS(e, t, n) {
        return pc = {
          next: pc
            pc = {
              next: pc
      return fY(e, t, n);
        var f = pc, h = n(e);
        return pc = f, BS(e, t, h);
  var v = t[g];
  return v !== void 0 ? v : g;
function fY(e, t, n) {
      r += BS(e, t, n[o]) + ";";
        t != null && t[c] !== void 0 ? r += s + "{" + t[c] + "}" : mj(c) && (r += Zk(s) + ":" + gj(s, c) + ";");
          mj(a[f]) && (r += Zk(s) + ":" + gj(s, a[f]) + ";");
        var h = BS(e, t, a);
            r += Zk(s) + ":" + h + ";";
            r += s + "{" + h + "}";
var vj = /label:\s*([^\s;{]+)\s*(;|$)/g, pc;
function py(e, t, n) {
  pc = void 0;
    r = !1, o += BS(n, t, s);
    if (o += BS(n, t, e[c]), r) {
  vj.lastIndex = 0;
  for (var h = "", g; (g = vj.exec(o)) !== null; )
    h += "-" + g[1];
  var v = lY(o) + h;
    name: v,
    next: pc
var pY = function(t) {
}, CH = RT.useInsertionEffect ? RT.useInsertionEffect : !1, xH = CH || pY, yj = CH || x.useLayoutEffect, EH = /* @__PURE__ */ x.createContext(
  typeof HTMLElement < "u" ? /* @__PURE__ */ tY({
EH.Provider;
var PI = function(t) {
    var o = x.useContext(EH);
}, dC = /* @__PURE__ */ x.createContext({}), MI = {}.hasOwnProperty, iM = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", hY = function(t, n) {
    MI.call(n, o) && (r[o] = n[o]);
  return r[iM] = t, r;
}, mY = function(t) {
  return RI(n, r, o), xH(function() {
    return kI(n, r, o);
}, gY = /* @__PURE__ */ PI(function(e, t, n) {
  var o = e[iM], s = [r], a = "";
  typeof e.className == "string" ? a = wH(t.registered, s, e.className) : e.className != null && (a = e.className + " ");
  var c = py(s, void 0, x.useContext(dC));
  for (var h in e)
    MI.call(e, h) && h !== "css" && h !== iM && (f[h] = e[h]);
  return f.className = a, n && (f.ref = n), /* @__PURE__ */ x.createElement(x.Fragment, null, /* @__PURE__ */ x.createElement(mY, {
}), vY = gY, bj = function(t, n) {
  if (n == null || !MI.call(n, "css"))
  s[0] = vY, s[1] = hY(t, n);
})(bj || (bj = {}));
var yY = /* @__PURE__ */ PI(function(e, t) {
  var n = e.styles, r = py([n], void 0, x.useContext(dC)), o = x.useRef();
  return yj(function() {
  }, [t]), yj(function() {
    if (r.next !== void 0 && kI(t, r.next, !0), a.tags.length) {
function ip() {
  return py(t);
function Tc() {
  var e = ip.apply(void 0, arguments), t = "animation-" + e.name;
var bY = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|popover|popoverTarget|popoverTargetAction|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, wY = /* @__PURE__ */ gH(
    return bY.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
), SY = wY, CY = function(t) {
}, wj = function(t) {
  t.charCodeAt(0) > 96 ? SY : CY;
}, Sj = function(t, n, r) {
}, xY = function(t) {
  return RI(n, r, o), xH(function() {
    return kI(n, r, o);
}, EY = function e(t, n) {
  var c = Sj(t, n, r), f = c || wj(o), h = !f("as");
    var g = arguments, v = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (s !== void 0 && v.push("label:" + s + ";"), g[0] == null || g[0].raw === void 0)
      v.push.apply(v, g);
      v.push(w[0]);
        v.push(g[T], w[T]);
    var E = PI(function(O, P, I) {
      var M = h && O.as || o, A = "", k = [], j = O;
        j = {};
        for (var B in O)
          j[B] = O[B];
        j.theme = x.useContext(dC);
      }
      typeof O.className == "string" ? A = wH(P.registered, k, O.className) : O.className != null && (A = O.className + " ");
      var H = py(v.concat(k), P.registered, j);
      A += P.key + "-" + H.name, a !== void 0 && (A += " " + a);
      var F = h && c === void 0 ? wj(M) : f, D = {};
        h && q === "as" || F(q) && (D[q] = O[q]);
      return D.className = A, I && (D.ref = I), /* @__PURE__ */ x.createElement(x.Fragment, null, /* @__PURE__ */ x.createElement(xY, {
        cache: P,
        serialized: H,
      }), /* @__PURE__ */ x.createElement(M, D));
    return E.displayName = s !== void 0 ? s : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", E.defaultProps = t.defaultProps, E.__emotion_real = E, E.__emotion_base = o, E.__emotion_styles = v, E.__emotion_forwardProp = c, Object.defineProperty(E, "toString", {
    }), E.withComponent = function(O, P) {
      var I = e(O, J({}, n, P, {
        shouldForwardProp: Sj(E, P, !0)
      return I.apply(void 0, v);
}, TY = [
], MT = EY.bind(null);
TY.forEach(function(e) {
  MT[e] = MT(e);
var sM = { exports: {} }, AE = { exports: {} }, Tr = {};
var Cj;
function _Y() {
  if (Cj) return Tr;
  Cj = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, c = e ? Symbol.for("react.context") : 60110, f = e ? Symbol.for("react.async_mode") : 60111, h = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, v = e ? Symbol.for("react.suspense") : 60113, w = e ? Symbol.for("react.suspense_list") : 60120, C = e ? Symbol.for("react.memo") : 60115, T = e ? Symbol.for("react.lazy") : 60116, E = e ? Symbol.for("react.block") : 60121, O = e ? Symbol.for("react.fundamental") : 60117, P = e ? Symbol.for("react.responder") : 60118, I = e ? Symbol.for("react.scope") : 60119;
  function M(k) {
    if (typeof k == "object" && k !== null) {
      var j = k.$$typeof;
      switch (j) {
          switch (k = k.type, k) {
            case h:
            case v:
              return k;
              switch (k = k && k.$$typeof, k) {
                  return k;
                  return j;
          return j;
      }
    }
  }
  function A(k) {
    return M(k) === h;
  }
  return Tr.AsyncMode = f, Tr.ConcurrentMode = h, Tr.ContextConsumer = c, Tr.ContextProvider = a, Tr.Element = t, Tr.ForwardRef = g, Tr.Fragment = r, Tr.Lazy = T, Tr.Memo = C, Tr.Portal = n, Tr.Profiler = s, Tr.StrictMode = o, Tr.Suspense = v, Tr.isAsyncMode = function(k) {
    return A(k) || M(k) === f;
  }, Tr.isConcurrentMode = A, Tr.isContextConsumer = function(k) {
    return M(k) === c;
  }, Tr.isContextProvider = function(k) {
    return M(k) === a;
  }, Tr.isElement = function(k) {
    return typeof k == "object" && k !== null && k.$$typeof === t;
  }, Tr.isForwardRef = function(k) {
    return M(k) === g;
  }, Tr.isFragment = function(k) {
    return M(k) === r;
  }, Tr.isLazy = function(k) {
    return M(k) === T;
  }, Tr.isMemo = function(k) {
    return M(k) === C;
  }, Tr.isPortal = function(k) {
    return M(k) === n;
  }, Tr.isProfiler = function(k) {
    return M(k) === s;
  }, Tr.isStrictMode = function(k) {
    return M(k) === o;
  }, Tr.isSuspense = function(k) {
    return M(k) === v;
  }, Tr.isValidElementType = function(k) {
    return typeof k == "string" || typeof k == "function" || k === r || k === h || k === s || k === o || k === v || k === w || typeof k == "object" && k !== null && (k.$$typeof === T || k.$$typeof === C || k.$$typeof === a || k.$$typeof === c || k.$$typeof === g || k.$$typeof === O || k.$$typeof === P || k.$$typeof === I || k.$$typeof === E);
  }, Tr.typeOf = M, Tr;
}
var _r = {};
var xj;
function OY() {
  return xj || (xj = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, s = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, c = e ? Symbol.for("react.context") : 60110, f = e ? Symbol.for("react.async_mode") : 60111, h = e ? Symbol.for("react.concurrent_mode") : 60111, g = e ? Symbol.for("react.forward_ref") : 60112, v = e ? Symbol.for("react.suspense") : 60113, w = e ? Symbol.for("react.suspense_list") : 60120, C = e ? Symbol.for("react.memo") : 60115, T = e ? Symbol.for("react.lazy") : 60116, E = e ? Symbol.for("react.block") : 60121, O = e ? Symbol.for("react.fundamental") : 60117, P = e ? Symbol.for("react.responder") : 60118, I = e ? Symbol.for("react.scope") : 60119;
      ce === r || ce === h || ce === s || ce === o || ce === v || ce === w || typeof ce == "object" && ce !== null && (ce.$$typeof === T || ce.$$typeof === C || ce.$$typeof === a || ce.$$typeof === c || ce.$$typeof === g || ce.$$typeof === O || ce.$$typeof === P || ce.$$typeof === I || ce.$$typeof === E);
    function A(ce) {
              case h:
              case v:
    var k = f, j = h, B = c, H = a, F = t, D = g, q = r, U = T, K = C, ee = n, G = s, Y = o, X = v, te = !1;
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Q(ce) || A(ce) === f;
      return A(ce) === h;
    function V(ce) {
      return A(ce) === c;
      return A(ce) === a;
      return A(ce) === g;
      return A(ce) === r;
      return A(ce) === T;
      return A(ce) === C;
      return A(ce) === n;
      return A(ce) === s;
      return A(ce) === o;
      return A(ce) === v;
    _r.AsyncMode = k, _r.ConcurrentMode = j, _r.ContextConsumer = B, _r.ContextProvider = H, _r.Element = F, _r.ForwardRef = D, _r.Fragment = q, _r.Lazy = U, _r.Memo = K, _r.Portal = ee, _r.Profiler = G, _r.StrictMode = Y, _r.Suspense = X, _r.isAsyncMode = re, _r.isConcurrentMode = Q, _r.isContextConsumer = V, _r.isContextProvider = ie, _r.isElement = de, _r.isForwardRef = ue, _r.isFragment = he, _r.isLazy = ge, _r.isMemo = fe, _r.isPortal = pe, _r.isProfiler = be, _r.isStrictMode = we, _r.isSuspense = _e, _r.isValidElementType = M, _r.typeOf = A;
  }()), _r;
var Ej;
function TH() {
  return Ej || (Ej = 1, process.env.NODE_ENV === "production" ? AE.exports = _Y() : AE.exports = OY()), AE.exports;
var eP, Tj;
function RY() {
  if (Tj) return eP;
  Tj = 1;
      var h = {};
        h[g] = g;
      }), Object.keys(Object.assign({}, h)).join("") === "abcdefghijklmnopqrst";
  return eP = o() ? Object.assign : function(s, a) {
    for (var c, f = r(s), h, g = 1; g < arguments.length; g++) {
      for (var v in c)
        t.call(c, v) && (f[v] = c[v]);
        h = e(c);
        for (var w = 0; w < h.length; w++)
          n.call(c, h[w]) && (f[h[w]] = c[h[w]]);
  }, eP;
var tP, _j;
function II() {
  if (_j) return tP;
  _j = 1;
  return tP = e, tP;
var nP, Oj;
function _H() {
  return Oj || (Oj = 1, nP = Function.call.bind(Object.prototype.hasOwnProperty)), nP;
var rP, Rj;
function kY() {
  if (Rj) return rP;
  Rj = 1;
    var t = II(), n = {}, r = _H();
  function o(s, a, c, f, h) {
          var v;
            v = s[g](a, g, f, c, null, t);
            v = T;
          if (v && !(v instanceof Error) && e(
            (f || "React class") + ": type specification of " + c + " `" + g + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof v + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), v instanceof Error && !(v.message in n)) {
            n[v.message] = !0;
            var C = h ? h() : "";
              "Failed " + c + " type: " + v.message + (C ?? "")
  }, rP = o, rP;
var oP, kj;
function PY() {
  if (kj) return oP;
  kj = 1;
  var e = TH(), t = RY(), n = II(), r = _H(), o = kY(), s = function() {
  return oP = function(c, f) {
    var h = typeof Symbol == "function" && Symbol.iterator, g = "@@iterator";
    function v(Q) {
      var V = Q && (h && Q[h] || Q[g]);
      if (typeof V == "function")
        return V;
      array: P("array"),
      bigint: P("bigint"),
      bool: P("boolean"),
      func: P("function"),
      number: P("number"),
      object: P("object"),
      string: P("string"),
      symbol: P("symbol"),
      element: A(),
      elementType: k(),
      instanceOf: j,
      node: D(),
      objectOf: H,
      oneOf: B,
      oneOfType: F,
      shape: U,
      exact: K
    function T(Q, V) {
      return Q === V ? Q !== 0 || 1 / Q === 1 / V : Q !== Q && V !== V;
    function E(Q, V) {
      this.message = Q, this.data = V && typeof V == "object" ? V : {}, this.stack = "";
        var V = {}, ie = 0;
            !V[Ce] && // Avoid spamming the console because they are often not actionable except for lib authors
            ), V[Ce] = !0, ie++);
    function P(Q) {
      function V(ie, de, ue, he, ge, fe) {
        var pe = ie[de], be = Y(pe);
      return O(V);
      function V(ie, de, ue, he, ge) {
          var pe = Y(fe);
      return O(V);
    function A() {
      function Q(V, ie, de, ue, he) {
        var ge = V[ie];
          var fe = Y(ge);
    function k() {
      function Q(V, ie, de, ue, he) {
        var ge = V[ie];
          var fe = Y(ge);
    function j(Q) {
      function V(ie, de, ue, he, ge) {
      return O(V);
    function B(Q) {
      function V(ie, de, ue, he, ge) {
      return O(V);
    function H(Q) {
      function V(ie, de, ue, he, ge) {
        var fe = ie[de], pe = Y(fe);
      return O(V);
    function F(Q) {
      for (var V = 0; V < Q.length; V++) {
        var ie = Q[V];
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(ie) + " at index " + V + "."
    function D() {
      function Q(V, ie, de, ue, he) {
        return ee(V[ie]) ? null : new E("Invalid " + ue + " `" + he + "` supplied to " + ("`" + de + "`, expected a ReactNode."));
    function q(Q, V, ie, de, ue) {
        (Q || "React class") + ": " + V + " type `" + ie + "." + de + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + ue + "`."
    function U(Q) {
      function V(ie, de, ue, he, ge) {
        var fe = ie[de], pe = Y(fe);
      return O(V);
    function K(Q) {
      function V(ie, de, ue, he, ge) {
        var fe = ie[de], pe = Y(fe);
      return O(V);
          var V = v(Q);
          if (V) {
            var ie = V.call(Q), de;
            if (V !== Q.entries) {
    function G(Q, V) {
      return Q === "symbol" ? !0 : V ? V["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && V instanceof Symbol : !1;
    function Y(Q) {
      var V = typeof Q;
      return Array.isArray(Q) ? "array" : Q instanceof RegExp ? "object" : G(V, Q) ? "symbol" : V;
      var V = Y(Q);
      if (V === "object") {
      return V;
      var V = X(Q);
      switch (V) {
          return "an " + V;
          return "a " + V;
          return V;
  }, oP;
var iP, Pj;
function MY() {
  if (Pj) return iP;
  Pj = 1;
  var e = II();
  return n.resetWarningCache = t, iP = function() {
    function r(a, c, f, h, g, v) {
      if (v !== e) {
  }, iP;
  var IY = TH(), DY = !0;
  sM.exports = PY()(IY.isElement, DY);
  sM.exports = MY()();
var AY = sM.exports;
const u = /* @__PURE__ */ vI(AY);
function NY(e) {
function DI(e) {
  } = e, r = typeof t == "function" ? (o) => t(NY(o) ? n : o) : t;
  return /* @__PURE__ */ $.jsx(yY, {
process.env.NODE_ENV !== "production" && (DI.propTypes = {
function OH(e, t) {
  const n = MT(e, t);
function $Y(e, t) {
const Mj = [];
function Gf(e) {
  return Mj[0] = e, py(Mj);
var aM = { exports: {} }, Nr = {};
var Ij;
function LY() {
  if (Ij) return Nr;
  Ij = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.consumer"), a = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), w = Symbol.for("react.view_transition"), C = Symbol.for("react.client.reference");
            case h:
                case v:
  return Nr.ContextConsumer = s, Nr.ContextProvider = a, Nr.Element = e, Nr.ForwardRef = c, Nr.Fragment = n, Nr.Lazy = v, Nr.Memo = g, Nr.Portal = t, Nr.Profiler = o, Nr.StrictMode = r, Nr.Suspense = f, Nr.SuspenseList = h, Nr.isContextConsumer = function(E) {
  }, Nr.isContextProvider = function(E) {
  }, Nr.isElement = function(E) {
  }, Nr.isForwardRef = function(E) {
  }, Nr.isFragment = function(E) {
  }, Nr.isLazy = function(E) {
    return T(E) === v;
  }, Nr.isMemo = function(E) {
  }, Nr.isPortal = function(E) {
  }, Nr.isProfiler = function(E) {
  }, Nr.isStrictMode = function(E) {
  }, Nr.isSuspense = function(E) {
  }, Nr.isSuspenseList = function(E) {
    return T(E) === h;
  }, Nr.isValidElementType = function(E) {
    return typeof E == "string" || typeof E == "function" || E === n || E === o || E === r || E === f || E === h || typeof E == "object" && E !== null && (E.$$typeof === v || E.$$typeof === g || E.$$typeof === a || E.$$typeof === s || E.$$typeof === c || E.$$typeof === C || E.getModuleId !== void 0);
  }, Nr.typeOf = T, Nr;
var $r = {};
var Dj;
function jY() {
  return Dj || (Dj = 1, process.env.NODE_ENV !== "production" && function() {
              case h:
                  case v:
    var t = Symbol.for("react.transitional.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), c = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), C = Symbol.for("react.view_transition"), T = Symbol.for("react.client.reference");
    $r.ContextConsumer = a, $r.ContextProvider = c, $r.Element = t, $r.ForwardRef = f, $r.Fragment = r, $r.Lazy = w, $r.Memo = v, $r.Portal = n, $r.Profiler = s, $r.StrictMode = o, $r.Suspense = h, $r.SuspenseList = g, $r.isContextConsumer = function(E) {
    }, $r.isContextProvider = function(E) {
    }, $r.isElement = function(E) {
    }, $r.isForwardRef = function(E) {
    }, $r.isFragment = function(E) {
    }, $r.isLazy = function(E) {
    }, $r.isMemo = function(E) {
      return e(E) === v;
    }, $r.isPortal = function(E) {
    }, $r.isProfiler = function(E) {
    }, $r.isStrictMode = function(E) {
    }, $r.isSuspense = function(E) {
      return e(E) === h;
    }, $r.isSuspenseList = function(E) {
    }, $r.isValidElementType = function(E) {
      return typeof E == "string" || typeof E == "function" || E === r || E === s || E === o || E === h || E === g || typeof E == "object" && E !== null && (E.$$typeof === w || E.$$typeof === v || E.$$typeof === c || E.$$typeof === a || E.$$typeof === f || E.$$typeof === T || E.getModuleId !== void 0);
    }, $r.typeOf = e;
  }()), $r;
}
process.env.NODE_ENV === "production" ? aM.exports = LY() : aM.exports = jY();
var wu = aM.exports;
function hc(e) {
function RH(e) {
  if (/* @__PURE__ */ x.isValidElement(e) || wu.isValidElementType(e) || !hc(e))
    t[n] = RH(e[n]);
function Ri(e, t, n = {
  return hc(e) && hc(t) && Object.keys(t).forEach((o) => {
    /* @__PURE__ */ x.isValidElement(t[o]) || wu.isValidElementType(t[o]) ? r[o] = t[o] : hc(t[o]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, o) && hc(e[o]) ? r[o] = Ri(e[o], t[o], n) : n.clone ? r[o] = hc(t[o]) ? RH(t[o]) : t[o] : r[o] = t[o];
const FY = (e) => {
function zY(e) {
  } = e, s = FY(t), a = Object.keys(s);
  function h(w, C) {
    return a.indexOf(w) + 1 < a.length ? h(w, a[a.indexOf(w) + 1]) : c(w);
  function v(w) {
    return C === 0 ? c(a[1]) : C === a.length - 1 ? f(a[C]) : h(w, a[a.indexOf(w) + 1]).replace("@media", "@media not all and");
    between: h,
    not: v,
function Aj(e, t) {
function BY(e, t) {
function HY(e, t) {
For example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.` : wc(18, `(${t})`));
function VY(e) {
const UY = {
}, sp = process.env.NODE_ENV !== "production" ? u.oneOfType([u.number, u.string, u.object, u.array]) : {};
function bS(e, t) {
  return t ? Ri(e, t, {
const P_ = {
}, Nj = {
  up: (e) => `@media (min-width:${P_[e]}px)`
}, WY = {
      let n = typeof t == "number" ? t : P_[t] || t;
function fa(e, t, n) {
    const s = r.breakpoints || Nj;
    const s = r.breakpoints || Nj;
      if (BY(s.keys, c)) {
        const f = HY(r.containerQueries ? r : WY, c);
      } else if (Object.keys(s.values || P_).includes(c)) {
function kH(e = {}) {
function lM(e, t) {
function GY(e, ...t) {
  const n = kH(e), r = [n, ...t].reduce((o, s) => Ri(o, s), {});
  return lM(Object.keys(n), r);
function qY(e, t) {
function em({
  const r = n || qY(e, t), o = Object.keys(r);
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : wc(7));
function M_(e, t, n = !0) {
function IT(e, t, n, r = n) {
  return typeof e == "function" ? o = e(n) : Array.isArray(e) ? o = e[n] || r : o = M_(e, n) || r, t && (o = t(o, r, e)), o;
function zo(e) {
    const c = a[t], f = a.theme, h = M_(f, r) || {};
    return fa(a, c, (v) => {
      let w = IT(h, o, v);
      return v === w && typeof v == "string" && (w = IT(h, o, `${t}${v === "default" ? "" : He(v)}`, v)), n === !1 ? w : {
    [t]: sp
function KY(e) {
const YY = {
}, XY = {
}, $j = {
}, QY = KY((e) => {
    if ($j[e])
      e = $j[e];
  const [t, n] = e.split(""), r = YY[t], o = XY[n] || "";
}), I_ = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], D_ = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], JY = [...I_, ...D_];
function fC(e, t, n, r) {
  const o = M_(e, t, !0) ?? n;
function A_(e) {
  return fC(e, "spacing", 8, "spacing");
function um(e, t) {
function ZY(e, t) {
  return (n) => e.reduce((r, o) => (r[o] = um(t, n), r), {});
function eX(e, t, n, r) {
  const o = QY(n), s = ZY(o, r), a = e[n];
  return fa(e, a, s);
function PH(e, t) {
  const n = A_(e.theme);
  return Object.keys(e).map((r) => eX(e, t, r, n)).reduce(bS, {});
function _o(e) {
  return PH(e, I_);
_o.propTypes = process.env.NODE_ENV !== "production" ? I_.reduce((e, t) => (e[t] = sp, e), {}) : {};
_o.filterProps = I_;
function Oo(e) {
  return PH(e, D_);
Oo.propTypes = process.env.NODE_ENV !== "production" ? D_.reduce((e, t) => (e[t] = sp, e), {}) : {};
Oo.filterProps = D_;
process.env.NODE_ENV !== "production" && JY.reduce((e, t) => (e[t] = sp, e), {});
function MH(e = 8, t = A_({
function N_(...e) {
  }), r), {}), n = (r) => Object.keys(r).reduce((o, s) => t[s] ? bS(o, t[s](r)) : o, {});
function gl(e) {
function Pl(e, t) {
  return zo({
const tX = Pl("border", gl), nX = Pl("borderTop", gl), rX = Pl("borderRight", gl), oX = Pl("borderBottom", gl), iX = Pl("borderLeft", gl), sX = Pl("borderColor"), aX = Pl("borderTopColor"), lX = Pl("borderRightColor"), uX = Pl("borderBottomColor"), cX = Pl("borderLeftColor"), dX = Pl("outline", gl), fX = Pl("outlineColor"), $_ = (e) => {
    const t = fC(e.theme, "shape.borderRadius", 4, "borderRadius"), n = (r) => ({
      borderRadius: um(t, r)
    return fa(e, e.borderRadius, n);
$_.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: sp
$_.filterProps = ["borderRadius"];
N_(tX, nX, rX, oX, iX, sX, aX, lX, uX, cX, $_, dX, fX);
const L_ = (e) => {
    const t = fC(e.theme, "spacing", 8, "gap"), n = (r) => ({
      gap: um(t, r)
    return fa(e, e.gap, n);
L_.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: sp
L_.filterProps = ["gap"];
const j_ = (e) => {
    const t = fC(e.theme, "spacing", 8, "columnGap"), n = (r) => ({
      columnGap: um(t, r)
    return fa(e, e.columnGap, n);
j_.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: sp
j_.filterProps = ["columnGap"];
const F_ = (e) => {
    const t = fC(e.theme, "spacing", 8, "rowGap"), n = (r) => ({
      rowGap: um(t, r)
    return fa(e, e.rowGap, n);
F_.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: sp
F_.filterProps = ["rowGap"];
const pX = zo({
}), hX = zo({
}), mX = zo({
}), gX = zo({
}), vX = zo({
}), yX = zo({
}), bX = zo({
}), wX = zo({
}), SX = zo({
N_(L_, j_, F_, pX, hX, mX, gX, vX, yX, bX, wX, SX);
function $v(e, t) {
const CX = zo({
  transform: $v
}), xX = zo({
  transform: $v
}), EX = zo({
  transform: $v
N_(CX, xX, EX);
function Ia(e) {
const TX = zo({
  transform: Ia
}), AI = (e) => {
      const r = ((a = (s = (o = e.theme) == null ? void 0 : o.breakpoints) == null ? void 0 : s.values) == null ? void 0 : a[n]) || P_[n];
        maxWidth: Ia(n)
    return fa(e, e.maxWidth, t);
AI.filterProps = ["maxWidth"];
const _X = zo({
  transform: Ia
}), OX = zo({
  transform: Ia
}), RX = zo({
  transform: Ia
}), kX = zo({
  transform: Ia
zo({
  transform: Ia
zo({
  transform: Ia
const PX = zo({
N_(TX, AI, _X, OX, RX, kX, PX);
const pC = {
    transform: gl
    transform: gl
    transform: gl
    transform: gl
    transform: gl
    transform: gl
    style: $_
    transform: $v
    transform: $v
    transform: $v
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: Oo
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: _o
    style: L_
    style: F_
    style: j_
    transform: Ia
    style: AI
    transform: Ia
    transform: Ia
    transform: Ia
    transform: Ia
function MX(...e) {
function IX(e, t) {
function DX() {
      themeKey: h,
      style: v
    if (h === "typography" && r === "inherit")
    const w = M_(o, h) || {};
    return v ? v(a) : fa(a, r, (T) => {
      let E = IT(w, g, T);
      return T === E && typeof T == "string" && (E = IT(w, g, `${n}${T === "default" ? "" : He(T)}`, T)), f === !1 ? E : {
    const a = o.unstable_sxConfig ?? pC;
      let h = f;
        h = f(o);
      if (!h)
      const g = kH(o.breakpoints), v = Object.keys(g);
      return Object.keys(h).forEach((C) => {
        const T = IX(h[C], o);
              w = bS(w, e(C, T, o, a));
              const E = fa({
              MX(E, T) ? w[C] = t({
              }) : w = bS(w, E);
            w = bS(w, e(C, T, o, a));
        "@layer sx": Aj(o, lM(v, w))
      } : Aj(o, lM(v, w));
const Zf = DX();
Zf.filterProps = ["sx"];
function AX(e, t) {
function hy(e = {}, ...t) {
  } = e, c = zY(n), f = MH(o);
  let h = Ri({
      ...UY,
  return h = VY(h), h.applyStyles = AX, h = t.reduce((g, v) => Ri(g, v), h), h.unstable_sxConfig = {
    ...pC,
  }, h.unstable_sx = function(v) {
    return Zf({
      sx: v,
  }, h;
function NX(e) {
function NI(e = null) {
  const t = x.useContext(dC);
  return !t || NX(t) ? e : t;
const $X = hy();
function hC(e = $X) {
  return NI(e);
function sP(e) {
  const t = Gf(e);
function $I({
  const r = hC(n), o = t && r[t] || r;
  return o.modularCssLayers && (Array.isArray(s) ? s = s.map((a) => sP(typeof a == "function" ? a(o) : a)) : s = sP(s)), /* @__PURE__ */ $.jsx(DI, {
process.env.NODE_ENV !== "production" && ($I.propTypes = {
const LX = (e) => {
  }, n = ((r = e == null ? void 0 : e.theme) == null ? void 0 : r.unstable_sxConfig) ?? pC;
function mC(e) {
  } = LX(n);
    return hc(c) ? {
const Lj = (e) => e, jX = () => {
  let e = Lj;
      e = Lj;
}, IH = jX();
function DH(e) {
    for (t = 0; t < o; t++) e[t] && (n = DH(e[t])) && (r && (r += " "), r += n);
  for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = DH(e)) && (r && (r += " "), r += t);
function FX(e = {}) {
  } = e, s = OH("div", {
  })(Zf);
  return /* @__PURE__ */ x.forwardRef(function(f, h) {
    const g = hC(n), {
      className: v,
    } = mC(f);
      ref: h,
      className: et(v, o ? o(r) : r),
const zX = {
function ln(e, t, n = "Mui") {
  const r = zX[t];
  return r ? `${n}-${r}` : `${IH.generate(e)}-${t}`;
function fn(e, t, n = "Mui") {
    r[o] = ln(e, o, n);
function AH(e, t = "") {
function jj(e, t, n) {
  const r = AH(t);
function BX(e) {
      return AH(e, "Component");
        case wu.ForwardRef:
          return jj(e, e.render, "ForwardRef");
        case wu.Memo:
          return jj(e, e.type, "memo");
function NH(e) {
    style: Gf(n),
    typeof o.style != "function" && (o.style = Gf(o.style));
const HX = hy();
function aP(e) {
function Kh(e, t) {
function VX(e) {
function UX(e, t, n) {
  e.theme = qX(e.theme) ? n : e.theme[t] || e.theme;
function mT(e, t, n) {
    return r.flatMap((o) => mT(e, o, n));
      o = n ? Kh(r.style, n) : r.style;
      o = n ? Kh(Gf(a), n) : a;
    return $H(e, r.variants, [o], n);
  return r != null && r.isProcessed ? n ? Kh(Gf(r.style), n) : r.style : n ? Kh(Gf(r), n) : r;
function $H(e, t, n = [], r = void 0) {
    }), n.push(r ? Kh(Gf(c.style(o)), r) : c.style(o))) : n.push(r ? Kh(Gf(c.style), r) : c.style);
function LH(e = {}) {
    defaultTheme: n = HX,
    rootShouldForwardProp: r = aP,
    slotShouldForwardProp: o = aP
    UX(c, t, n);
    $Y(c, (j) => j.filter((B) => B !== Zf));
      name: h,
      skipVariantsResolver: v,
      overridesResolver: C = VX(jH(g)),
    } = f, E = h && h.startsWith("Mui") || g ? "components" : "custom", O = v !== void 0 ? v : (
    ), P = w || !1;
    let I = aP;
    g === "Root" || g === "root" ? I = r : g ? I = o : KX(c) && (I = void 0);
    const M = OH(c, {
      label: GX(h, g),
    }), A = (j) => {
      if (j.__emotion_real === j)
        return j;
      if (typeof j == "function")
        return function(H) {
          return mT(H, j, H.theme.modularCssLayers ? E : void 0);
      if (hc(j)) {
        const B = NH(j);
        return function(F) {
          return B.variants ? mT(F, B, F.theme.modularCssLayers ? E : void 0) : F.theme.modularCssLayers ? Kh(B.style, E) : B.style;
      return j;
    }, k = (...j) => {
      const B = [], H = j.map(A), F = [];
      if (B.push(s), h && C && F.push(function(K) {
        const G = (te = (X = K.theme.components) == null ? void 0 : X[h]) == null ? void 0 : te.styleOverrides;
        const Y = {};
          Y[re] = mT(K, G[re], K.theme.modularCssLayers ? "theme" : void 0);
        return C(K, Y);
      }), h && !O && F.push(function(K) {
        var Y, X;
        const ee = K.theme, G = (X = (Y = ee == null ? void 0 : ee.components) == null ? void 0 : Y[h]) == null ? void 0 : X.variants;
        return G ? $H(K, G, [], K.theme.modularCssLayers ? "theme" : void 0) : null;
      }), P || F.push(Zf), Array.isArray(H[0])) {
        const U = H.shift(), K = new Array(B.length).fill(""), ee = new Array(F.length).fill("");
        G = [...K, ...U, ...ee], G.raw = [...K, ...U.raw, ...ee], B.unshift(G);
      const D = [...B, ...H, ...F], q = M(...D);
      return c.muiName && (q.muiName = c.muiName), process.env.NODE_ENV !== "production" && (q.displayName = WX(h, g, c)), q;
    return M.withConfig && (k.withConfig = M.withConfig), k;
function WX(e, t, n) {
  return e ? `${e}${He(t || "")}` : `Styled(${BX(n)})`;
function GX(e, t) {
  return process.env.NODE_ENV !== "production" && e && (n = `${e}-${jH(t || "Root")}`), n;
function qX(e) {
function KX(e) {
function jH(e) {
const LI = LH();
function Wv(e, t) {
              n[o][f] = Wv(s[f], a[f]);
function YX(e) {
  return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : Wv(t.components[n].defaultProps, r);
function jI({
  let o = hC(n);
  return r && (o = o[r] || o), YX({
const Lr = typeof window < "u" ? x.useLayoutEffect : x.useEffect;
function XX(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
function FI(e, t = 0, n = 1) {
  return process.env.NODE_ENV !== "production" && (e < t || e > n) && console.error(`MUI: The value provided ${e} is out of range [${t}, ${n}].`), XX(e, t, n);
function QX(e) {
function Sc(e) {
    return Sc(QX(e));
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : wc(9, e));
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : wc(10, o));
const JX = (e) => {
  const t = Sc(e);
}, sS = (e, t) => {
    return JX(e);
function gC(e) {
function FH(e) {
  e = Sc(e);
  } = e, n = t[0], r = t[1] / 100, o = t[2] / 100, s = r * Math.min(o, 1 - o), a = (h, g = (h + n / 30) % 12) => o - s * Math.max(Math.min(g - 3, 9 - g, 1), -1);
  return e.type === "hsla" && (c += "a", f.push(t[3])), gC({
function uM(e) {
  e = Sc(e);
  let t = e.type === "hsl" || e.type === "hsla" ? Sc(FH(e)).values : e.values;
function Fj(e, t) {
  const n = uM(e), r = uM(t);
function rn(e, t) {
  return e = Sc(e), t = FI(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, gC(e);
function NE(e, t, n) {
    return rn(e, t);
function ep(e, t) {
  if (e = Sc(e), t = FI(t), e.type.includes("hsl"))
  return gC(e);
function Hr(e, t, n) {
    return ep(e, t);
function tp(e, t) {
  if (e = Sc(e), t = FI(t), e.type.includes("hsl"))
  return gC(e);
function Vr(e, t, n) {
    return tp(e, t);
function ZX(e, t = 0.15) {
  return uM(e) > 0.5 ? ep(e, t) : tp(e, t);
function $E(e, t, n) {
    return ZX(e, t);
function ja(e, t) {
function eQ(e) {
function zH(e, t, n, r, o) {
  return typeof f == "function" && !eQ(f) && (c = "Did you accidentally use a plain function component for an element instead?"), c !== void 0 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an element that can hold a ref. ${c} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
const ap = ja(u.element, zH);
ap.isRequired = ja(u.element.isRequired, zH);
function tQ(e) {
function nQ(e, t, n, r, o) {
  return typeof s == "function" && !tQ(s) && (c = "Did you accidentally provide a plain function component instead?"), c !== void 0 ? new Error(`Invalid ${r} \`${a}\` supplied to \`${n}\`. Expected an element type that can hold a ref. ${c} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
const zI = ja(u.elementType, nQ), rQ = "exact-prop: ";
function vC(e) {
    [rQ]: (t) => {
function Tl(e, t, n, r, o) {
const pa = u.oneOfType([u.func, u.object]);
function zj(...e) {
function BI(e, t = 166) {
function gT(e, t) {
function go(e) {
function _l(e) {
  return go(e).defaultView || window;
function BH(e, t) {
  return (o) => (s, a, c, f, h, ...g) => {
    const v = h || a, w = n == null ? void 0 : n[v];
      const C = w(s, a, c, f, h, ...g);
    return typeof s[a] < "u" && !s[o] ? new Error(`The prop \`${v}\` of \`${e}\` can only be used together with the \`${o}\` prop.`) : null;
function cM(e, t) {
let Bj = 0;
function oQ(e) {
    t == null && (Bj += 1, n(`mui-${Bj}`));
const iQ = {
  ...RT
}, Hj = iQ.useId;
function mr(e) {
  if (Hj !== void 0) {
    const t = Hj();
  return oQ(e);
function sQ(e, t, n, r, o) {
function tm({
      current: h
      !o && !Object.is(h, t) && console.error([`MUI: A component is changing the default ${r} state of an uncontrolled ${n} after being initialized. To suppress this warning opt to use a controlled ${n}.`].join(`
  const f = x.useCallback((h) => {
    o || a(h);
function Fn(e) {
  return Lr(() => {
function Ir(...e) {
const Vj = {};
function Ml(e, t) {
  const n = x.useRef(Vj);
  return n.current === Vj && (n.current = e(t)), n;
const aQ = [];
function HI(e) {
  x.useEffect(e, aQ);
class z_ {
    Nn(this, "currentId", null);
    Nn(this, "clear", () => {
    Nn(this, "disposeEffect", () => this.clear);
    return new z_();
function Aa() {
  const e = Ml(z_.create).current;
  return HI(e.disposeEffect), e;
function DT(e) {
function HH(e = window) {
const VI = (e) => {
function lQ(e) {
function VH(e, t, n, r) {
    const s = lQ(o);
function UH(e, t, ...n) {
  return e[t] === void 0 ? null : VH(e, t, ...n);
function dM() {
UH.isRequired = VH;
dM.isRequired = dM;
const nm = process.env.NODE_ENV === "production" ? dM : UH;
      const h = s[f];
      h && (a += (c === !0 ? "" : " ") + t(h), c = !1, n && n[h] && (a += " " + n[h]));
function uQ(e) {
function WH(e, t, n) {
  return e === void 0 || uQ(e) ? t : {
function GH(e, t = []) {
function Uj(e) {
function qH(e) {
  const a = GH({
  }), c = Uj(r), f = Uj(o), h = t(a), g = et(h == null ? void 0 : h.className, n == null ? void 0 : n.className, s, o == null ? void 0 : o.className, r == null ? void 0 : r.className), v = {
    ...h == null ? void 0 : h.style,
    ...h,
  return g.length > 0 && (w.className = g), Object.keys(v).length > 0 && (w.style = v), {
    internalRef: h.ref
function KH(e, t, n) {
function YH(e) {
  var v;
  } = e, a = o ? {} : KH(n, r), {
  } = qH({
  }), h = Ir(f, a == null ? void 0 : a.ref, (v = e.additionalProps) == null ? void 0 : v.ref);
  return WH(t, {
    ref: h
function lp(e) {
const UI = /* @__PURE__ */ x.createContext(null);
process.env.NODE_ENV !== "production" && (UI.displayName = "ThemeContext");
function WI() {
  const e = x.useContext(UI);
const cQ = typeof Symbol == "function" && Symbol.for, dQ = cQ ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function fQ(e, t) {
function AT(e) {
  } = e, r = WI();
    } : fQ(r, n);
    return s != null && (s[dQ] = r !== null), s;
  return /* @__PURE__ */ $.jsx(UI.Provider, {
process.env.NODE_ENV !== "production" && (AT.propTypes = {
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (AT.propTypes = vC(AT.propTypes));
const XH = /* @__PURE__ */ x.createContext();
function QH({
  return /* @__PURE__ */ $.jsx(XH.Provider, {
process.env.NODE_ENV !== "production" && (QH.propTypes = {
const my = () => x.useContext(XH) ?? !1, JH = /* @__PURE__ */ x.createContext(void 0);
function ZH({
  return /* @__PURE__ */ $.jsx(JH.Provider, {
process.env.NODE_ENV !== "production" && (ZH.propTypes = {
function pQ(e) {
  return o.defaultProps ? Wv(o.defaultProps, r) : !o.styleOverrides && !o.variants ? Wv(o, r) : r;
function hQ({
  const n = x.useContext(JH);
  return pQ({
function mQ(e) {
  const t = NI(), n = mr() || "", {
  return !r || t !== null ? o = "" : typeof r == "string" ? o = r.replace(/mui(?!\.)/g, o) : o = `@layer ${o};`, Lr(() => {
      const h = document.createElement("style");
      h.setAttribute("data-mui-layer-order", n), h.textContent = o, s.prepend(h);
  }, [o, n]), o ? /* @__PURE__ */ $.jsx($I, {
const Wj = {};
function Gj(e, t, n, r = !1) {
function HS(e) {
  } = e, o = NI(Wj), s = WI() || Wj;
  const a = Gj(r, o, n), c = Gj(r, s, n, !0), f = (r ? a[r] : a).direction === "rtl", h = mQ(a);
  return /* @__PURE__ */ $.jsx(AT, {
    children: /* @__PURE__ */ $.jsx(dC.Provider, {
      children: /* @__PURE__ */ $.jsx(QH, {
        children: /* @__PURE__ */ $.jsxs(ZH, {
          children: [h, t]
process.env.NODE_ENV !== "production" && (HS.propTypes = {
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (HS.propTypes = vC(HS.propTypes));
const qj = {
function gQ(e) {
    return (s === void 0 || o.theme !== n) && (qj.theme = o.theme, s = NH(e(qj)), t = s, n = o.theme), s;
const GI = "mode", qI = "color-scheme", vQ = "data-color-scheme";
function yQ(e) {
    modeStorageKey: o = GI,
    colorSchemeStorageKey: s = qI,
    attribute: a = vQ,
  let h = "", g = a;
    h += `${c}.classList.remove('${w}'.replace('%s', light), '${w}'.replace('%s', dark));
  const v = g.match(/\[([^\]]+)\]/);
  if (v) {
    const [w, C] = v[1].split("=");
    C || (h += `${c}.removeAttribute('${w}'.replace('%s', light));
      ${c}.removeAttribute('${w}'.replace('%s', dark));`), h += `
    h += `${c}.setAttribute('${g}', colorScheme);`;
    ${h}
function bQ() {
const wQ = ({
      return bQ;
function lP() {
function Kj(e) {
function eV(e, t) {
function SQ(e) {
  return eV(e, (t) => {
function CQ(e) {
    modeStorageKey: s = GI,
    colorSchemeStorageKey: a = qI,
    storageManager: f = wQ,
    noSsr: h = !1
  } = e, g = o.join(","), v = o.length > 1, w = x.useMemo(() => f == null ? void 0 : f({
    const H = (w == null ? void 0 : w.get(t)) || t, F = (C == null ? void 0 : C.get(n)) || n, D = (T == null ? void 0 : T.get(r)) || r;
      mode: H,
      systemMode: Kj(H),
      lightColorScheme: F,
      darkColorScheme: D
  }), [P, I] = x.useState(h || !v);
  const M = SQ(E), A = x.useCallback((H) => {
    O((F) => {
      if (H === F.mode)
        return F;
      const D = H ?? t;
      return w == null || w.set(D), {
        ...F,
        mode: D,
        systemMode: Kj(D)
  }, [w, t]), k = x.useCallback((H) => {
    H ? typeof H == "string" ? H && !g.includes(H) ? console.error(`\`${H}\` does not exist in \`theme.colorSchemes\`.`) : O((F) => {
      const D = {
        ...F
      return eV(F, (q) => {
        q === "light" && (C == null || C.set(H), D.lightColorScheme = H), q === "dark" && (T == null || T.set(H), D.darkColorScheme = H);
      }), D;
    }) : O((F) => {
      const D = {
        ...F
      }, q = H.light === null ? n : H.light, U = H.dark === null ? r : H.dark;
      return q && (g.includes(q) ? (D.lightColorScheme = q, C == null || C.set(q)) : console.error(`\`${q}\` does not exist in \`theme.colorSchemes\`.`)), U && (g.includes(U) ? (D.darkColorScheme = U, T == null || T.set(U)) : console.error(`\`${U}\` does not exist in \`theme.colorSchemes\`.`)), D;
    }) : O((F) => (C == null || C.set(n), T == null || T.set(r), {
      ...F,
  }, [g, C, T, n, r]), j = x.useCallback((H) => {
    E.mode === "system" && O((F) => {
      const D = H != null && H.matches ? "dark" : "light";
      return F.systemMode === D ? F : {
        ...F,
        systemMode: D
  }, [E.mode]), B = x.useRef(j);
  return B.current = j, x.useEffect(() => {
    if (typeof window.matchMedia != "function" || !v)
    const H = (...D) => B.current(...D), F = window.matchMedia("(prefers-color-scheme: dark)");
    return F.addListener(H), H(F), () => {
      F.removeListener(H);
  }, [v]), x.useEffect(() => {
    if (v) {
      const H = (w == null ? void 0 : w.subscribe((q) => {
        (!q || ["light", "dark", "system"].includes(q)) && A(q || t);
      })) || lP, F = (C == null ? void 0 : C.subscribe((q) => {
        (!q || g.match(q)) && k({
      })) || lP, D = (T == null ? void 0 : T.subscribe((q) => {
        (!q || g.match(q)) && k({
      })) || lP;
        H(), F(), D();
  }, [k, A, g, t, c, v, w, C, T]), {
    mode: P ? E.mode : void 0,
    systemMode: P ? E.systemMode : void 0,
    colorScheme: P ? M : void 0,
    setMode: A,
    setColorScheme: k
const xQ = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function EQ(e) {
    modeStorageKey: r = GI,
    colorSchemeStorageKey: o = qI,
  }, h = /* @__PURE__ */ x.createContext(void 0);
  process.env.NODE_ENV !== "production" && (h.displayName = "ColorSchemeContext");
  const g = () => x.useContext(h) || f, v = {}, w = {};
  function C(P) {
      modeStorageKey: A = r,
      colorSchemeStorageKey: k = o,
      disableTransitionOnChange: j = s,
      storageManager: B,
      storageWindow: H = typeof window > "u" ? void 0 : window,
      documentNode: F = typeof document > "u" ? void 0 : document,
      colorSchemeNode: D = typeof document > "u" ? void 0 : document.documentElement,
      disableStyleSheetGeneration: U = !1,
      defaultMode: K = "system",
    } = P, G = x.useRef(!1), Y = WI(), X = x.useContext(h), te = !!X && !q, re = x.useMemo(() => M || (typeof n == "function" ? n() : n), [M]), Q = re[t], V = Q || re, {
      colorSchemes: ie = v,
    } = V, he = Object.keys(ie).filter((vt) => !!ie[vt]).join(","), ge = x.useMemo(() => he.split(","), [he]), fe = typeof a == "string" ? a : a.light, pe = typeof a == "string" ? a : a.dark, be = ie[fe] && ie[pe] ? K : ((Et = (ut = ie[V.defaultColorScheme]) == null ? void 0 : ut.palette) == null ? void 0 : Et.mode) || ((Tt = V.palette) == null ? void 0 : Tt.mode), {
    } = CQ({
      modeStorageKey: A,
      colorSchemeStorageKey: k,
      storageManager: B,
      storageWindow: H,
    let Le = we, rt = Be;
    te && (Le = X.mode, rt = X.colorScheme);
      const vt = rt || V.defaultColorScheme, Xe = ((Ie = V.generateThemeVars) == null ? void 0 : Ie.call(V)) || V.vars, Oe = {
        ...V,
    }, [V, rt, de, ie, ue]), wt = V.colorSchemeSelector;
    Lr(() => {
      if (rt && D && wt && wt !== "media") {
          D.classList.remove(...ge.map((Oe) => Xe.substring(1).replace("%s", Oe))), D.classList.add(Xe.substring(1).replace("%s", rt));
              D.removeAttribute(Ie.replace(rt, yt));
            }), D.setAttribute(Ie, pt ? pt.replace(/"|'/g, "") : "");
            D.setAttribute(Xe, rt);
    }, [rt, wt, D, ge]), x.useEffect(() => {
      if (j && G.current && F) {
        const Xe = F.createElement("style");
        Xe.appendChild(F.createTextNode(xQ)), F.head.appendChild(Xe), window.getComputedStyle(F.body), vt = setTimeout(() => {
          F.head.removeChild(Xe);
    }, [rt, j, F]), x.useEffect(() => (G.current = !0, () => {
      mode: Le,
    }), [ge, rt, Ne, Ce, Le, tt, _e, ce, ot.colorSchemeSelector]);
    (U || V.cssVariables === !1 || te && (Y == null ? void 0 : Y.cssVarPrefix) === ue) && (nt = !1);
      children: [/* @__PURE__ */ $.jsx(HS, {
      }), nt && /* @__PURE__ */ $.jsx(DI, {
    return te ? Ft : /* @__PURE__ */ $.jsx(h.Provider, {
    getInitColorSchemeScript: (P) => yQ({
      ...P
function TQ(e = "") {
const Yj = (e, t, n, r = []) => {
}, _Q = (e, t, n) => {
}, OQ = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function uP(e, t) {
  return _Q(
    (c, f, h) => {
        const g = `--${n ? `${n}-` : ""}${c.join("-")}`, v = OQ(c, f);
          [g]: v
        }), Yj(s, c, `var(${g})`, h), Yj(a, c, `var(${g}, ${v})`, h);
function RQ(e, t = {}) {
    vars: h,
    varsWithDefaults: v
  } = uP(f, t);
  let w = v;
  if (Object.entries(E || {}).forEach(([M, A]) => {
      vars: k,
      css: j,
      varsWithDefaults: B
    } = uP(A, t);
    w = Ri(w, B), C[M] = {
      css: j,
      vars: k
      vars: A,
      varsWithDefaults: k
    } = uP(T, t);
    w = Ri(w, k), C[c] = {
      vars: A
  function O(M, A) {
    var j, B;
    let k = o;
    if (o === "class" && (k = ".%s"), o === "data" && (k = "[data-%s]"), o != null && o.startsWith("data-") && !o.includes("%s") && (k = `[${o}="%s"]`), M) {
      if (k === "media")
          [`@media (prefers-color-scheme: ${((B = (j = s[M]) == null ? void 0 : j.palette) == null ? void 0 : B.mode) || M})`]: {
            ":root": A
      if (k)
        return e.defaultColorScheme === M ? `:root, ${k.replace("%s", String(M))}` : k.replace("%s", String(M));
        ...h
        vars: A
        M = Ri(M, A);
      var H, F;
      const M = [], A = e.defaultColorScheme || "light";
      function k(D, q) {
        Object.keys(q).length && M.push(typeof D == "string" ? {
          [D]: {
        } : D);
      k(n(void 0, {
        [A]: j,
        ...B
      if (j) {
          css: D
        } = j, q = (F = (H = s[A]) == null ? void 0 : H.palette) == null ? void 0 : F.mode, U = !r && q ? {
          ...D
          ...D
        k(n(A, {
          ...U
        }), U);
      return Object.entries(B).forEach(([D, {
        const U = (G = (ee = s[D]) == null ? void 0 : ee.palette) == null ? void 0 : G.mode, K = !r && U ? {
          colorScheme: U,
        k(n(D, {
          ...K
        }), K);
function kQ(e) {
const PQ = hy(), MQ = LI("div", {
}), IQ = (e) => jI({
  defaultTheme: PQ
}), DQ = (e, t) => {
  const n = (f) => ln(t, f), {
function AQ(e = {}) {
    createStyledComponent: t = MQ,
    useThemeProps: n = IQ,
  }) => c.fixed && Object.keys(a.breakpoints.values).reduce((f, h) => {
    const g = h, v = a.breakpoints.values[g];
    return v !== 0 && (f[a.breakpoints.up(g)] = {
      maxWidth: `${v}${a.breakpoints.unit}`
    const h = n(c), {
      component: v = "div",
    } = h, P = {
      ...h,
      component: v,
    }, I = DQ(P, r);
        as: v,
        ownerState: P,
const NQ = (e, t) => e.filter((n) => t.includes(n)), gy = (e, t, n) => {
  }) : t && typeof t == "object" ? (Object.keys(t).length > e.keys.length ? e.keys : NQ(e.keys, Object.keys(t))).forEach((s) => {
function NT(e) {
function B_(e) {
const Xj = "--Grid-columns", Lv = "--Grid-parent-columns", $Q = ({
  return gy(e.breakpoints, t.size, (r, o) => {
      width: `calc(100% * ${o} / var(${Lv}) - (var(${Lv}) - ${o}) * (var(${B_("column")}) / var(${Lv})))`
}, LQ = ({
  return gy(e.breakpoints, t.offset, (r, o) => {
      marginLeft: o === 0 ? "0px" : `calc(100% * ${o} / var(${Lv}) + var(${B_("column")}) * ${o} / var(${Lv}))`
}, jQ = ({
    [Xj]: 12
  return gy(e.breakpoints, t.columns, (r, o) => {
      [Xj]: s,
        [Lv]: s
}, FQ = ({
  return gy(e.breakpoints, t.rowSpacing, (r, o) => {
      [NT("row")]: s,
        [B_("row")]: s
}, zQ = ({
  return gy(e.breakpoints, t.columnSpacing, (r, o) => {
      [NT("column")]: s,
        [B_("column")]: s
}, BQ = ({
  return gy(e.breakpoints, t.direction, (r, o) => {
}, HQ = ({
    gap: `var(${NT("row")}) var(${NT("column")})`
}), VQ = (e) => {
}, UQ = (e, t = "xs") => {
}, WQ = (e) => e === void 0 ? [] : typeof e == "object" ? Object.entries(e).map(([t, n]) => `direction-${t}-${n}`) : [`direction-xs-${String(e)}`], GQ = (e) => ["item", "zeroMinWidth"].includes(e) ? `The \`${e}\` prop has been removed and is no longer necessary. You can safely remove it.` : `The \`${e}\` prop has been removed. See https://v6.mui.com/material-ui/migration/upgrade-to-grid-v2/ for migration instructions.`, Qj = [];
function qQ(e, t) {
    Qj.includes(r) || (Qj.push(r), console.warn(`MUI Grid2: ${GQ(r)}
const KQ = hy(), YQ = LI("div", {
function XQ(e) {
  return jI({
    defaultTheme: KQ
function QQ(e = {}) {
    createStyledComponent: t = YQ,
    useThemeProps: n = XQ,
    useTheme: r = hC,
  } = e, s = (h, g) => {
      container: v,
    } = h, O = {
      root: ["root", v && "container", T !== "wrap" && `wrap-xs-${String(T)}`, ...WQ(w), ...VQ(E), ...v ? UQ(C, g.breakpoints.keys[0]) : []]
    return mt(O, (P) => ln(o, P), {});
  function a(h, g, v = () => !0) {
    return h === null || (Array.isArray(h) ? h.forEach((C, T) => {
      C !== null && v(C) && g.keys[T] && (w[g.keys[T]] = C);
    }) : typeof h == "object" ? Object.keys(h).forEach((C) => {
      const T = h[C];
      T != null && v(T) && (w[C] = T);
    }) : w[g.keys[0]] = h), w;
  }
  const c = t(jQ, zQ, FQ, $Q, BQ, HQ, LQ), f = /* @__PURE__ */ x.forwardRef(function(g, v) {
    const w = r(), C = n(g), T = mC(C);
    qQ(T, w.breakpoints);
      columns: P = 12,
      direction: A = "row",
      wrap: k = "wrap",
      size: j = {},
      offset: B = {},
      spacing: H = 0,
      rowSpacing: F = H,
      columnSpacing: D = H,
      ...U
    } = T, K = a(j, w.breakpoints, (V) => V !== !1), ee = a(B, w.breakpoints), G = g.columns ?? (q ? void 0 : P), Y = g.spacing ?? (q ? void 0 : H), X = g.rowSpacing ?? g.spacing ?? (q ? void 0 : F), te = g.columnSpacing ?? g.spacing ?? (q ? void 0 : D), re = {
      direction: A,
      wrap: k,
      spacing: Y,
      size: K,
      ref: v,
      ...U,
      children: x.Children.map(O, (V) => {
        return /* @__PURE__ */ x.isValidElement(V) && gT(V, ["Grid"]) && I && V.props.container ? /* @__PURE__ */ x.cloneElement(V, {
          unstable_level: ((ie = V.props) == null ? void 0 : ie.unstable_level) ?? q + 1
        }) : V;
const JQ = hy(), ZQ = LI("div", {
function eJ(e) {
  return jI({
    defaultTheme: JQ
function tJ(e, t) {
const nJ = (e) => ({
})[e], rJ = ({
    ...fa({
    }, em({
    const r = A_(t), o = Object.keys(t.breakpoints.values).reduce((f, h) => ((typeof e.spacing == "object" && e.spacing[h] != null || typeof e.direction == "object" && e.direction[h] != null) && (f[h] = !0), f), {}), s = em({
    }), a = em({
    typeof s == "object" && Object.keys(s).forEach((f, h, g) => {
        const w = h > 0 ? s[g[h - 1]] : "column";
    }), n = Ri(n, fa({
    }, a, (f, h) => e.useFlexGap ? {
      gap: um(r, f)
        [`margin${nJ(h ? s[h] : e.direction)}`]: um(r, f)
  return n = GY(t.breakpoints, n), n;
function oJ(e = {}) {
    createStyledComponent: t = ZQ,
    useThemeProps: n = eJ,
  }, (f) => ln(r, f), {}), s = t(rJ), a = /* @__PURE__ */ x.forwardRef(function(f, h) {
    const g = n(f), v = mC(g), {
      className: P,
    } = v, A = {
    }, k = o();
      ownerState: A,
      ref: h,
      className: et(k.root, P),
      children: E ? tJ(O, E) : O
function tV() {
      paper: jS.white,
      default: jS.white
const iJ = tV();
function nV() {
      primary: jS.white,
      active: jS.white,
const Jj = nV();
function Zj(e, t, n, r) {
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = tp(e.main, o) : t === "dark" && (e.dark = ep(e.main, s)));
function sJ(e = "light") {
    main: uv[200],
    light: uv[50],
    dark: uv[400]
    main: uv[700],
    light: uv[400],
    dark: uv[800]
function aJ(e = "light") {
    main: lv[200],
    light: lv[50],
    dark: lv[400]
    main: lv[500],
    light: lv[300],
    dark: lv[700]
function lJ(e = "light") {
    main: av[500],
    light: av[300],
    dark: av[700]
    main: av[700],
    light: av[400],
    dark: av[800]
function uJ(e = "light") {
    main: cv[400],
    light: cv[300],
    dark: cv[700]
    main: cv[700],
    light: cv[500],
    dark: cv[900]
function cJ(e = "light") {
    main: dv[400],
    light: dv[300],
    dark: dv[700]
    main: dv[800],
    light: dv[500],
    dark: dv[900]
function dJ(e = "light") {
    main: zw[400],
    light: zw[300],
    dark: zw[700]
    light: zw[500],
    dark: zw[900]
function KI(e) {
  } = e, s = e.primary || sJ(t), a = e.secondary || aJ(t), c = e.error || lJ(t), f = e.info || uJ(t), h = e.success || cJ(t), g = e.warning || dJ(t);
  function v(E) {
    const O = Fj(E, Jj.text.primary) >= n ? Jj.text.primary : iJ.text.primary;
      const P = Fj(E, O);
      P < 3 && console.error([`MUI: The contrast ratio of ${P}:1 for ${O} on ${E}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
    mainShade: P = 500,
    }, !E.main && E[P] && (E.main = E[P]), !E.hasOwnProperty("main"))
The color object needs to have a \`main\` property or a \`${P}\` property.` : wc(11, O ? ` (${O})` : "", P));
} });` : wc(12, O ? ` (${O})` : "", JSON.stringify(E.main)));
    return Zj(E, "light", I, r), Zj(E, "dark", M, r), E.contrastText || (E.contrastText = v(E.main)), E;
  return t === "light" ? C = tV() : t === "dark" && (C = nV()), process.env.NODE_ENV !== "production" && (C || console.error(`MUI: The palette mode \`${t}\` is not supported.`)), Ri({
      ...jS
      color: h,
    grey: _7,
    getContrastText: v,
function fJ(e) {
function pJ(e, t) {
function hJ(e) {
const eF = {
}, tF = '"Roboto", "Helvetica", "Arial", sans-serif';
function rV(e, t) {
    fontFamily: n = tF,
    allVariants: h,
    ...v
  const w = r / 14, C = g || ((O) => `${O / f * w}rem`), T = (O, P, I, M, A) => ({
    fontSize: C(P),
    ...n === tF ? {
      letterSpacing: `${hJ(M / P)}em`
    ...A,
    ...h
    button: T(a, 14, 1.75, 0.4, eF),
    overline: T(s, 12, 2.66, 1, eF),
  return Ri({
  }, v, {
const mJ = 0.2, gJ = 0.14, vJ = 0.12;
function io(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${mJ})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${gJ})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${vJ})`].join(",");
const yJ = ["none", io(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), io(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), io(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), io(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), io(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), io(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), io(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), io(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), io(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), io(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), io(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), io(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), io(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), io(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), io(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), io(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), io(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), io(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), io(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), io(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), io(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), io(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), io(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), io(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], bJ = {
}, wJ = {
function nF(e) {
function SJ(e) {
function CJ(e) {
    ...bJ,
    ...wJ,
    getAutoHeightDuration: SJ,
        ...h
        const g = (w) => typeof w == "string", v = (w) => !Number.isNaN(parseFloat(w));
        !g(o) && !Array.isArray(o) && console.error('MUI: Argument "props" must be a string or Array.'), !v(a) && !g(a) && console.error(`MUI: Argument "duration" must be a number or a string but found ${a}.`), g(c) || console.error('MUI: Argument "easing" must be a string.'), !v(f) && !g(f) && console.error('MUI: Argument "delay" must be a number or a string.'), typeof s != "object" && console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join(`
`)), Object.keys(h).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(h).join(",")}].`);
      return (Array.isArray(o) ? o : [o]).map((g) => `${g} ${typeof a == "string" ? a : nF(a)} ${c} ${typeof f == "string" ? f : nF(f)}`).join(",");
const xJ = {
function EJ(e) {
  return hc(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
function oV(e = {}) {
      !EJ(c) || a.startsWith("unstable_") ? delete r[a] : hc(c) && (r[a] = {
function fM(e = {}, ...t) {
    ...h
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name or follow the [docs](https://mui.com/material-ui/customization/css-theme-variables/usage/) to enable the feature." : wc(20));
  const g = KI(s), v = hy(e);
  let w = Ri(v, {
    mixins: pJ(v.breakpoints, r),
    shadows: yJ.slice(),
    typography: rV(g, c),
    transitions: CJ(a),
      ...xJ
  if (w = Ri(w, h), w = t.reduce((C, T) => Ri(C, T), w), process.env.NODE_ENV !== "production") {
      let P;
      for (P in E) {
        const I = E[P];
        if (C.includes(P) && Object.keys(I).length > 0) {
            const M = ln("", P);
            console.error([`MUI: The \`${O}\` component increases the CSS specificity of the \`${P}\` internal state.`, "You can not override it like this: ", JSON.stringify(E, null, 2), "", `Instead, you need to use the '&.${M}' syntax:`, JSON.stringify({
          E[P] = {};
    ...pC,
    ...h == null ? void 0 : h.unstable_sxConfig
    return Zf({
  }, w.toRuntimeSource = oV, w;
function pM(e) {
const TJ = [...Array(25)].map((e, t) => {
  const n = pM(t);
function iV(e) {
function sV(e) {
  return e === "dark" ? TJ : [];
function _J(e) {
  } = e, s = KI(t);
      ...iV(s.mode),
    overlays: r || sV(s.mode),
function OJ(e) {
const RJ = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], kJ = (e) => (t, n) => {
      return RJ(e.cssVarPrefix).forEach((c) => {
function PJ(e, t) {
function aS(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : FH(e);
function gd(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = sS(aS(e[t]), `MUI: Can't create \`palette.${t}Channel\` because \`palette.${t}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
function MJ(e) {
const ic = (e) => {
}, IJ = (e = "mui") => TQ(e);
function cP(e, t, n, r) {
    e[r] = _J({
  } = fM({
      ...iV(o),
    overlays: (t == null ? void 0 : t.overlays) || sV(o)
function DJ(e = {}, ...t) {
    shouldSkipGeneratingVar: a = OJ,
    ...h
  } = e, g = Object.keys(n)[0], v = r || (n.light && g !== "light" ? "light" : g), w = IJ(s), {
    [v]: C,
  } = n, P = {
  if ((v === "dark" && !("dark" in n) || v === "light" && !("light" in n)) && (I = !0), !I)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The \`colorSchemes.${v}\` option is either missing or invalid.` : wc(21, v));
  const M = cP(P, I, h, v);
  T && !P.light && cP(P, T, void 0, "light"), E && !P.dark && cP(P, E, void 0, "dark");
  let A = {
    defaultColorScheme: v,
    colorSchemes: P,
      ...fJ(M.typography),
    spacing: MJ(h.spacing)
  Object.keys(A.colorSchemes).forEach((F) => {
    const D = A.colorSchemes[F].palette, q = (U) => {
      const K = U.split("-"), ee = K[1], G = K[2];
      return w(U, D[ee][G]);
    if (D.mode === "light" && (Ke(D.common, "background", "#fff"), Ke(D.common, "onBackground", "#000")), D.mode === "dark" && (Ke(D.common, "background", "#000"), Ke(D.common, "onBackground", "#fff")), PJ(D, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), D.mode === "light") {
      Ke(D.Alert, "errorColor", Hr(D.error.light, 0.6)), Ke(D.Alert, "infoColor", Hr(D.info.light, 0.6)), Ke(D.Alert, "successColor", Hr(D.success.light, 0.6)), Ke(D.Alert, "warningColor", Hr(D.warning.light, 0.6)), Ke(D.Alert, "errorFilledBg", q("palette-error-main")), Ke(D.Alert, "infoFilledBg", q("palette-info-main")), Ke(D.Alert, "successFilledBg", q("palette-success-main")), Ke(D.Alert, "warningFilledBg", q("palette-warning-main")), Ke(D.Alert, "errorFilledColor", ic(() => D.getContrastText(D.error.main))), Ke(D.Alert, "infoFilledColor", ic(() => D.getContrastText(D.info.main))), Ke(D.Alert, "successFilledColor", ic(() => D.getContrastText(D.success.main))), Ke(D.Alert, "warningFilledColor", ic(() => D.getContrastText(D.warning.main))), Ke(D.Alert, "errorStandardBg", Vr(D.error.light, 0.9)), Ke(D.Alert, "infoStandardBg", Vr(D.info.light, 0.9)), Ke(D.Alert, "successStandardBg", Vr(D.success.light, 0.9)), Ke(D.Alert, "warningStandardBg", Vr(D.warning.light, 0.9)), Ke(D.Alert, "errorIconColor", q("palette-error-main")), Ke(D.Alert, "infoIconColor", q("palette-info-main")), Ke(D.Alert, "successIconColor", q("palette-success-main")), Ke(D.Alert, "warningIconColor", q("palette-warning-main")), Ke(D.AppBar, "defaultBg", q("palette-grey-100")), Ke(D.Avatar, "defaultBg", q("palette-grey-400")), Ke(D.Button, "inheritContainedBg", q("palette-grey-300")), Ke(D.Button, "inheritContainedHoverBg", q("palette-grey-A100")), Ke(D.Chip, "defaultBorder", q("palette-grey-400")), Ke(D.Chip, "defaultAvatarColor", q("palette-grey-700")), Ke(D.Chip, "defaultIconColor", q("palette-grey-700")), Ke(D.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), Ke(D.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), Ke(D.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), Ke(D.LinearProgress, "primaryBg", Vr(D.primary.main, 0.62)), Ke(D.LinearProgress, "secondaryBg", Vr(D.secondary.main, 0.62)), Ke(D.LinearProgress, "errorBg", Vr(D.error.main, 0.62)), Ke(D.LinearProgress, "infoBg", Vr(D.info.main, 0.62)), Ke(D.LinearProgress, "successBg", Vr(D.success.main, 0.62)), Ke(D.LinearProgress, "warningBg", Vr(D.warning.main, 0.62)), Ke(D.Skeleton, "bg", `rgba(${q("palette-text-primaryChannel")} / 0.11)`), Ke(D.Slider, "primaryTrack", Vr(D.primary.main, 0.62)), Ke(D.Slider, "secondaryTrack", Vr(D.secondary.main, 0.62)), Ke(D.Slider, "errorTrack", Vr(D.error.main, 0.62)), Ke(D.Slider, "infoTrack", Vr(D.info.main, 0.62)), Ke(D.Slider, "successTrack", Vr(D.success.main, 0.62)), Ke(D.Slider, "warningTrack", Vr(D.warning.main, 0.62));
      const U = $E(D.background.default, 0.8);
      Ke(D.SnackbarContent, "bg", U), Ke(D.SnackbarContent, "color", ic(() => D.getContrastText(U))), Ke(D.SpeedDialAction, "fabHoverBg", $E(D.background.paper, 0.15)), Ke(D.StepConnector, "border", q("palette-grey-400")), Ke(D.StepContent, "border", q("palette-grey-400")), Ke(D.Switch, "defaultColor", q("palette-common-white")), Ke(D.Switch, "defaultDisabledColor", q("palette-grey-100")), Ke(D.Switch, "primaryDisabledColor", Vr(D.primary.main, 0.62)), Ke(D.Switch, "secondaryDisabledColor", Vr(D.secondary.main, 0.62)), Ke(D.Switch, "errorDisabledColor", Vr(D.error.main, 0.62)), Ke(D.Switch, "infoDisabledColor", Vr(D.info.main, 0.62)), Ke(D.Switch, "successDisabledColor", Vr(D.success.main, 0.62)), Ke(D.Switch, "warningDisabledColor", Vr(D.warning.main, 0.62)), Ke(D.TableCell, "border", Vr(NE(D.divider, 1), 0.88)), Ke(D.Tooltip, "bg", NE(D.grey[700], 0.92));
    }
    if (D.mode === "dark") {
      Ke(D.Alert, "errorColor", Vr(D.error.light, 0.6)), Ke(D.Alert, "infoColor", Vr(D.info.light, 0.6)), Ke(D.Alert, "successColor", Vr(D.success.light, 0.6)), Ke(D.Alert, "warningColor", Vr(D.warning.light, 0.6)), Ke(D.Alert, "errorFilledBg", q("palette-error-dark")), Ke(D.Alert, "infoFilledBg", q("palette-info-dark")), Ke(D.Alert, "successFilledBg", q("palette-success-dark")), Ke(D.Alert, "warningFilledBg", q("palette-warning-dark")), Ke(D.Alert, "errorFilledColor", ic(() => D.getContrastText(D.error.dark))), Ke(D.Alert, "infoFilledColor", ic(() => D.getContrastText(D.info.dark))), Ke(D.Alert, "successFilledColor", ic(() => D.getContrastText(D.success.dark))), Ke(D.Alert, "warningFilledColor", ic(() => D.getContrastText(D.warning.dark))), Ke(D.Alert, "errorStandardBg", Hr(D.error.light, 0.9)), Ke(D.Alert, "infoStandardBg", Hr(D.info.light, 0.9)), Ke(D.Alert, "successStandardBg", Hr(D.success.light, 0.9)), Ke(D.Alert, "warningStandardBg", Hr(D.warning.light, 0.9)), Ke(D.Alert, "errorIconColor", q("palette-error-main")), Ke(D.Alert, "infoIconColor", q("palette-info-main")), Ke(D.Alert, "successIconColor", q("palette-success-main")), Ke(D.Alert, "warningIconColor", q("palette-warning-main")), Ke(D.AppBar, "defaultBg", q("palette-grey-900")), Ke(D.AppBar, "darkBg", q("palette-background-paper")), Ke(D.AppBar, "darkColor", q("palette-text-primary")), Ke(D.Avatar, "defaultBg", q("palette-grey-600")), Ke(D.Button, "inheritContainedBg", q("palette-grey-800")), Ke(D.Button, "inheritContainedHoverBg", q("palette-grey-700")), Ke(D.Chip, "defaultBorder", q("palette-grey-700")), Ke(D.Chip, "defaultAvatarColor", q("palette-grey-300")), Ke(D.Chip, "defaultIconColor", q("palette-grey-300")), Ke(D.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), Ke(D.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), Ke(D.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), Ke(D.LinearProgress, "primaryBg", Hr(D.primary.main, 0.5)), Ke(D.LinearProgress, "secondaryBg", Hr(D.secondary.main, 0.5)), Ke(D.LinearProgress, "errorBg", Hr(D.error.main, 0.5)), Ke(D.LinearProgress, "infoBg", Hr(D.info.main, 0.5)), Ke(D.LinearProgress, "successBg", Hr(D.success.main, 0.5)), Ke(D.LinearProgress, "warningBg", Hr(D.warning.main, 0.5)), Ke(D.Skeleton, "bg", `rgba(${q("palette-text-primaryChannel")} / 0.13)`), Ke(D.Slider, "primaryTrack", Hr(D.primary.main, 0.5)), Ke(D.Slider, "secondaryTrack", Hr(D.secondary.main, 0.5)), Ke(D.Slider, "errorTrack", Hr(D.error.main, 0.5)), Ke(D.Slider, "infoTrack", Hr(D.info.main, 0.5)), Ke(D.Slider, "successTrack", Hr(D.success.main, 0.5)), Ke(D.Slider, "warningTrack", Hr(D.warning.main, 0.5));
      const U = $E(D.background.default, 0.98);
      Ke(D.SnackbarContent, "bg", U), Ke(D.SnackbarContent, "color", ic(() => D.getContrastText(U))), Ke(D.SpeedDialAction, "fabHoverBg", $E(D.background.paper, 0.15)), Ke(D.StepConnector, "border", q("palette-grey-600")), Ke(D.StepContent, "border", q("palette-grey-600")), Ke(D.Switch, "defaultColor", q("palette-grey-300")), Ke(D.Switch, "defaultDisabledColor", q("palette-grey-600")), Ke(D.Switch, "primaryDisabledColor", Hr(D.primary.main, 0.55)), Ke(D.Switch, "secondaryDisabledColor", Hr(D.secondary.main, 0.55)), Ke(D.Switch, "errorDisabledColor", Hr(D.error.main, 0.55)), Ke(D.Switch, "infoDisabledColor", Hr(D.info.main, 0.55)), Ke(D.Switch, "successDisabledColor", Hr(D.success.main, 0.55)), Ke(D.Switch, "warningDisabledColor", Hr(D.warning.main, 0.55)), Ke(D.TableCell, "border", Hr(NE(D.divider, 1), 0.68)), Ke(D.Tooltip, "bg", NE(D.grey[700], 0.92));
    }
    gd(D.background, "default"), gd(D.background, "paper"), gd(D.common, "background"), gd(D.common, "onBackground"), gd(D, "divider"), Object.keys(D).forEach((U) => {
      const K = D[U];
      U !== "tonalOffset" && K && typeof K == "object" && (K.main && Ke(D[U], "mainChannel", sS(aS(K.main))), K.light && Ke(D[U], "lightChannel", sS(aS(K.light))), K.dark && Ke(D[U], "darkChannel", sS(aS(K.dark))), K.contrastText && Ke(D[U], "contrastTextChannel", sS(aS(K.contrastText))), U === "text" && (gd(D[U], "primary"), gd(D[U], "secondary")), U === "action" && (K.active && gd(D[U], "active"), K.selected && gd(D[U], "selected")));
  }), A = t.reduce((F, D) => Ri(F, D), A);
  const k = {
    getSelector: kJ(A)
    vars: j,
    generateThemeVars: B,
    generateStyleSheets: H
  } = RQ(A, k);
  return A.vars = j, Object.entries(A.colorSchemes[A.defaultColorScheme]).forEach(([F, D]) => {
    A[F] = D;
  }), A.generateThemeVars = B, A.generateStyleSheets = H, A.generateSpacing = function() {
    return MH(h.spacing, A_(this));
  }, A.getColorSchemeSelector = kQ(c), A.spacing = A.generateSpacing(), A.shouldSkipGeneratingVar = a, A.unstable_sxConfig = {
    ...pC,
    ...h == null ? void 0 : h.unstable_sxConfig
  }, A.unstable_sx = function(D) {
    return Zf({
      sx: D,
  }, A.toRuntimeSource = oV, A;
function rF(e, t, n) {
    palette: KI({
function H_(e = {}, ...t) {
  } = e, c = s || "light", f = o == null ? void 0 : o[c], h = {
      return fM(e, ...t);
    "palette" in e || h[c] && (h[c] !== !0 ? g = h[c].palette : c === "dark" && (g = {
    const v = fM({
    return v.defaultColorScheme = c, v.colorSchemes = h, v.palette.mode === "light" && (v.colorSchemes.light = {
      ...h.light !== !0 && h.light,
      palette: v.palette
    }, rF(v, "dark", h.dark)), v.palette.mode === "dark" && (v.colorSchemes.dark = {
      ...h.dark !== !0 && h.dark,
      palette: v.palette
    }, rF(v, "light", h.light)), v;
  }
  return !n && !("light" in h) && c === "light" && (h.light = !0), DJ({
    colorSchemes: h,
function AJ(e) {
function NJ(e) {
const YI = H_();
function za() {
  const e = hC(YI);
  return process.env.NODE_ENV !== "production" && x.useDebugValue(e), e[gc] || e;
function aV(e) {
const Ds = (e) => aV(e) && e !== "classes", Ue = LH({
  themeId: gc,
  defaultTheme: YI,
  rootShouldForwardProp: Ds
function $J({
  const n = gc in e ? e[gc] : void 0;
  return /* @__PURE__ */ $.jsx(HS, {
    themeId: n ? gc : void 0,
const LE = {
  CssVarsProvider: LJ
} = EQ({
  themeId: gc,
  theme: () => H_({
  colorSchemeStorageKey: LE.colorSchemeStorageKey,
  modeStorageKey: LE.modeStorageKey,
    light: LE.defaultLightColorScheme,
    dark: LE.defaultDarkColorScheme
      typography: rV(e.palette, e.typography)
      return Zf({
}), jJ = LJ;
function FJ({
    const r = gc in e ? e[gc] : e;
  return n ? /* @__PURE__ */ $.jsx($J, {
  }) : /* @__PURE__ */ $.jsx(jJ, {
function lV(e) {
  return /* @__PURE__ */ $.jsx($I, {
    defaultTheme: YI,
    themeId: gc
process.env.NODE_ENV !== "production" && (lV.propTypes = {
function XI(e) {
      /* @__PURE__ */ $.jsx(lV, {
function zJ() {
  return mC;
const Zt = gQ;
function gn(e) {
  return hQ(e);
function BJ(e) {
  return ln("MuiSvgIcon", e);
fn("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const HJ = (e) => {
  return mt(o, BJ, r);
}, VJ = Ue("svg", {
  var t, n, r, o, s, a, c, f, h, g, v, w, C, T;
          fontSize: ((g = (h = e.typography) == null ? void 0 : h.pxToRem) == null ? void 0 : g.call(h, 35)) || "2.1875rem"
        var O, P;
            color: (P = (O = (e.vars ?? e).palette) == null ? void 0 : O[E]) == null ? void 0 : P.main
          color: (w = (v = (e.vars ?? e).palette) == null ? void 0 : v.action) == null ? void 0 : w.active
})), $T = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    htmlColor: h,
    titleAccess: v,
  const P = HJ(E);
  return /* @__PURE__ */ $.jsxs(VJ, {
    className: et(P.root, s),
    color: h,
    "aria-hidden": v ? void 0 : !0,
    role: v ? "img" : void 0,
    children: [T ? o.props.children : o, v ? /* @__PURE__ */ $.jsx("title", {
      children: v
process.env.NODE_ENV !== "production" && ($T.propTypes = {
$T.muiName = "SvgIcon";
function Tn(e, t) {
    return /* @__PURE__ */ $.jsx($T, {
  return process.env.NODE_ENV !== "production" && (n.displayName = `${t}Icon`), n.muiName = $T.muiName, /* @__PURE__ */ x.memo(/* @__PURE__ */ x.forwardRef(n));
function QI(e, t) {
function hM(e, t) {
  return hM = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
  }, hM(e, t);
function uV(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, hM(e, t);
const oF = {
var UJ = process.env.NODE_ENV !== "production" ? u.oneOfType([u.number, u.shape({
const LT = pu.createContext(null);
var WJ = function(t) {
}, lS = "unmounted", Lh = "exited", jh = "entering", Ev = "entered", mM = "exiting", Cu = /* @__PURE__ */ function(e) {
  uV(t, e);
    return s.appearStatus = null, r.in ? c ? (f = Lh, s.appearStatus = jh) : f = Ev : r.unmountOnExit || r.mountOnEnter ? f = lS : f = Lh, s.state = {
    return a && s.status === lS ? {
      status: Lh
      this.props.in ? a !== jh && a !== Ev && (s = jh) : (a === jh || a === Ev) && (s = mM);
      if (this.cancelNextCallback(), s === jh) {
          var a = this.props.nodeRef ? this.props.nodeRef.current : kE.findDOMNode(this);
          a && WJ(a);
    else this.props.unmountOnExit && this.state.status === Lh && this.setState({
      status: lS
    var s = this, a = this.props.enter, c = this.context ? this.context.isMounting : o, f = this.props.nodeRef ? [c] : [kE.findDOMNode(this), c], h = f[0], g = f[1], v = this.getTimeouts(), w = c ? v.appear : v.enter;
    if (!o && !a || oF.disabled) {
        status: Ev
        s.props.onEntered(h);
    this.props.onEnter(h, g), this.safeSetState({
      status: jh
      s.props.onEntering(h, g), s.onTransitionEnd(w, function() {
          status: Ev
          s.props.onEntered(h, g);
    var o = this, s = this.props.exit, a = this.getTimeouts(), c = this.props.nodeRef ? void 0 : kE.findDOMNode(this);
    if (!s || oF.disabled) {
        status: Lh
      status: mM
          status: Lh
    var a = this.props.nodeRef ? this.props.nodeRef.current : kE.findDOMNode(this), c = o == null && !this.props.addEndListener;
      var f = this.props.nodeRef ? [this.nextCallback] : [a, this.nextCallback], h = f[0], g = f[1];
      this.props.addEndListener(h, g);
    if (o === lS)
      /* @__PURE__ */ pu.createElement(LT.Provider, {
      }, typeof a == "function" ? a(o, c) : pu.cloneElement(pu.Children.only(a), c))
}(pu.Component);
Cu.contextType = LT;
Cu.propTypes = process.env.NODE_ENV !== "production" ? {
    var n = UJ;
function fv() {
Cu.defaultProps = {
  onEnter: fv,
  onEntering: fv,
  onEntered: fv,
  onExit: fv,
  onExiting: fv,
  onExited: fv
Cu.UNMOUNTED = lS;
Cu.EXITED = Lh;
Cu.ENTERING = jh;
Cu.ENTERED = Ev;
Cu.EXITING = mM;
function GJ(e) {
function JI(e, t) {
function qJ(e, t) {
        var h = r[f][a];
        c[r[f][a]] = n(h);
function Yh(e, t, n) {
function KJ(e, t) {
  return JI(e.children, function(n) {
      appear: Yh(n, "appear", e),
      enter: Yh(n, "enter", e),
      exit: Yh(n, "exit", e)
function YJ(e, t, n) {
  var r = JI(e.children), o = qJ(t, r);
      var c = s in t, f = s in r, h = t[s], g = x.isValidElement(h) && !h.props.in;
        exit: Yh(a, "exit", e),
        enter: Yh(a, "enter", e)
      }) : f && c && x.isValidElement(h) && (o[s] = x.cloneElement(a, {
        in: h.props.in,
        exit: Yh(a, "exit", e),
        enter: Yh(a, "enter", e)
var XJ = Object.values || function(e) {
}, QJ = {
}, ZI = /* @__PURE__ */ function(e) {
  uV(t, e);
    var a = s.handleExited.bind(GJ(s));
      children: f ? KJ(o, c) : YJ(o, a, c),
    var a = JI(this.props.children);
    var o = this.props, s = o.component, a = o.childFactory, c = qt(o, ["component", "childFactory"]), f = this.state.contextValue, h = XJ(this.state.children).map(a);
    return delete c.appear, delete c.enter, delete c.exit, s === null ? /* @__PURE__ */ pu.createElement(LT.Provider, {
    }, h) : /* @__PURE__ */ pu.createElement(LT.Provider, {
    }, /* @__PURE__ */ pu.createElement(s, c, h));
}(pu.Component);
ZI.propTypes = process.env.NODE_ENV !== "production" ? {
ZI.defaultProps = QJ;
const eD = (e) => e.scrollTop;
function Gv(e, t) {
function JJ(e) {
  return ln("MuiPaper", e);
fn("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const ZJ = (e) => {
  return mt(s, JJ, o);
}, eZ = Ue("div", {
}))), la = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
  }), o = za(), {
    variant: h = "elevation",
  } = r, v = {
    variant: h
  }, w = ZJ(v);
`)), /* @__PURE__ */ $.jsx(eZ, {
    ownerState: v,
      ...h === "elevation" && {
          "--Paper-overlay": `linear-gradient(${rn("#fff", pM(c))}, ${rn("#fff", pM(c))})`
process.env.NODE_ENV !== "production" && (la.propTypes = {
  elevation: ja(nm, (e) => {
function bn(e, t) {
    component: h,
    slotProps: v = {
  } = s, C = g[e] || r, T = KH(v[e], o), {
    internalRef: P
  } = qH({
  }), I = Ir(P, T == null ? void 0 : T.ref, t.ref), M = e === "root" ? E || h : E, A = WH(C, {
    ...e === "root" && !h && !g[e] && a,
  return [C, A];
class jT {
    Nn(this, "mountEffect", () => {
    return new jT();
    const t = Ml(jT.create).current, [n, r] = x.useState(!1);
    return this.mounted || (this.mounted = nZ(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
function tZ() {
  return jT.use();
function nZ() {
function cV(e) {
    timeout: h
  } = e, [g, v] = x.useState(!1), w = et(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), C = {
  return !c && !g && v(!0), x.useEffect(() => {
      const E = setTimeout(f, h);
  }, [f, c, h]), /* @__PURE__ */ $.jsx("span", {
process.env.NODE_ENV !== "production" && (cV.propTypes = {
const ml = fn("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), gM = 550, rZ = 80, oZ = Tc`
`, iZ = Tc`
`, sZ = Tc`
`, aZ = Ue("span", {
}), lZ = Ue(cV, {
  &.${ml.rippleVisible} {
    animation-name: ${oZ};
    animation-duration: ${gM}ms;
  &.${ml.ripplePulsate} {
  & .${ml.child} {
  & .${ml.childLeaving} {
    animation-name: ${iZ};
    animation-duration: ${gM}ms;
  & .${ml.childPulsate} {
    animation-name: ${sZ};
`, dV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
  } = r, [f, h] = x.useState([]), g = x.useRef(0), v = x.useRef(null);
    v.current && (v.current(), v.current = null);
  const w = x.useRef(!1), C = Aa(), T = x.useRef(null), E = x.useRef(null), O = x.useCallback((A) => {
      pulsate: k,
      rippleX: j,
      rippleY: B,
      rippleSize: H,
      cb: F
    } = A;
    h((D) => [...D, /* @__PURE__ */ $.jsx(lZ, {
        ripple: et(s.ripple, ml.ripple),
        rippleVisible: et(s.rippleVisible, ml.rippleVisible),
        ripplePulsate: et(s.ripplePulsate, ml.ripplePulsate),
        child: et(s.child, ml.child),
        childLeaving: et(s.childLeaving, ml.childLeaving),
        childPulsate: et(s.childPulsate, ml.childPulsate)
      timeout: gM,
      pulsate: k,
      rippleX: j,
      rippleY: B,
      rippleSize: H
    }, g.current)]), g.current += 1, v.current = F;
  }, [s]), P = x.useCallback((A = {}, k = {}, j = () => {
      pulsate: B = !1,
      center: H = o || k.pulsate,
      fakeElement: F = !1
    } = k;
    if ((A == null ? void 0 : A.type) === "mousedown" && w.current) {
    (A == null ? void 0 : A.type) === "touchstart" && (w.current = !0);
    const D = F ? null : E.current, q = D ? D.getBoundingClientRect() : {
    let U, K, ee;
    if (H || A === void 0 || A.clientX === 0 && A.clientY === 0 || !A.clientX && !A.touches)
      U = Math.round(q.width / 2), K = Math.round(q.height / 2);
        clientY: Y
      } = A.touches && A.touches.length > 0 ? A.touches[0] : A;
      U = Math.round(G - q.left), K = Math.round(Y - q.top);
    if (H)
      const G = Math.max(Math.abs((D ? D.clientWidth : 0) - U), U) * 2 + 2, Y = Math.max(Math.abs((D ? D.clientHeight : 0) - K), K) * 2 + 2;
      ee = Math.sqrt(G ** 2 + Y ** 2);
    A != null && A.touches ? T.current === null && (T.current = () => {
        pulsate: B,
        rippleX: U,
        rippleY: K,
        cb: j
    }, C.start(rZ, () => {
      pulsate: B,
      rippleX: U,
      rippleY: K,
      cb: j
    P({}, {
  }, [P]), M = x.useCallback((A, k) => {
    if (C.clear(), (A == null ? void 0 : A.type) === "touchend" && T.current) {
        M(A, k);
    T.current = null, h((j) => j.length > 0 ? j.slice(1) : j), v.current = k;
    start: P,
  }), [I, P, M]), /* @__PURE__ */ $.jsx(aZ, {
    className: et(ml.root, s.root, a),
    children: /* @__PURE__ */ $.jsx(ZI, {
process.env.NODE_ENV !== "production" && (dV.propTypes = {
function uZ(e) {
  return ln("MuiButtonBase", e);
const cZ = fn("MuiButtonBase", ["root", "disabled", "focusVisible"]), dZ = (e) => {
  }, uZ, o);
}, fZ = Ue("button", {
  [`&.${cZ.disabled}`]: {
}), cm = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    disabled: h = !1,
    disableTouchRipple: v = !1,
    onContextMenu: P,
    onFocusVisible: A,
    onKeyDown: k,
    onKeyUp: j,
    onMouseDown: B,
    onMouseLeave: H,
    onMouseUp: F,
    onTouchEnd: D,
    onTouchStart: U,
    tabIndex: K = 0,
    type: Y,
  } = r, te = x.useRef(null), re = tZ(), Q = Ir(re.ref, G), [V, ie] = x.useState(!1);
  h && V && ie(!1), x.useImperativeHandle(o, () => ({
  const de = re.shouldMount && !g && !h;
    V && w && !g && re.pulsate();
  }, [g, w, V, re]);
  const ue = vd(re, "start", B, v), he = vd(re, "stop", P, v), ge = vd(re, "stop", I, v), fe = vd(re, "stop", F, v), pe = vd(re, "stop", (nt) => {
    V && nt.preventDefault(), H && H(nt);
  }, v), be = vd(re, "start", U, v), we = vd(re, "stop", D, v), _e = vd(re, "stop", q, v), ce = vd(re, "stop", (nt) => {
    DT(nt.target) || ie(!1), E && E(nt);
  }, !1), Ce = Fn((nt) => {
    te.current || (te.current = nt.currentTarget), DT(nt.target) && (ie(!0), A && A(nt)), M && M(nt);
  }, Be = Fn((nt) => {
    w && !nt.repeat && V && nt.key === " " && re.stop(nt, () => {
    }), nt.target === nt.currentTarget && Ne() && nt.key === " " && nt.preventDefault(), k && k(nt), nt.target === nt.currentTarget && Ne() && nt.key === "Enter" && !h && (nt.preventDefault(), O && O(nt));
  }), tt = Fn((nt) => {
    w && nt.key === " " && V && !nt.defaultPrevented && re.stop(nt, () => {
    }), j && j(nt), O && nt.target === nt.currentTarget && Ne() && nt.key === " " && !nt.defaultPrevented && O(nt);
  let Le = f;
  Le === "button" && (X.href || X.to) && (Le = T);
  Le === "button" ? (rt.type = Y === void 0 ? "button" : Y, rt.disabled = h) : (!X.href && !X.to && (rt.role = "button"), h && (rt["aria-disabled"] = h));
  const ot = Ir(n, te), wt = {
    disabled: h,
    disableTouchRipple: v,
    tabIndex: K,
    focusVisible: V
  }, gt = dZ(wt);
  return /* @__PURE__ */ $.jsxs(fZ, {
    as: Le,
    tabIndex: h ? -1 : K,
    type: Y,
    children: [a, de ? /* @__PURE__ */ $.jsx(dV, {
function vd(e, t, n, r = !1) {
  return Fn((o) => (n && n(o), r || e[t](o), !0));
process.env.NODE_ENV !== "production" && (cm.propTypes = {
  action: pa,
  component: zI,
function pZ(e) {
function hZ(e, t = []) {
  if (!pZ(e))
function no(e = []) {
  return ([, t]) => t && hZ(t, e);
function mZ(e) {
  return ln("MuiAlert", e);
const iF = fn("MuiAlert", ["root", "action", "icon", "message", "filled", "colorSuccess", "colorInfo", "colorWarning", "colorError", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
function gZ(e) {
  return ln("MuiCircularProgress", e);
fn("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const If = 44, vM = Tc`
`, yM = Tc`
`, vZ = typeof vM != "string" ? ip`
        animation: ${vM} 1.4s linear infinite;
      ` : null, yZ = typeof yM != "string" ? ip`
        animation: ${yM} 1.4s ease-in-out infinite;
      ` : null, bZ = (e) => {
  return mt(s, gZ, t);
}, wZ = Ue("span", {
    style: vZ || {
      animation: `${vM} 1.4s linear infinite`
  }, ...Object.entries(e.palette).filter(no()).map(([t]) => ({
}))), SZ = Ue("svg", {
}), CZ = Ue("circle", {
    style: yZ || {
      animation: `${yM} 1.4s ease-in-out infinite`
}))), vy = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    thickness: h = 3.6,
    variant: v = "indeterminate",
    thickness: h,
    variant: v
  }, T = bZ(C), E = {}, O = {}, P = {};
  if (v === "determinate") {
    const I = 2 * Math.PI * ((If - h) / 2);
    E.strokeDasharray = I.toFixed(3), P["aria-valuenow"] = Math.round(g), E.strokeDashoffset = `${((100 - g) / 100 * I).toFixed(3)}px`, O.transform = "rotate(-90deg)";
  return /* @__PURE__ */ $.jsx(wZ, {
    ...P,
    children: /* @__PURE__ */ $.jsx(SZ, {
      viewBox: `${If / 2} ${If / 2} ${If} ${If}`,
      children: /* @__PURE__ */ $.jsx(CZ, {
        cx: If,
        cy: If,
        r: (If - h) / 2,
        strokeWidth: h
process.env.NODE_ENV !== "production" && (vy.propTypes = {
  disableShrink: ja(u.bool, (e) => e.disableShrink && e.variant && e.variant !== "indeterminate" ? new Error("MUI: You have provided the `disableShrink` prop with a variant other than `indeterminate`. This will have no effect.") : null),
function xZ(e) {
  return ln("MuiIconButton", e);
const sF = fn("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]), EZ = (e) => {
  return mt(c, xZ, t);
}, TZ = Ue(cm, {
      "--IconButton-hoverBg": e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : rn(e.palette.action.active, e.palette.action.hoverOpacity),
  }, ...Object.entries(e.palette).filter(no()).map(([t]) => ({
  })), ...Object.entries(e.palette).filter(no()).map(([t]) => ({
      "--IconButton-hoverBg": e.vars ? `rgba(${(e.vars || e).palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : rn((e.vars || e).palette[t].main, e.palette.action.hoverOpacity)
  [`&.${sF.disabled}`]: {
  [`&.${sF.loading}`]: {
}))), _Z = Ue("span", {
})), hu = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    disableFocusRipple: h = !1,
    id: v,
  } = r, E = mr(v), O = C ?? /* @__PURE__ */ $.jsx(vy, {
  }), P = {
    disableFocusRipple: h,
  }, I = EZ(P);
  return /* @__PURE__ */ $.jsxs(TZ, {
    id: w ? E : v,
    focusRipple: !h,
    ownerState: P,
      children: /* @__PURE__ */ $.jsx(_Z, {
        ownerState: P,
process.env.NODE_ENV !== "production" && (hu.propTypes = {
  children: ja(u.node, (e) => x.Children.toArray(e.children).some((n) => /* @__PURE__ */ x.isValidElement(n) && n.props.onClick) ? new Error(["MUI: You are providing an onClick event listener to a child of a button element.", "Prefer applying it to the IconButton directly.", "This guarantees that the whole <button> will be responsive to click events."].join(`
const OZ = Tn(/* @__PURE__ */ $.jsx("path", {
}), "SuccessOutlined"), RZ = Tn(/* @__PURE__ */ $.jsx("path", {
}), "ReportProblemOutlined"), kZ = Tn(/* @__PURE__ */ $.jsx("path", {
}), "ErrorOutline"), PZ = Tn(/* @__PURE__ */ $.jsx("path", {
}), "InfoOutlined"), fV = Tn(/* @__PURE__ */ $.jsx("path", {
}), "Close"), MZ = (e) => {
  return mt(s, mZ, o);
}, IZ = Ue(la, {
  const t = e.palette.mode === "light" ? ep : tp, n = e.palette.mode === "light" ? tp : ep;
    variants: [...Object.entries(e.palette).filter(no(["light"])).map(([r]) => ({
        [`& .${iF.icon}`]: e.vars ? {
    })), ...Object.entries(e.palette).filter(no(["light"])).map(([r]) => ({
        [`& .${iF.icon}`]: e.vars ? {
    })), ...Object.entries(e.palette).filter(no(["dark"])).map(([r]) => ({
})), DZ = Ue("div", {
}), AZ = Ue("div", {
}), NZ = Ue("div", {
}), aF = {
  success: /* @__PURE__ */ $.jsx(OZ, {
  warning: /* @__PURE__ */ $.jsx(RZ, {
  error: /* @__PURE__ */ $.jsx(kZ, {
  info: /* @__PURE__ */ $.jsx(PZ, {
}, jv = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    components: h = {},
    icon: v,
    iconMapping: w = aF,
    slots: P = {},
  } = r, A = {
  }, k = MZ(A), j = {
      closeButton: h.CloseButton,
      closeIcon: h.CloseIcon,
      ...P
  }, [B, H] = bn("root", {
    className: et(k.root, a),
    elementType: IZ,
      ...j,
    ownerState: A,
  }), [F, D] = bn("icon", {
    className: k.icon,
    elementType: DZ,
    externalForwardedProps: j,
    ownerState: A
  }), [q, U] = bn("message", {
    className: k.message,
    elementType: AZ,
    externalForwardedProps: j,
    ownerState: A
  }), [K, ee] = bn("action", {
    className: k.action,
    elementType: NZ,
    externalForwardedProps: j,
    ownerState: A
  }), [G, Y] = bn("closeButton", {
    elementType: hu,
    externalForwardedProps: j,
    ownerState: A
  }), [X, te] = bn("closeIcon", {
    elementType: fV,
    externalForwardedProps: j,
    ownerState: A
  return /* @__PURE__ */ $.jsxs(B, {
    ...H,
    children: [v !== !1 ? /* @__PURE__ */ $.jsx(F, {
      ...D,
      children: v || w[E] || aF[E]
      ...U,
    }), o != null ? /* @__PURE__ */ $.jsx(K, {
    }) : null, o == null && C ? /* @__PURE__ */ $.jsx(K, {
        ...Y,
process.env.NODE_ENV !== "production" && (jv.propTypes = {
function $Z(e) {
  return ln("MuiTypography", e);
const lF = fn("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), LZ = {
}, jZ = zJ(), FZ = (e) => {
  return mt(c, $Z, a);
}, zZ = Ue("span", {
    })), ...Object.entries(e.palette).filter(no()).map(([n]) => ({
})), uF = {
}, un = /* @__PURE__ */ x.forwardRef(function(t, n) {
  } = gn({
  }), s = !LZ[r], a = jZ({
    component: h,
    noWrap: v = !1,
    variantMapping: T = uF,
    component: h,
    noWrap: v,
  }, P = h || (w ? "p" : T[C] || uF[C]) || "span", I = FZ(O);
  return /* @__PURE__ */ $.jsx(zZ, {
    as: P,
process.env.NODE_ENV !== "production" && (un.propTypes = {
function BZ(e) {
  return ln("MuiAppBar", e);
fn("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent", "colorError", "colorInfo", "colorSuccess", "colorWarning"]);
const HZ = (e) => {
  return mt(o, BZ, r);
}, cF = (e, t) => e ? `${e == null ? void 0 : e.replace(")", "")}, ${t})` : t, VZ = Ue(la, {
  }, ...Object.entries(e.palette).filter(no(["contrastText"])).map(([t]) => ({
        backgroundColor: e.vars ? cF(e.vars.palette.AppBar.darkBg, "var(--AppBar-background)") : null,
        color: e.vars ? cF(e.vars.palette.AppBar.darkColor, "var(--AppBar-color)") : null
}))), pV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
  } = r, h = {
  }, g = HZ(h);
  return /* @__PURE__ */ $.jsx(VZ, {
    ownerState: h,
process.env.NODE_ENV !== "production" && (pV.propTypes = {
function dF(e) {
function hV(e = {}) {
    getOptionLabel: h
    n && (g = g.toLowerCase()), t && (g = dF(g));
    const v = g ? c.filter((w) => {
      let C = (s || h)(w);
      return n && (C = C.toLowerCase()), t && (C = dF(C)), o === "start" ? C.startsWith(g) : C.includes(g);
    return typeof r == "number" ? v.slice(0, r) : v;
const UZ = hV(), fF = 5, WZ = (e) => {
}, GZ = [];
function pF(e, t, n) {
function qZ(e) {
    unstable_isActiveElementInListbox: t = WZ,
    componentName: h = "useAutocomplete",
    defaultValue: g = e.multiple ? GZ : null,
    disableClearable: v = !1,
    filterOptions: O = UZ,
    filterSelectedOptions: P = !1,
    getOptionKey: A,
    getOptionLabel: k = (De) => De.label ?? De,
    groupBy: j,
    handleHomeEndKeys: B = !e.freeSolo,
    id: H,
    includeInputInList: F = !1,
    inputValue: D,
    multiple: U = !1,
    onChange: K,
    onInputChange: Y,
    readOnly: V = !1,
  } = e, ue = mr(H);
  let he = k;
    const Re = k(De);
        console.error(`MUI: The \`getOptionLabel\` method of ${h} returned ${Je} instead of a string for ${JSON.stringify(De)}.`);
  const ge = x.useRef(!1), fe = x.useRef(!0), pe = x.useRef(null), be = x.useRef(null), [we, _e] = x.useState(null), [ce, Ce] = x.useState(-1), Ne = o ? 0 : -1, Be = x.useRef(Ne), tt = x.useRef(pF(g ?? de, U, he)).current, [Le, rt] = tm({
    name: h
  }), [ot, wt] = tm({
    controlled: D,
    name: h,
    if (!(U ? Le.length < Re.length : Re !== null) && !c)
    const jt = pF(Re, U, he);
    ot !== jt && (wt(jt), Y && Y(De, jt, Je));
  }, [he, ot, U, Y, wt, c, Le]), [ut, Et] = tm({
    name: h,
  }), [Tt, At] = x.useState(!0), vt = !U && Le != null && ot === he(Le), Xe = ut && !V, Oe = Xe ? O(
    Q.filter((De) => !(P && (U ? Le : [Le]).some((Re) => Re !== null && q(De, Re)))),
  ) : [], Ie = VI({
    value: Le,
    const De = Le !== Ie.value;
    gt && !De || I && !De || Ft(null, Le, "reset");
  }, [Le, Ft, gt, Ie.value, I]);
  const pt = ut && Oe.length > 0 && !V, yt = Fn((De) => {
    U && ce > Le.length - 1 && (Ce(-1), yt(-1));
  }, [Le, U, ce, yt]);
  const bt = Fn(({
      const Ln = Kt, kr = jt.clientHeight + jt.scrollTop, ei = Ln.offsetTop + Ln.offsetHeight;
      ei > kr ? jt.scrollTop = ei - jt.clientHeight : Ln.offsetTop - Ln.offsetHeight * (j ? 1.3 : 0) < jt.scrollTop && (jt.scrollTop = Ln.offsetTop - Ln.offsetHeight * (j ? 1.3 : 0));
  }), We = Fn(({
      const kr = Be.current + Re;
      return kr < 0 ? kr === -1 && F ? -1 : E && Be.current !== -1 || Math.abs(Re) > 1 ? 0 : Ln : kr > Ln ? kr === Ln + 1 && F ? -1 : E || Math.abs(Re) > 1 ? Ln : 0 : kr;
    if (Be.current !== -1 && Ie.filteredOptions && Ie.filteredOptions.length !== Oe.length && Ie.inputValue === ot && (U ? Le.length === Ie.value.length && Ie.value.every((Re, Je) => he(Le[Je]) === he(Re)) : De(Ie.value, Le))) {
  }, Lt = x.useCallback(() => {
    const Re = U ? Le[0] : Le;
        if (U && Je && Le.findIndex((jt) => q(Je, jt)) !== -1)
    U ? !1 : Le,
    P,
    U
  ]), Cn = Fn((De) => {
    cM(be, De), De && Lt();
    (!pe.current || pe.current.nodeName !== "INPUT") && (pe.current && pe.current.nodeName === "TEXTAREA" ? console.warn([`A textarea element was provided to ${h} where input was expected.`, "This is not a supported scenario but it may work under certain conditions.", "A textarea keyboard navigation may conflict with Autocomplete controls (for example enter and arrow keys).", "Make sure to test keyboard navigation and add custom event handlers if necessary."].join(`
`)) : console.error([`MUI: Unable to find the input element. It was resolved to ${pe.current} while an HTMLInputElement was expected.`, `Instead, ${h} expects an input element.`, "", h === "useAutocomplete" ? "Make sure you have bound getInputProps correctly and that the normal ref/effect resolutions order is guaranteed." : "Make sure you have customized the input component correctly."].join(`
  }, [h]), x.useEffect(() => {
    Lt();
  }, [Lt]);
  const pn = (De) => {
  }, Or = (De, Re) => {
  }, lr = (De, Re, Je, Bt) => {
    if (U) {
      if (Le.length === Re.length && Le.every((jt, Kt) => jt === Re[Kt]))
    } else if (Le === Re)
    K && K(De, Re, Je, Bt), rt(Re);
  }, Fr = x.useRef(!1), Rr = (De, Re, Je = "selectOption", Bt = "options") => {
    if (U) {
      if (Kt = Array.isArray(Le) ? Le.slice() : [], process.env.NODE_ENV !== "production") {
        const kr = Kt.filter((ei) => q(Re, ei));
        kr.length > 1 && console.error([`MUI: The \`isOptionEqualToValue\` method of ${h} does not handle the arguments correctly.`, `The component expects a single value to match a given option but found ${kr.length} matches.`].join(`
      const Ln = Kt.findIndex((kr) => q(Re, kr));
    Ft(De, Kt, jt), lr(De, Kt, jt, {
    }), !w && (!De || !De.ctrlKey && !De.metaKey) && Or(De, jt), (a === !0 || a === "touch" && Fr.current || a === "mouse" && !Fr.current) && pe.current.blur();
  function Qo(De, Re) {
      if (Re === "next" && Je === Le.length || Re === "previous" && Je === -1)
  const Jo = (De, Re) => {
    if (!U)
    ot === "" && Or(De, "toggleInput");
    ce === -1 ? ot === "" && Re === "previous" && (Je = Le.length - 1) : (Je += Re === "next" ? 1 : -1, Je < 0 && (Je = 0), Je === Le.length && (Je = -1)), Je = Qo(Je, Re), Ce(Je), yt(Je);
    ge.current = !0, wt(""), Y && Y(De, "", "clear"), lr(De, U ? [] : null, "clear");
  }, gr = (De) => (Re) => {
          Xe && B && (Re.preventDefault(), We({
          Xe && B && (Re.preventDefault(), We({
            diff: -fF,
          }), pn(Re);
            diff: fF,
          }), pn(Re);
          }), pn(Re);
          }), pn(Re);
          Jo(Re, "previous");
          Jo(Re, "next");
            Rr(Re, Je, "selectOption"), r && pe.current.setSelectionRange(pe.current.value.length, pe.current.value.length);
          } else I && ot !== "" && vt === !1 && (U && Re.preventDefault(), Rr(Re, ot, "createOption", "freeSolo"));
          Xe ? (Re.preventDefault(), Re.stopPropagation(), Or(Re, "escape")) : f && (ot !== "" || U && Le.length > 0) && (Re.preventDefault(), Re.stopPropagation(), Wt(Re));
          if (U && !V && ot === "" && Le.length > 0) {
            const Je = ce === -1 ? Le.length - 1 : ce, Bt = Le.slice();
            Bt.splice(Je, 1), lr(Re, Bt, "removeOption", {
              option: Le[Je]
          if (U && !V && ot === "" && Le.length > 0 && ce !== -1) {
            const Je = ce, Bt = Le.slice();
            Bt.splice(Je, 1), lr(Re, Bt, "removeOption", {
              option: Le[Je]
  }, Zo = (De) => {
    nt(!0), re && !ge.current && pn(De);
  }, Kr = (De) => {
    nt(!1), fe.current = !0, ge.current = !1, s && Be.current !== -1 && Xe ? Rr(De, Oe[Be.current], "blur") : s && I && ot !== "" ? Rr(De, ot, "blur", "freeSolo") : c && Ft(De, Le, "blur"), Or(De, "blur");
  }, so = (De) => {
    ot !== Re && (wt(Re), At(!1), Y && Y(De, Re, "input")), Re === "" ? !v && !U && lr(De, null, "clear") : pn(De);
  }, Yr = (De) => {
  }, Yi = (De) => {
    }), Fr.current = !0;
  }, ki = (De) => {
    Rr(De, Oe[Re], "selectOption"), Fr.current = !1;
  }, Xi = (De) => (Re) => {
    const Je = Le.slice();
    Je.splice(De, 1), lr(Re, Je, "removeOption", {
      option: Le[De]
  }, Qi = (De) => {
    ut ? Or(De, "toggleInput") : pn(De);
    !C && (ot === "" || !ut) && Qi(De);
  Ct = Ct || (U ? Le.length > 0 : Le !== null);
  let hn = Oe;
  if (j) {
    hn = Oe.reduce((Je, Bt, jt) => {
      const Kt = j(Bt);
      return Je.length > 0 && Je[Je.length - 1].group === Kt ? Je[Je.length - 1].options.push(Bt) : (process.env.NODE_ENV !== "production" && (De.get(Kt) && !Re && (console.warn(`MUI: The options provided combined with the \`groupBy\` method of ${h} returns duplicated headers.`, "You can solve the issue by sorting the options with the output of `groupBy`."), Re = !0), De.set(Kt, !0)), Je.push({
  return C && gt && Kr(), {
      onKeyDown: gr(De),
      onBlur: Kr,
      onFocus: Zo,
      onChange: so,
      onClick: Qi
      ...!V && {
        onDelete: Xi(De)
      ref: Cn,
      const Je = (U ? Le : [Le]).some((jt) => jt != null && q(Re, jt)), Bt = M ? M(Re) : !1;
        key: (A == null ? void 0 : A(Re)) ?? he(Re),
        onMouseMove: Yr,
        onClick: ki,
        onTouchStart: Yi,
    value: Le,
    groupedOptions: hn
var ua = "top", Ol = "bottom", Rl = "right", ca = "left", tD = "auto", yC = [ua, Ol, Rl, ca], qv = "start", VS = "end", KZ = "clippingParents", mV = "viewport", Hw = "popper", YZ = "reference", hF = /* @__PURE__ */ yC.reduce(function(e, t) {
  return e.concat([t + "-" + qv, t + "-" + VS]);
}, []), gV = /* @__PURE__ */ [].concat(yC, [tD]).reduce(function(e, t) {
  return e.concat([t, t + "-" + qv, t + "-" + VS]);
}, []), XZ = "beforeRead", QZ = "read", JZ = "afterRead", ZZ = "beforeMain", eee = "main", tee = "afterMain", nee = "beforeWrite", ree = "write", oee = "afterWrite", iee = [XZ, QZ, JZ, ZZ, eee, tee, nee, ree, oee];
function Cc(e) {
function Fa(e) {
function dm(e) {
  var t = Fa(e).Element;
function wl(e) {
  var t = Fa(e).HTMLElement;
function nD(e) {
  var t = Fa(e).ShadowRoot;
function see(e) {
    !wl(s) || !Cc(s) || (Object.assign(s.style, r), Object.keys(o).forEach(function(a) {
function aee(e) {
      var o = t.elements[r], s = t.attributes[r] || {}, a = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : n[r]), c = a.reduce(function(f, h) {
        return f[h] = "", f;
      !wl(o) || !Cc(o) || (Object.assign(o.style, c), Object.keys(s).forEach(function(f) {
const lee = {
  fn: see,
  effect: aee,
function yc(e) {
var rm = Math.max, FT = Math.min, Kv = Math.round;
function bM() {
function vV() {
  return !/^((?!chrome|android).)*safari/i.test(bM());
function Yv(e, t, n) {
  t && wl(e) && (o = e.offsetWidth > 0 && Kv(r.width) / e.offsetWidth || 1, s = e.offsetHeight > 0 && Kv(r.height) / e.offsetHeight || 1);
  var a = dm(e) ? Fa(e) : window, c = a.visualViewport, f = !vV() && n, h = (r.left + (f && c ? c.offsetLeft : 0)) / o, g = (r.top + (f && c ? c.offsetTop : 0)) / s, v = r.width / o, w = r.height / s;
    width: v,
    right: h + v,
    left: h,
    x: h,
function rD(e) {
  var t = Yv(e), n = e.offsetWidth, r = e.offsetHeight;
function yV(e, t) {
  if (n && nD(n)) {
function kd(e) {
  return Fa(e).getComputedStyle(e);
function uee(e) {
  return ["table", "td", "th"].indexOf(Cc(e)) >= 0;
function up(e) {
  return ((dm(e) ? e.ownerDocument : (
function V_(e) {
  return Cc(e) === "html" ? e : (
    (nD(e) ? e.host : null) || // ShadowRoot detected
    up(e)
function mF(e) {
  return !wl(e) || // https://github.com/popperjs/popper-core/issues/837
  kd(e).position === "fixed" ? null : e.offsetParent;
function cee(e) {
  var t = /firefox/i.test(bM()), n = /Trident/i.test(bM());
  if (n && wl(e)) {
    var r = kd(e);
  var o = V_(e);
  for (nD(o) && (o = o.host); wl(o) && ["html", "body"].indexOf(Cc(o)) < 0; ) {
    var s = kd(o);
function bC(e) {
  for (var t = Fa(e), n = mF(e); n && uee(n) && kd(n).position === "static"; )
    n = mF(n);
  return n && (Cc(n) === "html" || Cc(n) === "body" && kd(n).position === "static") ? t : n || cee(e) || t;
function oD(e) {
function wS(e, t, n) {
  return rm(e, FT(t, n));
function dee(e, t, n) {
  var r = wS(e, t, n);
function bV() {
function wV(e) {
  return Object.assign({}, bV(), e);
function SV(e, t) {
var fee = function(t, n) {
  })) : t, wV(typeof t != "number" ? t : SV(t, yC));
function pee(e) {
  var t, n = e.state, r = e.name, o = e.options, s = n.elements.arrow, a = n.modifiersData.popperOffsets, c = yc(n.placement), f = oD(c), h = [ca, Rl].indexOf(c) >= 0, g = h ? "height" : "width";
    var v = fee(o.padding, n), w = rD(s), C = f === "y" ? ua : ca, T = f === "y" ? Ol : Rl, E = n.rects.reference[g] + n.rects.reference[f] - a[f] - n.rects.popper[g], O = a[f] - n.rects.reference[f], P = bC(s), I = P ? f === "y" ? P.clientHeight || 0 : P.clientWidth || 0 : 0, M = E / 2 - O / 2, A = v[C], k = I - w[g] - v[T], j = I / 2 - w[g] / 2 + M, B = wS(A, j, k), H = f;
    n.modifiersData[r] = (t = {}, t[H] = B, t.centerOffset = B - j, t);
function hee(e) {
  o != null && (typeof o == "string" && (o = t.elements.popper.querySelector(o), !o) || yV(t.elements.popper, o) && (t.elements.arrow = o));
const mee = {
  fn: pee,
  effect: hee,
function Xv(e) {
var gee = {
function vee(e, t) {
    x: Kv(n * o) / o || 0,
    y: Kv(r * o) / o || 0
function gF(e) {
  var t, n = e.popper, r = e.popperRect, o = e.placement, s = e.variation, a = e.offsets, c = e.position, f = e.gpuAcceleration, h = e.adaptive, g = e.roundOffsets, v = e.isFixed, w = a.x, C = w === void 0 ? 0 : w, T = a.y, E = T === void 0 ? 0 : T, O = typeof g == "function" ? g({
  var P = a.hasOwnProperty("x"), I = a.hasOwnProperty("y"), M = ca, A = ua, k = window;
  if (h) {
    var j = bC(n), B = "clientHeight", H = "clientWidth";
    if (j === Fa(n) && (j = up(n), kd(j).position !== "static" && c === "absolute" && (B = "scrollHeight", H = "scrollWidth")), j = j, o === ua || (o === ca || o === Rl) && s === VS) {
      A = Ol;
      var F = v && j === k && k.visualViewport ? k.visualViewport.height : (
        j[B]
      E -= F - r.height, E *= f ? 1 : -1;
    if (o === ca || (o === ua || o === Ol) && s === VS) {
      M = Rl;
      var D = v && j === k && k.visualViewport ? k.visualViewport.width : (
        j[H]
      C -= D - r.width, C *= f ? 1 : -1;
  }, h && gee), U = g === !0 ? vee({
  }, Fa(n)) : {
  if (C = U.x, E = U.y, f) {
    var K;
    return Object.assign({}, q, (K = {}, K[A] = I ? "0" : "", K[M] = P ? "0" : "", K.transform = (k.devicePixelRatio || 1) <= 1 ? "translate(" + C + "px, " + E + "px)" : "translate3d(" + C + "px, " + E + "px, 0)", K));
  return Object.assign({}, q, (t = {}, t[A] = I ? E + "px" : "", t[M] = P ? C + "px" : "", t.transform = "", t));
function yee(e) {
  var t = e.state, n = e.options, r = n.gpuAcceleration, o = r === void 0 ? !0 : r, s = n.adaptive, a = s === void 0 ? !0 : s, c = n.roundOffsets, f = c === void 0 ? !0 : c, h = {
    placement: yc(t.placement),
    variation: Xv(t.placement),
  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, gF(Object.assign({}, h, {
  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, gF(Object.assign({}, h, {
const bee = {
  fn: yee,
var jE = {
function wee(e) {
  var t = e.state, n = e.instance, r = e.options, o = r.scroll, s = o === void 0 ? !0 : o, a = r.resize, c = a === void 0 ? !0 : a, f = Fa(t.elements.popper), h = [].concat(t.scrollParents.reference, t.scrollParents.popper);
  return s && h.forEach(function(g) {
    g.addEventListener("scroll", n.update, jE);
  }), c && f.addEventListener("resize", n.update, jE), function() {
    s && h.forEach(function(g) {
      g.removeEventListener("scroll", n.update, jE);
    }), c && f.removeEventListener("resize", n.update, jE);
const See = {
  effect: wee,
var Cee = {
function vT(e) {
    return Cee[t];
var xee = {
function vF(e) {
    return xee[t];
function iD(e) {
  var t = Fa(e), n = t.pageXOffset, r = t.pageYOffset;
function sD(e) {
  return Yv(up(e)).left + iD(e).scrollLeft;
function Eee(e, t) {
  var n = Fa(e), r = up(e), o = n.visualViewport, s = r.clientWidth, a = r.clientHeight, c = 0, f = 0;
    var h = vV();
    (h || !h && t === "fixed") && (c = o.offsetLeft, f = o.offsetTop);
    x: c + sD(e),
function Tee(e) {
  var t, n = up(e), r = iD(e), o = (t = e.ownerDocument) == null ? void 0 : t.body, s = rm(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = rm(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), c = -r.scrollLeft + sD(e), f = -r.scrollTop;
  return kd(o || n).direction === "rtl" && (c += rm(n.clientWidth, o ? o.clientWidth : 0) - s), {
function aD(e) {
  var t = kd(e), n = t.overflow, r = t.overflowX, o = t.overflowY;
function CV(e) {
  return ["html", "body", "#document"].indexOf(Cc(e)) >= 0 ? e.ownerDocument.body : wl(e) && aD(e) ? e : CV(V_(e));
function SS(e, t) {
  var r = CV(e), o = r === ((n = e.ownerDocument) == null ? void 0 : n.body), s = Fa(r), a = o ? [s].concat(s.visualViewport || [], aD(r) ? r : []) : r, c = t.concat(a);
    c.concat(SS(V_(a)))
function wM(e) {
function _ee(e, t) {
  var n = Yv(e, !1, t === "fixed");
function yF(e, t, n) {
  return t === mV ? wM(Eee(e, n)) : dm(t) ? _ee(t, n) : wM(Tee(up(e)));
function Oee(e) {
  var t = SS(V_(e)), n = ["absolute", "fixed"].indexOf(kd(e).position) >= 0, r = n && wl(e) ? bC(e) : e;
  return dm(r) ? t.filter(function(o) {
    return dm(o) && yV(o, r) && Cc(o) !== "body";
function Ree(e, t, n, r) {
  var o = t === "clippingParents" ? Oee(e) : [].concat(t), s = [].concat(o, [n]), a = s[0], c = s.reduce(function(f, h) {
    var g = yF(e, h, r);
    return f.top = rm(g.top, f.top), f.right = FT(g.right, f.right), f.bottom = FT(g.bottom, f.bottom), f.left = rm(g.left, f.left), f;
  }, yF(e, a, r));
function xV(e) {
  var t = e.reference, n = e.element, r = e.placement, o = r ? yc(r) : null, s = r ? Xv(r) : null, a = t.x + t.width / 2 - n.width / 2, c = t.y + t.height / 2 - n.height / 2, f;
    case ua:
    case Ol:
    case Rl:
    case ca:
  var h = o ? oD(o) : null;
  if (h != null) {
    var g = h === "y" ? "height" : "width";
      case qv:
        f[h] = f[h] - (t[g] / 2 - n[g] / 2);
      case VS:
        f[h] = f[h] + (t[g] / 2 - n[g] / 2);
function US(e, t) {
  var n = t, r = n.placement, o = r === void 0 ? e.placement : r, s = n.strategy, a = s === void 0 ? e.strategy : s, c = n.boundary, f = c === void 0 ? KZ : c, h = n.rootBoundary, g = h === void 0 ? mV : h, v = n.elementContext, w = v === void 0 ? Hw : v, C = n.altBoundary, T = C === void 0 ? !1 : C, E = n.padding, O = E === void 0 ? 0 : E, P = wV(typeof O != "number" ? O : SV(O, yC)), I = w === Hw ? YZ : Hw, M = e.rects.popper, A = e.elements[T ? I : w], k = Ree(dm(A) ? A : A.contextElement || up(e.elements.popper), f, g, a), j = Yv(e.elements.reference), B = xV({
    reference: j,
  }), H = wM(Object.assign({}, M, B)), F = w === Hw ? H : j, D = {
    top: k.top - F.top + P.top,
    bottom: F.bottom - k.bottom + P.bottom,
    left: k.left - F.left + P.left,
    right: F.right - k.right + P.right
  if (w === Hw && q) {
    var U = q[o];
    Object.keys(D).forEach(function(K) {
      var ee = [Rl, Ol].indexOf(K) >= 0 ? 1 : -1, G = [ua, Ol].indexOf(K) >= 0 ? "y" : "x";
      D[K] += U[G] * ee;
  return D;
function kee(e, t) {
  var n = t, r = n.placement, o = n.boundary, s = n.rootBoundary, a = n.padding, c = n.flipVariations, f = n.allowedAutoPlacements, h = f === void 0 ? gV : f, g = Xv(r), v = g ? c ? hF : hF.filter(function(T) {
    return Xv(T) === g;
  }) : yC, w = v.filter(function(T) {
    return h.indexOf(T) >= 0;
  w.length === 0 && (w = v);
    return T[E] = US(e, {
    })[yc(E)], T;
function Pee(e) {
  if (yc(e) === tD)
  var t = vT(e);
  return [vF(e), t, vF(t)];
function Mee(e) {
    for (var o = n.mainAxis, s = o === void 0 ? !0 : o, a = n.altAxis, c = a === void 0 ? !0 : a, f = n.fallbackPlacements, h = n.padding, g = n.boundary, v = n.rootBoundary, w = n.altBoundary, C = n.flipVariations, T = C === void 0 ? !0 : C, E = n.allowedAutoPlacements, O = t.options.placement, P = yc(O), I = P === O, M = f || (I || !T ? [vT(O)] : Pee(O)), A = [O].concat(M).reduce(function(ue, he) {
      return ue.concat(yc(he) === tD ? kee(t, {
        rootBoundary: v,
        padding: h,
    }, []), k = t.rects.reference, j = t.rects.popper, B = /* @__PURE__ */ new Map(), H = !0, F = A[0], D = 0; D < A.length; D++) {
      var q = A[D], U = yc(q), K = Xv(q) === qv, ee = [ua, Ol].indexOf(U) >= 0, G = ee ? "width" : "height", Y = US(t, {
        rootBoundary: v,
        padding: h
      }), X = ee ? K ? Rl : ca : K ? Ol : ua;
      k[G] > j[G] && (X = vT(X));
      var te = vT(X), re = [];
      if (s && re.push(Y[U] <= 0), c && re.push(Y[X] <= 0, Y[te] <= 0), re.every(function(ue) {
        F = q, H = !1;
      B.set(q, re);
    if (H)
      for (var Q = T ? 3 : 1, V = function(he) {
        var ge = A.find(function(fe) {
          var pe = B.get(fe);
          return F = ge, "break";
        var de = V(ie);
    t.placement !== F && (t.modifiersData[r]._skip = !0, t.placement = F, t.reset = !0);
const Iee = {
  fn: Mee,
function bF(e, t, n) {
function wF(e) {
  return [ua, Rl, Ol, ca].some(function(t) {
function Dee(e) {
  var t = e.state, n = e.name, r = t.rects.reference, o = t.rects.popper, s = t.modifiersData.preventOverflow, a = US(t, {
  }), c = US(t, {
  }), f = bF(a, r), h = bF(c, o, s), g = wF(f), v = wF(h);
    popperEscapeOffsets: h,
    hasPopperEscaped: v
    "data-popper-escaped": v
const Aee = {
  fn: Dee
function Nee(e, t, n) {
  var r = yc(e), o = [ca, ua].indexOf(r) >= 0 ? -1 : 1, s = typeof n == "function" ? n(Object.assign({}, t, {
  return a = a || 0, c = (c || 0) * o, [ca, Rl].indexOf(r) >= 0 ? {
function $ee(e) {
  var t = e.state, n = e.options, r = e.name, o = n.offset, s = o === void 0 ? [0, 0] : o, a = gV.reduce(function(g, v) {
    return g[v] = Nee(v, t.rects, s), g;
  }, {}), c = a[t.placement], f = c.x, h = c.y;
  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += f, t.modifiersData.popperOffsets.y += h), t.modifiersData[r] = a;
const Lee = {
  fn: $ee
function jee(e) {
  t.modifiersData[n] = xV({
const Fee = {
  fn: jee,
function zee(e) {
function Bee(e) {
  var t = e.state, n = e.options, r = e.name, o = n.mainAxis, s = o === void 0 ? !0 : o, a = n.altAxis, c = a === void 0 ? !1 : a, f = n.boundary, h = n.rootBoundary, g = n.altBoundary, v = n.padding, w = n.tether, C = w === void 0 ? !0 : w, T = n.tetherOffset, E = T === void 0 ? 0 : T, O = US(t, {
    rootBoundary: h,
    padding: v,
  }), P = yc(t.placement), I = Xv(t.placement), M = !I, A = oD(P), k = zee(A), j = t.modifiersData.popperOffsets, B = t.rects.reference, H = t.rects.popper, F = typeof E == "function" ? E(Object.assign({}, t.rects, {
  })) : E, D = typeof F == "number" ? {
    mainAxis: F,
    altAxis: F
  }, F), q = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, U = {
  if (j) {
      var K, ee = A === "y" ? ua : ca, G = A === "y" ? Ol : Rl, Y = A === "y" ? "height" : "width", X = j[A], te = X + O[ee], re = X - O[G], Q = C ? -H[Y] / 2 : 0, V = I === qv ? B[Y] : H[Y], ie = I === qv ? -H[Y] : -B[Y], de = t.elements.arrow, ue = C && de ? rD(de) : {
      }, he = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : bV(), ge = he[ee], fe = he[G], pe = wS(0, B[Y], ue[Y]), be = M ? B[Y] / 2 - Q - pe - ge - D.mainAxis : V - pe - ge - D.mainAxis, we = M ? -B[Y] / 2 + Q + pe + fe + D.mainAxis : ie + pe + fe + D.mainAxis, _e = t.elements.arrow && bC(t.elements.arrow), ce = _e ? A === "y" ? _e.clientTop || 0 : _e.clientLeft || 0 : 0, Ce = (K = q == null ? void 0 : q[A]) != null ? K : 0, Ne = X + be - Ce - ce, Be = X + we - Ce, tt = wS(C ? FT(te, Ne) : te, X, C ? rm(re, Be) : re);
      j[A] = tt, U[A] = tt - X;
      var Le, rt = A === "x" ? ua : ca, ot = A === "x" ? Ol : Rl, wt = j[k], gt = k === "y" ? "height" : "width", nt = wt + O[rt], Ft = wt - O[ot], ut = [ua, ca].indexOf(P) !== -1, Et = (Le = q == null ? void 0 : q[k]) != null ? Le : 0, Tt = ut ? nt : wt - B[gt] - H[gt] - Et + D.altAxis, At = ut ? wt + B[gt] + H[gt] - Et - D.altAxis : Ft, vt = C && ut ? dee(Tt, wt, At) : wS(C ? Tt : nt, wt, C ? At : Ft);
      j[k] = vt, U[k] = vt - wt;
    t.modifiersData[r] = U;
const Hee = {
  fn: Bee,
function Vee(e) {
function Uee(e) {
  return e === Fa(e) || !wl(e) ? iD(e) : Vee(e);
function Wee(e) {
  var t = e.getBoundingClientRect(), n = Kv(t.width) / e.offsetWidth || 1, r = Kv(t.height) / e.offsetHeight || 1;
function Gee(e, t, n) {
  var r = wl(t), o = wl(t) && Wee(t), s = up(t), a = Yv(e, o, n), c = {
  return (r || !r && !n) && ((Cc(t) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
  aD(s)) && (c = Uee(t)), wl(t) ? (f = Yv(t, !0), f.x += t.clientLeft, f.y += t.clientTop) : s && (f.x = sD(s))), {
function qee(e) {
function Kee(e) {
  var t = qee(e);
  return iee.reduce(function(n, r) {
function Yee(e) {
function Xee(e) {
var SF = {
function CF() {
function Qee(e) {
  var t = e, n = t.defaultModifiers, r = n === void 0 ? [] : n, o = t.defaultOptions, s = o === void 0 ? SF : o;
  return function(c, f, h) {
    h === void 0 && (h = s);
      options: Object.assign({}, SF, s),
    }, v = [], w = !1, C = {
      setOptions: function(P) {
        var I = typeof P == "function" ? P(g.options) : P;
          reference: dm(c) ? SS(c) : c.contextElement ? SS(c.contextElement) : [],
          popper: SS(f)
        var M = Kee(Xee([].concat(r, g.options.modifiers)));
        return g.orderedModifiers = M.filter(function(A) {
          return A.enabled;
          var P = g.elements, I = P.reference, M = P.popper;
          if (CF(I, M)) {
              reference: Gee(I, bC(M), g.options.strategy === "fixed"),
              popper: rD(M)
            }, g.reset = !1, g.placement = g.options.placement, g.orderedModifiers.forEach(function(D) {
              return g.modifiersData[D.name] = Object.assign({}, D.data);
            for (var A = 0; A < g.orderedModifiers.length; A++) {
                g.reset = !1, A = -1;
              var k = g.orderedModifiers[A], j = k.fn, B = k.options, H = B === void 0 ? {} : B, F = k.name;
              typeof j == "function" && (g = j({
                options: H,
                name: F,
      update: Yee(function() {
    if (!CF(c, f))
    C.setOptions(h).then(function(O) {
      !w && h.onFirstUpdate && h.onFirstUpdate(O);
        var P = O.name, I = O.options, M = I === void 0 ? {} : I, A = O.effect;
        if (typeof A == "function") {
          var k = A({
            name: P,
          }), j = function() {
          v.push(k || j);
      v.forEach(function(O) {
      }), v = [];
var Jee = [See, Fee, bee, lee, Lee, Iee, Hee, mee, Aee], Zee = /* @__PURE__ */ Qee({
  defaultModifiers: Jee
function ete(e) {
const WS = /* @__PURE__ */ x.forwardRef(function(t, n) {
  } = t, [a, c] = x.useState(null), f = Ir(/* @__PURE__ */ x.isValidElement(r) ? lp(r) : null, n);
  if (Lr(() => {
    s || c(ete(o) || document.body);
  }, [o, s]), Lr(() => {
      return cM(n, a), () => {
        cM(n, null);
      const h = {
      return /* @__PURE__ */ x.cloneElement(r, h);
  return a && /* @__PURE__ */ E_.createPortal(r, a);
process.env.NODE_ENV !== "production" && (WS.propTypes = {
  container: u.oneOfType([Tl, u.func]),
process.env.NODE_ENV !== "production" && (WS.propTypes = vC(WS.propTypes));
function tte(e) {
  return ln("MuiPopper", e);
fn("MuiPopper", ["root"]);
function nte(e, t) {
function zT(e) {
function U_(e) {
function rte(e) {
  return !U_(e);
const ote = (e) => {
  }, tte, t);
}, ite = {}, ste = /* @__PURE__ */ x.forwardRef(function(t, n) {
    placement: h,
    popperRef: v,
  } = t, P = x.useRef(null), I = Ir(P, n), M = x.useRef(null), A = Ir(M, v), k = x.useRef(A);
  Lr(() => {
    k.current = A;
  }, [A]), x.useImperativeHandle(v, () => M.current, []);
  const j = nte(h, s), [B, H] = x.useState(j), [F, D] = x.useState(zT(r));
    r && D(zT(r));
  }, [r]), Lr(() => {
    if (!F || !f)
      H(te.placement);
    if (process.env.NODE_ENV !== "production" && F && U_(F) && F.nodeType === 1) {
      const te = F.getBoundingClientRect();
    let Y = [{
    c != null && (Y = Y.concat(c)), g && g.modifiers != null && (Y = Y.concat(g.modifiers));
    const X = Zee(F, P.current, {
      placement: j,
      modifiers: Y
    return k.current(X), () => {
      X.destroy(), k.current(null);
  }, [F, a, c, f, g, j]);
    placement: B
  const U = ote(t), K = C.root ?? "div", ee = YH({
    elementType: K,
    className: U.root
  return /* @__PURE__ */ $.jsx(K, {
}), EV = /* @__PURE__ */ x.forwardRef(function(t, n) {
    modifiers: h,
    placement: v = "bottom",
    popperOptions: w = ite,
    slots: P = {},
  } = t, [M, A] = x.useState(!0), k = () => {
    A(!1);
  }, j = () => {
    A(!0);
  let B;
    B = s;
    const D = zT(r);
    B = D && U_(D) ? go(D).body : go(null).body;
  const H = !g && f && (!E || M) ? "none" : void 0, F = E ? {
    onEnter: k,
    onExited: j
  return /* @__PURE__ */ $.jsx(WS, {
    container: B,
    children: /* @__PURE__ */ $.jsx(ste, {
      modifiers: h,
      placement: v,
      slots: P,
        display: H,
      TransitionProps: F,
process.env.NODE_ENV !== "production" && (EV.propTypes = {
  anchorEl: ja(u.oneOfType([Tl, u.object, u.func]), (e) => {
      const t = zT(e.anchorEl);
      if (t && U_(t) && t.nodeType === 1) {
      } else if (!t || typeof t.getBoundingClientRect != "function" || rte(t) && t.contextElement != null && t.contextElement.nodeType !== 1)
  container: u.oneOfType([Tl, u.func]),
  popperRef: pa,
const ate = Ue(EV, {
})({}), cp = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = my(), o = gn({
    container: h,
    keepMounted: v,
    transition: P,
    ...A
  } = o, k = (I == null ? void 0 : I.root) ?? (c == null ? void 0 : c.Root), j = {
    container: h,
    keepMounted: v,
    transition: P,
    ...A
  return /* @__PURE__ */ $.jsx(ate, {
      root: k
    ...j,
process.env.NODE_ENV !== "production" && (cp.propTypes = {
  anchorEl: u.oneOfType([Tl, u.object, u.func]),
  container: u.oneOfType([Tl, u.func]),
  popperRef: pa,
function lte(e) {
  return ln("MuiListSubheader", e);
fn("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
const ute = (e) => {
  return mt(a, lte, t);
}, cte = Ue("li", {
}))), BT = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    inset: h = !1,
  } = r, v = {
    inset: h
  }, w = ute(v);
  return /* @__PURE__ */ $.jsx(cte, {
    ownerState: v,
BT && (BT.muiSkipListHighlight = !0);
process.env.NODE_ENV !== "production" && (BT.propTypes = {
const dte = Tn(/* @__PURE__ */ $.jsx("path", {
function fte(e) {
  return ln("MuiChip", e);
const Kn = fn("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorDefault", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]), pte = (e) => {
  } = e, h = {
  return mt(h, fte, t);
}, hte = Ue("div", {
      [`& .${Kn.avatar}`]: t.avatar
      [`& .${Kn.avatar}`]: t[`avatar${He(c)}`]
      [`& .${Kn.avatar}`]: t[`avatarColor${He(r)}`]
      [`& .${Kn.icon}`]: t.icon
      [`& .${Kn.icon}`]: t[`icon${He(c)}`]
      [`& .${Kn.icon}`]: t[`iconColor${He(o)}`]
      [`& .${Kn.deleteIcon}`]: t.deleteIcon
      [`& .${Kn.deleteIcon}`]: t[`deleteIcon${He(c)}`]
      [`& .${Kn.deleteIcon}`]: t[`deleteIconColor${He(r)}`]
      [`& .${Kn.deleteIcon}`]: t[`deleteIcon${He(f)}Color${He(r)}`]
    [`&.${Kn.disabled}`]: {
    [`& .${Kn.avatar}`]: {
    [`& .${Kn.avatarColorPrimary}`]: {
    [`& .${Kn.avatarColorSecondary}`]: {
    [`& .${Kn.avatarSmall}`]: {
    [`& .${Kn.icon}`]: {
    [`& .${Kn.deleteIcon}`]: {
      color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.26)` : rn(e.palette.text.primary, 0.26),
        color: e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / 0.4)` : rn(e.palette.text.primary, 0.4)
        [`& .${Kn.icon}`]: {
        [`& .${Kn.deleteIcon}`]: {
    }, ...Object.entries(e.palette).filter(no(["contrastText"])).map(([n]) => ({
        [`& .${Kn.deleteIcon}`]: {
          color: e.vars ? `rgba(${e.vars.palette[n].contrastTextChannel} / 0.7)` : rn(e.palette[n].contrastText, 0.7),
        [`& .${Kn.icon}`]: {
        [`& .${Kn.icon}`]: {
        [`&.${Kn.focusVisible}`]: {
          backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : rn(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }, ...Object.entries(e.palette).filter(no(["dark"])).map(([n]) => ({
        [`&.${Kn.focusVisible}`]: {
          backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : rn(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
        [`&.${Kn.focusVisible}`]: {
          backgroundColor: e.vars ? `rgba(${e.vars.palette.action.selectedChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : rn(e.palette.action.selected, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
    }, ...Object.entries(e.palette).filter(no(["dark"])).map(([n]) => ({
        [`&:hover, &.${Kn.focusVisible}`]: {
        [`&.${Kn.clickable}:hover`]: {
        [`&.${Kn.focusVisible}`]: {
        [`& .${Kn.avatar}`]: {
        [`& .${Kn.avatarSmall}`]: {
        [`& .${Kn.icon}`]: {
        [`& .${Kn.iconSmall}`]: {
        [`& .${Kn.deleteIcon}`]: {
        [`& .${Kn.deleteIconSmall}`]: {
    }, ...Object.entries(e.palette).filter(no()).map(([n]) => ({
        border: `1px solid ${e.vars ? `rgba(${e.vars.palette[n].mainChannel} / 0.7)` : rn(e.palette[n].main, 0.7)}`,
        [`&.${Kn.clickable}:hover`]: {
          backgroundColor: e.vars ? `rgba(${e.vars.palette[n].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : rn(e.palette[n].main, e.palette.action.hoverOpacity)
        [`&.${Kn.focusVisible}`]: {
          backgroundColor: e.vars ? `rgba(${e.vars.palette[n].mainChannel} / ${e.vars.palette.action.focusOpacity})` : rn(e.palette[n].main, e.palette.action.focusOpacity)
        [`& .${Kn.deleteIcon}`]: {
          color: e.vars ? `rgba(${e.vars.palette[n].mainChannel} / 0.7)` : rn(e.palette[n].main, 0.7),
})), mte = Ue("span", {
function xF(e) {
const _d = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    deleteIcon: h,
    icon: v,
    size: P = "medium",
    skipFocusWhenDisabled: A = !1,
    ...k
  } = r, j = x.useRef(null), B = Ir(j, n), H = (re) => {
  }, F = (re) => {
    re.currentTarget === re.target && xF(re) && re.preventDefault(), E && E(re);
  }, D = (re) => {
    re.currentTarget === re.target && T && xF(re) && T(re), O && O(re);
  }, q = a !== !1 && C ? !0 : a, U = q || T ? cm : f || "div", K = {
    component: U,
    size: P,
    iconColor: /* @__PURE__ */ x.isValidElement(v) && v.props.color || c,
  }, ee = pte(K), G = U === cm ? {
  let Y = null;
  T && (Y = h && /* @__PURE__ */ x.isValidElement(h) ? /* @__PURE__ */ x.cloneElement(h, {
    className: et(h.props.className, ee.deleteIcon),
    onClick: H
  }) : /* @__PURE__ */ $.jsx(dte, {
    onClick: H
  return v && /* @__PURE__ */ x.isValidElement(v) && (te = /* @__PURE__ */ x.cloneElement(v, {
    className: et(ee.icon, v.props.className)
  })), process.env.NODE_ENV !== "production" && X && te && console.error("MUI: The Chip component can not handle the avatar and the icon prop at the same time. Pick one."), /* @__PURE__ */ $.jsxs(hte, {
    as: U,
    onKeyDown: F,
    onKeyUp: D,
    ref: B,
    tabIndex: A && g ? -1 : M,
    ownerState: K,
    ...k,
    children: [X || te, /* @__PURE__ */ $.jsx(mte, {
      ownerState: K,
    }), Y]
process.env.NODE_ENV !== "production" && (_d.propTypes = {
  children: sQ,
function FE(e) {
const gte = {
function vte(e) {
function EF(e) {
  return vte(e) || e.outerHeightStyle === 0 && !e.overflowing;
const TV = /* @__PURE__ */ x.forwardRef(function(t, n) {
    current: h
  } = x.useRef(c != null), g = x.useRef(null), v = Ir(n, g), w = x.useRef(null), C = x.useRef(null), T = x.useCallback(() => {
    const M = g.current, A = C.current;
    if (!M || !A)
    const j = _l(M).getComputedStyle(M);
    if (j.width === "0px")
    A.style.width = j.width, A.value = M.value || t.placeholder || "x", A.value.slice(-1) === `
` && (A.value += " ");
    const B = j.boxSizing, H = FE(j.paddingBottom) + FE(j.paddingTop), F = FE(j.borderBottomWidth) + FE(j.borderTopWidth), D = A.scrollHeight;
    A.value = "x";
    const q = A.scrollHeight;
    let U = D;
    s && (U = Math.max(Number(s) * q, U)), o && (U = Math.min(Number(o) * q, U)), U = Math.max(U, q);
    const K = U + (B === "border-box" ? H + F : 0), ee = Math.abs(U - D) <= 1;
      outerHeightStyle: K,
  }, [o, s, t.placeholder]), E = Fn(() => {
    const M = g.current, A = T();
    if (!M || !A || EF(A))
    const k = A.outerHeightStyle;
    return w.current != null && w.current !== k;
    const M = g.current, A = T();
    if (!M || !A || EF(A))
    const k = A.outerHeightStyle;
    w.current !== k && (w.current = k, M.style.height = `${k}px`), M.style.overflow = A.overflowing ? "hidden" : "";
  }, [T]), P = x.useRef(-1);
  Lr(() => {
    const M = BI(O), A = g == null ? void 0 : g.current;
    if (!A)
    const k = _l(A);
    k.addEventListener("resize", M);
    let j;
    return typeof ResizeObserver < "u" && (j = new ResizeObserver(() => {
      E() && (j.unobserve(A), cancelAnimationFrame(P.current), O(), P.current = requestAnimationFrame(() => {
        j.observe(A);
    }), j.observe(A)), () => {
      M.clear(), cancelAnimationFrame(P.current), k.removeEventListener("resize", M), j && j.disconnect();
  }, [T, O, E]), Lr(() => {
    h || O(), r && r(M);
      ref: v,
        ...gte.shadow,
process.env.NODE_ENV !== "production" && (TV.propTypes = {
function SM(e) {
function gm({
const wC = /* @__PURE__ */ x.createContext(void 0);
process.env.NODE_ENV !== "production" && (wC.displayName = "FormControlContext");
function Md() {
  return x.useContext(wC);
function TF(e) {
function HT(e, t = !1) {
  return e && (TF(e.value) && e.value !== "" || t && TF(e.defaultValue) && e.defaultValue !== "");
function yte(e) {
function bte(e) {
  return ln("MuiInputBase", e);
const _i = fn("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var _F;
const W_ = (e, t) => {
}, G_ = (e, t) => {
}, wte = (e) => {
    hiddenLabel: h,
    readOnly: v,
    root: ["root", `color${He(n)}`, r && "disabled", o && "error", f && "fullWidth", a && "focused", c && "formControl", w && w !== "medium" && `size${He(w)}`, g && "multiline", C && "adornedStart", s && "adornedEnd", h && "hiddenLabel", v && "readOnly"],
    input: ["input", r && "disabled", T === "search" && "inputTypeSearch", g && "inputMultiline", w === "small" && "inputSizeSmall", h && "inputHiddenLabel", C && "inputAdornedStart", s && "inputAdornedEnd", v && "readOnly"]
  return mt(E, bte, t);
}, q_ = Ue("div", {
  overridesResolver: W_
  [`&.${_i.disabled}`]: {
}))), K_ = Ue("input", {
  overridesResolver: G_
    [`label[data-shrink=false] + .${_i.formControl} &`]: {
    [`&.${_i.disabled}`]: {
})), OF = XI({
}), vm = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    components: h = {},
    defaultValue: v,
    id: P,
    inputRef: A,
    margin: k,
    maxRows: j,
    minRows: B,
    multiline: H = !1,
    name: F,
    onBlur: D,
    onClick: U,
    onFocus: K,
    placeholder: Y,
    slotProps: V = {},
  }, []), _e = Ir(be, A, M.ref, we), [ce, Ce] = x.useState(!1), Ne = Md();
  const Be = gm({
    !Ne && w && ce && (Ce(!1), D && D());
  }, [Ne, w, ce, D]);
  const tt = Ne && Ne.onFilled, Le = Ne && Ne.onEmpty, rt = x.useCallback((Ie) => {
    HT(Ie) ? tt && tt() : Le && Le();
  }, [tt, Le]);
  Lr(() => {
    K && K(Ie), M.onFocus && M.onFocus(Ie), Ne && Ne.onFocus ? Ne.onFocus(Ie) : Ce(!0);
    D && D(Ie), M.onBlur && M.onBlur(Ie), Ne && Ne.onBlur ? Ne.onBlur(Ie) : Ce(!1);
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info." : wc(1));
    be.current && Ie.currentTarget === Ie.target && be.current.focus(), U && U(Ie);
  H && Ft === "input" && (re ? (process.env.NODE_ENV !== "production" && (B || j) && console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set."), ut = {
    maxRows: j,
    minRows: B,
  }, Ft = TV);
    multiline: H,
  }, At = wte(Tt), vt = ie.root || h.Root || q_, Xe = V.root || g.root || {}, Oe = ie.input || h.Input || K_;
    ...V.input ?? g.input
    children: [!C && typeof OF == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
    (_F || (_F = /* @__PURE__ */ $.jsx(OF, {}))), /* @__PURE__ */ $.jsxs(vt, {
      ...!SM(vt) && {
      children: [de, /* @__PURE__ */ $.jsx(wC.Provider, {
          defaultValue: v,
          id: P,
          name: F,
          placeholder: Y,
          ...!SM(Oe) && {
process.env.NODE_ENV !== "production" && (vm.propTypes = {
  inputComponent: zI,
  inputRef: pa,
function Ste(e) {
  return ln("MuiInput", e);
const Ff = {
  ..._i,
  ...fn("MuiInput", ["root", "underline", "input"])
function Cte(e) {
  return ln("MuiOutlinedInput", e);
const pl = {
  ..._i,
  ...fn("MuiOutlinedInput", ["root", "notchedOutline", "input"])
function xte(e) {
  return ln("MuiFilledInput", e);
const Pa = {
  ..._i,
  ...fn("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
}, _V = Tn(/* @__PURE__ */ $.jsx("path", {
function Ete(e) {
  return ln("MuiAutocomplete", e);
const jn = fn("MuiAutocomplete", ["root", "expanded", "fullWidth", "focused", "focusVisible", "tag", "tagSizeSmall", "tagSizeMedium", "hasPopupIcon", "hasClearIcon", "inputRoot", "input", "inputFocused", "endAdornment", "clearIndicator", "popupIndicator", "popupIndicatorOpen", "popper", "popperDisablePortal", "paper", "listbox", "loading", "noOptions", "option", "groupLabel", "groupUl"]);
var RF, kF;
const Tte = (e) => {
    popupOpen: h,
  } = e, v = {
    popupIndicator: ["popupIndicator", h && "popupIndicatorOpen"],
  return mt(v, Ete, t);
}, _te = Ue("div", {
      [`& .${jn.tag}`]: t.tag
      [`& .${jn.tag}`]: t[`tagSize${He(c)}`]
      [`& .${jn.inputRoot}`]: t.inputRoot
      [`& .${jn.input}`]: t.input
      [`& .${jn.input}`]: a && t.inputFocused
  [`&.${jn.focused} .${jn.clearIndicator}`]: {
    [`&:hover .${jn.clearIndicator}`]: {
  [`& .${jn.tag}`]: {
  [`& .${jn.inputRoot}`]: {
    [`.${jn.hasPopupIcon}&, .${jn.hasClearIcon}&`]: {
    [`.${jn.hasPopupIcon}.${jn.hasClearIcon}&`]: {
    [`& .${jn.input}`]: {
  [`& .${Ff.root}`]: {
  [`& .${Ff.root}.${_i.sizeSmall}`]: {
    [`& .${Ff.input}`]: {
  [`& .${pl.root}`]: {
    [`.${jn.hasPopupIcon}&, .${jn.hasClearIcon}&`]: {
    [`.${jn.hasPopupIcon}.${jn.hasClearIcon}&`]: {
    [`& .${jn.input}`]: {
    [`& .${jn.endAdornment}`]: {
  [`& .${pl.root}.${_i.sizeSmall}`]: {
    [`& .${jn.input}`]: {
  [`& .${Pa.root}`]: {
    [`.${jn.hasPopupIcon}&, .${jn.hasClearIcon}&`]: {
    [`.${jn.hasPopupIcon}.${jn.hasClearIcon}&`]: {
    [`& .${Pa.input}`]: {
    [`& .${jn.endAdornment}`]: {
  [`& .${Pa.root}.${_i.sizeSmall}`]: {
    [`& .${Pa.input}`]: {
  [`& .${_i.hiddenLabel}`]: {
  [`& .${Pa.root}.${_i.hiddenLabel}`]: {
    [`& .${jn.input}`]: {
  [`& .${Pa.root}.${_i.hiddenLabel}.${_i.sizeSmall}`]: {
    [`& .${jn.input}`]: {
  [`& .${jn.input}`]: {
      [`& .${jn.tag}`]: {
      [`& .${jn.input}`]: {
      [`& .${jn.inputRoot}`]: {
}), Ote = Ue("div", {
}), Rte = Ue(hu, {
}), kte = Ue(hu, {
}), Pte = Ue(cp, {
      [`& .${jn.option}`]: t.option
}))), Mte = Ue(la, {
}))), Ite = Ue("div", {
}))), Dte = Ue("div", {
}))), Ate = Ue("ul", {
  [`& .${jn.option}`]: {
    [`&.${jn.focused}`]: {
    [`&.${jn.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : rn(e.palette.primary.main, e.palette.action.selectedOpacity),
      [`&.${jn.focused}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : rn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
      [`&.${jn.focusVisible}`]: {
        backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : rn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
}))), Nte = Ue(BT, {
}))), $te = Ue("ul", {
  [`& .${jn.option}`]: {
}), lD = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    className: h,
    clearIcon: g = RF || (RF = /* @__PURE__ */ $.jsx(fV, {
    clearOnBlur: v = !r.freeSolo,
    disableClearable: P = !1,
    disabledItemsFocusable: A = !1,
    disableListWrap: k = !1,
    disablePortal: j = !1,
    filterOptions: B,
    filterSelectedOptions: H = !1,
    forcePopupIcon: F = "auto",
    freeSolo: D = !1,
    getLimitTagsText: U = (Dn) => `+${Dn}`,
    getOptionDisabled: K,
    isOptionEqualToValue: Y,
    inputValue: V,
    options: Le,
    popupIcon: wt = kF || (kF = /* @__PURE__ */ $.jsx(_V, {})),
    getListboxProps: Lt,
    getOptionProps: Cn,
    value: pn,
    dirty: Or,
    expanded: lr,
    id: Fr,
    popupOpen: Rr,
    focused: Qo,
    focusedTag: Jo,
    setAnchorEl: gr,
    inputValue: Zo,
    groupedOptions: Kr
  } = qZ({
  }), so = !P && !M && Or && !gt, Yr = (!D || F === !0) && F !== !1, {
    onMouseDown: Yi
    ref: ki,
    ...Xi
  } = Lt(), ye = G || ((Dn) => Dn.label ?? Dn), Ye = {
    disablePortal: j,
    expanded: lr,
    focused: Qo,
    hasClearIcon: so,
    hasPopupIcon: Yr,
    inputFocused: Jo === -1,
    popupOpen: Rr,
  }, ft = Tte(Ye), Ct = {
  }, [hn, De] = bn("listbox", {
    elementType: Ate,
    additionalProps: Xi,
    ref: ki
  }), [Re, Je] = bn("paper", {
    elementType: la,
  }), [Bt, jt] = bn("popper", {
    elementType: cp,
      disablePortal: j,
      open: Rr
  if (fe && pn.length > 0) {
    const Dn = (Io) => ({
      ...St(Io)
    Et ? Kt = Et(pn, Dn, Ye) : Kt = pn.map((Io, Pi) => {
        key: Ji,
        ...wi
      } = Dn({
        index: Pi
      return /* @__PURE__ */ $.jsx(_d, {
        label: ye(Io),
        ...wi,
      }, Ji);
    const Dn = Kt.length - ie;
    !Qo && Dn > 0 && (Kt = Kt.splice(0, ie), Kt.push(/* @__PURE__ */ $.jsx("span", {
      children: U(Dn)
  const kr = nt || ((Dn) => /* @__PURE__ */ $.jsxs("li", {
    children: [/* @__PURE__ */ $.jsx(Nte, {
      children: Dn.group
    }), /* @__PURE__ */ $.jsx($te, {
      children: Dn.children
  }, Dn.key)), wn = ut || ((Dn, Io) => {
      key: Pi,
      ...Ji
    } = Dn;
      ...Ji,
      children: ye(Io)
    }, Pi);
  }), xn = (Dn, Io) => {
    const Pi = Cn({
      option: Dn,
      index: Io
    return wn({
      ...Pi,
    }, Dn, {
      selected: Pi["aria-selected"],
      index: Io,
      inputValue: Zo
  }, bi = Ct.slotProps.clearIndicator, As = Ct.slotProps.popupIndicator;
    children: [/* @__PURE__ */ $.jsx(_te, {
      className: et(ft.root, h),
        id: Fr,
          ref: gr,
          onMouseDown: (Dn) => {
            Dn.target === Dn.currentTarget && Yi(Dn);
          ...(so || Yr) && {
            endAdornment: /* @__PURE__ */ $.jsxs(Ote, {
              children: [so ? /* @__PURE__ */ $.jsx(Rte, {
                ...bi,
                className: et(ft.clearIndicator, bi == null ? void 0 : bi.className),
              }) : null, Yr ? /* @__PURE__ */ $.jsx(kte, {
                "aria-label": Rr ? T : tt,
                title: Rr ? T : tt,
                ...As,
                className: et(ft.popupIndicator, As == null ? void 0 : As.className),
    }), Wt ? /* @__PURE__ */ $.jsx(Pte, {
      children: /* @__PURE__ */ $.jsxs(Mte, {
        children: [he && Kr.length === 0 ? /* @__PURE__ */ $.jsx(Ite, {
        }) : null, Kr.length === 0 && !D && !he ? /* @__PURE__ */ $.jsx(Dte, {
          onMouseDown: (Dn) => {
            Dn.preventDefault();
        }) : null, Kr.length > 0 ? /* @__PURE__ */ $.jsx(hn, {
          children: Kr.map((Dn, Io) => X ? kr({
            key: Dn.key,
            group: Dn.group,
            children: Dn.options.map((Pi, Ji) => xn(Pi, Dn.index + Ji))
          }) : xn(Dn, Io))
process.env.NODE_ENV !== "production" && (lD.propTypes = {
  defaultValue: ja(u.any, (e) => e.multiple && e.defaultValue !== void 0 && !Array.isArray(e.defaultValue) ? new Error(["MUI: The Autocomplete expects the `defaultValue` prop to be an array when `multiple={true}` or undefined.", `However, ${e.defaultValue} was provided.`].join(`
  limitTags: nm,
  value: ja(u.any, (e) => e.multiple && e.value !== void 0 && !Array.isArray(e.value) ? new Error(["MUI: The Autocomplete expects the `value` prop to be an array when `multiple={true}` or undefined.", `However, ${e.value} was provided.`].join(`
const Lte = {
}, OV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = za(), o = {
    in: h,
    onEntered: v,
    timeout: P = o,
    TransitionComponent: I = Cu,
  } = t, A = x.useRef(null), k = Ir(A, lp(c), n), j = (ee) => (G) => {
      const Y = A.current;
      G === void 0 ? ee(Y) : ee(Y, G);
  }, B = j(w), H = j((ee, G) => {
    eD(ee);
    const Y = Gv({
      timeout: P,
    ee.style.webkitTransition = r.transitions.create("opacity", Y), ee.style.transition = r.transitions.create("opacity", Y), g && g(ee, G);
  }), F = j(v), D = j(E), q = j((ee) => {
    const G = Gv({
      timeout: P,
  }), U = j(T), K = (ee) => {
    s && s(A.current, ee);
    in: h,
    nodeRef: A,
    onEnter: H,
    onEntered: F,
    onEntering: B,
    onExited: U,
    onExiting: D,
    addEndListener: K,
    timeout: P,
      ...Y
        visibility: ee === "exited" && !h ? "hidden" : void 0,
        ...Lte[ee],
      ref: k,
      ...Y
process.env.NODE_ENV !== "production" && (OV.propTypes = {
  children: ap.isRequired,
function jte(e) {
  return ln("MuiBackdrop", e);
fn("MuiBackdrop", ["root", "invisible"]);
const Fte = (e) => {
  }, jte, t);
}, zte = Ue("div", {
}), RV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    components: h = {},
    slotProps: v = {},
  }, P = Fte(O), I = {
    root: h.Root,
    ...v
  }, A = {
  }, [k, j] = bn("root", {
    elementType: zte,
    externalForwardedProps: A,
    className: et(P.root, s),
  }), [B, H] = bn("transition", {
    elementType: OV,
    externalForwardedProps: A,
  return /* @__PURE__ */ $.jsx(B, {
    ...H,
    children: /* @__PURE__ */ $.jsx(k, {
      ...j,
      classes: P,
process.env.NODE_ENV !== "production" && (RV.propTypes = {
function Bte(e) {
  } = e, s = VI({
  } = a ? s : e, h = c && Number(c) > f ? `${f}+` : c;
    displayValue: h
function Hte(e) {
  return ln("MuiBadge", e);
const Df = fn("MuiBadge", [
]), dP = 10, fP = 4, Vte = (e) => {
  return mt(c, Hte, a);
}, Ute = Ue("span", {
}), Wte = Ue("span", {
  minWidth: dP * 2,
  height: dP * 2,
  borderRadius: dP,
  variants: [...Object.entries(e.palette).filter(no(["contrastText"])).map(([t]) => ({
      borderRadius: fP,
      height: fP * 2,
      minWidth: fP * 2,
      [`&.${Df.invisible}`]: {
      [`&.${Df.invisible}`]: {
      [`&.${Df.invisible}`]: {
      [`&.${Df.invisible}`]: {
      [`&.${Df.invisible}`]: {
      [`&.${Df.invisible}`]: {
      [`&.${Df.invisible}`]: {
      [`&.${Df.invisible}`]: {
function PF(e) {
const kV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    componentsProps: h = {},
    overlap: v = "rectangular",
    slotProps: P,
    ...A
    badgeContent: k,
    invisible: j,
    max: B,
    displayValue: H
  } = Bte({
  }), F = VI({
    anchorOrigin: PF(o),
    overlap: v,
  }), D = j || k == null && M !== "dot", {
    overlap: U = v,
    anchorOrigin: K,
  } = D ? F : r, G = PF(K), Y = ee !== "dot" ? H : void 0, X = {
    badgeContent: k,
    invisible: D,
    max: B,
    displayValue: Y,
    overlap: U,
  }, te = Vte(X), re = {
      root: (P == null ? void 0 : P.root) ?? h.root,
      badge: (P == null ? void 0 : P.badge) ?? h.badge
  }, [Q, V] = bn("root", {
    elementType: Ute,
      ...A
  }), [ie, de] = bn("badge", {
    elementType: Wte,
    ...V,
      children: Y
process.env.NODE_ENV !== "production" && (kV.propTypes = {
const Gte = fn("MuiBox", ["root"]), qte = H_(), ym = FX({
  themeId: gc,
  defaultTheme: qte,
  defaultClassName: Gte.root,
  generateClassName: IH.generate
process.env.NODE_ENV !== "production" && (ym.propTypes = {
function Kte(e) {
  return ln("MuiButton", e);
}
const Ph = fn("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]), PV = /* @__PURE__ */ x.createContext({});
process.env.NODE_ENV !== "production" && (PV.displayName = "ButtonGroupContext");
const MV = /* @__PURE__ */ x.createContext(void 0);
process.env.NODE_ENV !== "production" && (MV.displayName = "ButtonGroupButtonContext");
const Yte = (e) => {
  } = e, h = {
  }, g = mt(h, Kte, f);
}, IV = [{
}], Xte = Ue(cm, {
  shouldForwardProp: (e) => Ds(e) || e === "classes",
    [`&.${Ph.disabled}`]: {
        [`&.${Ph.focusVisible}`]: {
        [`&.${Ph.disabled}`]: {
        [`&.${Ph.disabled}`]: {
    }, ...Object.entries(e.palette).filter(no()).map(([r]) => ({
        "--variant-outlinedBorder": e.vars ? `rgba(${e.vars.palette[r].mainChannel} / 0.5)` : rn(e.palette[r].main, 0.5),
            "--variant-textBg": e.vars ? `rgba(${e.vars.palette[r].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : rn(e.palette[r].main, e.palette.action.hoverOpacity),
            "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette[r].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : rn(e.palette[r].main, e.palette.action.hoverOpacity)
            "--variant-textBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : rn(e.palette.text.primary, e.palette.action.hoverOpacity),
            "--variant-outlinedBg": e.vars ? `rgba(${e.vars.palette.text.primaryChannel} / ${e.vars.palette.action.hoverOpacity})` : rn(e.palette.text.primary, e.palette.action.hoverOpacity)
        [`&.${Ph.focusVisible}`]: {
        [`&.${Ph.disabled}`]: {
        [`&.${Ph.loading}`]: {
})), Qte = Ue("span", {
  }, ...IV]
})), Jte = Ue("span", {
  }, ...IV]
})), Zte = Ue("span", {
})), MF = Ue("span", {
}), Qv = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = x.useContext(PV), o = x.useContext(MV), s = Wv(r, t), a = gn({
    component: h = "button",
    disabled: v = !1,
    id: P,
    loadingPosition: A = "center",
    size: k = "medium",
    startIcon: j,
    type: B,
    variant: H = "text",
    ...F
  } = a, D = mr(P), q = M ?? /* @__PURE__ */ $.jsx(vy, {
    "aria-labelledby": D,
  }), U = {
    component: h,
    disabled: v,
    loadingPosition: A,
    size: k,
    type: B,
    variant: H
  }, K = Yte(U), ee = (j || I && A === "start") && /* @__PURE__ */ $.jsx(Qte, {
    className: K.startIcon,
    ownerState: U,
    children: j || /* @__PURE__ */ $.jsx(MF, {
      className: K.loadingIconPlaceholder,
      ownerState: U
  }), G = (T || I && A === "end") && /* @__PURE__ */ $.jsx(Jte, {
    className: K.endIcon,
    ownerState: U,
    children: T || /* @__PURE__ */ $.jsx(MF, {
      className: K.loadingIconPlaceholder,
      ownerState: U
  }), Y = o || "", X = typeof I == "boolean" ? (
      className: K.loadingWrapper,
      children: I && /* @__PURE__ */ $.jsx(Zte, {
        className: K.loadingIndicator,
        ownerState: U,
  return /* @__PURE__ */ $.jsxs(Xte, {
    ownerState: U,
    className: et(r.className, K.root, g, Y),
    component: h,
    disabled: v || I,
    focusVisibleClassName: et(K.focusVisible, E),
    type: B,
    id: I ? D : P,
    ...F,
    classes: K,
    children: [ee, A !== "end" && X, c, A === "end" && X, G]
process.env.NODE_ENV !== "production" && (Qv.propTypes = {
function ene(e) {
  return ln("MuiCard", e);
fn("MuiCard", ["root"]);
const tne = (e) => {
  }, ene, t);
}, nne = Ue(la, {
}), uD = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
  }, f = tne(c);
  return /* @__PURE__ */ $.jsx(nne, {
process.env.NODE_ENV !== "production" && (uD.propTypes = {
  raised: ja(u.bool, (e) => e.raised && e.variant === "outlined" ? new Error('MUI: Combining `raised={true}` with `variant="outlined"` has no effect.') : null),
function rne(e) {
  return ln("MuiCardContent", e);
fn("MuiCardContent", ["root"]);
const one = (e) => {
  }, rne, t);
}, ine = Ue("div", {
}), cD = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
  }, f = one(c);
  return /* @__PURE__ */ $.jsx(ine, {
process.env.NODE_ENV !== "production" && (cD.propTypes = {
function sne(e) {
  return ln("PrivateSwitchBase", e);
fn("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const ane = (e) => {
  return mt(s, sne, t);
}, lne = Ue(cm, {
}), une = Ue("input", {
  shouldForwardProp: Ds
}), DV = /* @__PURE__ */ x.forwardRef(function(t, n) {
    edge: h = !1,
    id: v,
    onFocus: P,
    tabIndex: A,
    type: k,
    value: j,
    slots: B = {},
    slotProps: H = {},
    ...F
  } = t, [D, q] = tm({
  }), U = Md(), K = (he) => {
    P && P(he), U && U.onFocus && U.onFocus(he);
    E && E(he), U && U.onBlur && U.onBlur(he);
  let Y = c;
  U && typeof Y > "u" && (Y = U.disabled);
  const X = k === "checkbox" || k === "radio", te = {
    checked: D,
    disabled: Y,
    edge: h
  }, re = ane(te), Q = {
    slots: B,
      ...H
  }, [V, ie] = bn("root", {
    elementType: lne,
      ...F
        (fe = he.onFocus) == null || fe.call(he, ge), K(ge);
      disabled: Y,
  }), [de, ue] = bn("input", {
    elementType: une,
      disabled: Y,
      id: X ? v : void 0,
      tabIndex: A,
      type: k,
      ...k === "checkbox" && j === void 0 ? {} : {
        value: j
  return /* @__PURE__ */ $.jsxs(V, {
    }), D ? s : g]
process.env.NODE_ENV !== "production" && (DV.propTypes = {
  inputRef: pa,
const cne = Tn(/* @__PURE__ */ $.jsx("path", {
}), "CheckBoxOutlineBlank"), dne = Tn(/* @__PURE__ */ $.jsx("path", {
}), "CheckBox"), fne = Tn(/* @__PURE__ */ $.jsx("path", {
function pne(e) {
  return ln("MuiCheckbox", e);
const pP = fn("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]), hne = (e) => {
  }, a = mt(s, pne, t);
}, mne = Ue(DV, {
  shouldForwardProp: (e) => Ds(e) || e === "classes",
        backgroundColor: e.vars ? `rgba(${e.vars.palette.action.activeChannel} / ${e.vars.palette.action.hoverOpacity})` : rn(e.palette.action.active, e.palette.action.hoverOpacity)
  }, ...Object.entries(e.palette).filter(no()).map(([t]) => ({
        backgroundColor: e.vars ? `rgba(${e.vars.palette[t].mainChannel} / ${e.vars.palette.action.hoverOpacity})` : rn(e.palette[t].main, e.palette.action.hoverOpacity)
  })), ...Object.entries(e.palette).filter(no()).map(([t]) => ({
      [`&.${pP.checked}, &.${pP.indeterminate}`]: {
      [`&.${pP.disabled}`]: {
}))), gne = /* @__PURE__ */ $.jsx(dne, {}), vne = /* @__PURE__ */ $.jsx(cne, {}), yne = /* @__PURE__ */ $.jsx(fne, {}), AV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    checkedIcon: o = gne,
    icon: a = vne,
    indeterminateIcon: f = yne,
    inputProps: h,
    disableRipple: v = !1,
  } = r, O = c ? f : a, P = c ? f : o, I = {
    disableRipple: v,
  }, M = hne(I), A = T.input ?? h, [k, j] = bn("root", {
    elementType: mne,
      checkedIcon: /* @__PURE__ */ x.cloneElement(P, {
        fontSize: P.props.fontSize ?? g
      disableRipple: v,
        input: QI(typeof A == "function" ? A(I) : A, {
  return /* @__PURE__ */ $.jsx(k, {
    ...j,
process.env.NODE_ENV !== "production" && (AV.propTypes = {
function IF(e) {
function bne(e, t) {
function GS(e) {
  } = e, a = x.useRef(!1), c = x.useRef(null), f = x.useRef(!1), h = x.useRef(!1);
  const g = Ir(lp(t), c), v = Fn((T) => {
    const E = h.current;
    h.current = !1;
    const O = go(c.current);
    if (!f.current || !c.current || "clientX" in T && bne(T, O))
    let P;
    T.composedPath ? P = T.composedPath().includes(c.current) : P = !O.documentElement.contains(
    ), !P && (n || !E) && o(T);
    h.current = !0;
      const T = IF(s), E = go(c.current), O = () => {
      return E.addEventListener(T, v), E.addEventListener("touchmove", O), () => {
        E.removeEventListener(T, v), E.removeEventListener("touchmove", O);
  }, [v, s]), r !== !1 && (C[r] = w(r)), x.useEffect(() => {
      const T = IF(r), E = go(c.current);
      return E.addEventListener(T, v), () => {
        E.removeEventListener(T, v);
  }, [v, r]), /* @__PURE__ */ x.cloneElement(t, C);
process.env.NODE_ENV !== "production" && (GS.propTypes = {
  children: ap.isRequired,
process.env.NODE_ENV !== "production" && (GS.propTypes = vC(GS.propTypes));
const dD = AQ({
  useThemeProps: (e) => gn({
process.env.NODE_ENV !== "production" && (dD.propTypes = {
const CM = typeof XI({}) == "function", wne = (e, t) => ({
}), Sne = (e) => ({
}), NV = (e, t = !1) => {
    var g, v;
    const h = e.getColorSchemeSelector(c);
    h.startsWith("@") ? n[h] = {
    } : n[h.replace(/\s*&/, "")] = {
      colorScheme: (v = f.palette) == null ? void 0 : v.mode
    html: wne(e, t),
      ...Sne(e),
}, yT = "mui-ecs", Cne = (e) => {
  const t = NV(e, !1), n = Array.isArray(t) ? t[0] : t;
  return !e.vars && n && (n.html[`:root:has(${yT})`] = {
      [`:root:not(:has(.${yT}))`]: {
      [`&:not(:has(.${yT}))`]: {
}, xne = XI(CM ? ({
}) => NV(e, t) : ({
}) => Cne(e));
function $V(e) {
  const t = gn({
    children: [CM && /* @__PURE__ */ $.jsx(xne, {
    }), !CM && !r && /* @__PURE__ */ $.jsx("span", {
      className: yT,
process.env.NODE_ENV !== "production" && ($V.propTypes = {
function Ene(e) {
  const t = go(e);
  return t.body === e ? _l(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
function CS(e, t) {
function DF(e) {
  return parseInt(_l(e).getComputedStyle(e).paddingRight, 10) || 0;
function Tne(e) {
function AF(e, t, n, r, o) {
    const c = !s.includes(a), f = !Tne(a);
    c && f && CS(a, o);
function hP(e, t) {
function _ne(e, t) {
    if (Ene(r)) {
      const a = HH(_l(r));
      }), r.style.paddingRight = `${DF(r) + a}px`;
      const c = go(r).querySelectorAll(".mui-fixed");
        }), f.style.paddingRight = `${DF(f) + a}px`;
      s = go(r).body;
      const a = r.parentElement, c = _l(r);
function One(e) {
class Rne {
    r = this.modals.length, this.modals.push(t), t.modalRef && CS(t.modalRef, !1);
    const o = One(n);
    AF(n, t.mount, t.modalRef, o, !0);
    const s = hP(this.containers, (a) => a.container === n);
    const r = hP(this.containers, (s) => s.modals.includes(t)), o = this.containers[r];
    o.restore || (o.restore = _ne(o, n));
    const o = hP(this.containers, (a) => a.modals.includes(t)), s = this.containers[o];
      s.restore && s.restore(), t.modalRef && CS(t.modalRef, n), AF(s.container, t.mount, t.modalRef, s.hiddenSiblings, !1), this.containers.splice(o, 1);
      a.modalRef && CS(a.modalRef, !1);
const kne = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function Pne(e) {
function Mne(e) {
function Ine(e) {
  return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || Mne(e));
function Dne(e) {
  return Array.from(e.querySelectorAll(kne)).forEach((r, o) => {
    const s = Pne(r);
    s === -1 || !Ine(r) || (s === 0 ? t.push(r) : n.push({
function Ane() {
function qS(e) {
    getTabbable: s = Dne,
    isEnabled: a = Ane,
  } = e, f = x.useRef(!1), h = x.useRef(null), g = x.useRef(null), v = x.useRef(null), w = x.useRef(null), C = x.useRef(!1), T = x.useRef(null), E = Ir(lp(t), T), O = x.useRef(null);
    const M = go(T.current);
      o || (v.current && v.current.focus && (f.current = !0, v.current.focus()), v.current = null);
    const M = go(T.current), A = (B) => {
      O.current = B, !(r || !a() || B.key !== "Tab") && M.activeElement === T.current && B.shiftKey && (f.current = !0, g.current && g.current.focus());
    }, k = () => {
      var F, D;
      const B = T.current;
      if (B === null)
      if (B.contains(M.activeElement) || r && M.activeElement !== h.current && M.activeElement !== g.current)
      let H = [];
      if ((M.activeElement === h.current || M.activeElement === g.current) && (H = s(T.current)), H.length > 0) {
        const q = !!((F = O.current) != null && F.shiftKey && ((D = O.current) == null ? void 0 : D.key) === "Tab"), U = H[0], K = H[H.length - 1];
        typeof U != "string" && typeof K != "string" && (q ? K.focus() : U.focus());
        B.focus();
    M.addEventListener("focusin", k), M.addEventListener("keydown", A, !0);
    const j = setInterval(() => {
      M.activeElement && M.activeElement.tagName === "BODY" && k();
      clearInterval(j), M.removeEventListener("focusin", k), M.removeEventListener("keydown", A, !0);
  const P = (M) => {
    v.current === null && (v.current = M.relatedTarget), C.current = !0, w.current = M.target;
    const A = t.props.onFocus;
    A && A(M);
    v.current === null && (v.current = M.relatedTarget), C.current = !0;
      ref: h,
      onFocus: P
process.env.NODE_ENV !== "production" && (qS.propTypes = {
  children: ap,
process.env.NODE_ENV !== "production" && (qS.propTypes = vC(qS.propTypes));
function Nne(e) {
function $ne(e) {
const NF = () => {
}, zE = new Rne();
function Lne(e) {
    open: h,
  } = e, v = x.useRef({}), w = x.useRef(null), C = x.useRef(null), T = Ir(C, g), [E, O] = x.useState(!h), P = $ne(c);
  const M = () => go(w.current), A = () => (v.current.modalRef = C.current, v.current.mount = w.current, v.current), k = () => {
    zE.mount(A(), {
  }, j = Fn(() => {
    const G = Nne(t) || M().body;
    zE.add(A(), G), C.current && k();
  }), B = () => zE.isTopModal(A()), H = Fn((G) => {
    w.current = G, G && (h && B() ? k() : C.current && CS(C.current, I));
  }), F = x.useCallback(() => {
    zE.remove(A(), I);
    F();
  }, [F]), x.useEffect(() => {
    h ? j() : (!P || !o) && F();
  }, [h, F, P, o, j]);
  const D = (G) => (Y) => {
    (X = G.onKeyDown) == null || X.call(G, Y), !(Y.key !== "Escape" || Y.which === 229 || // Wait until IME is settled.
    !B()) && (n || (Y.stopPropagation(), f && f(Y, "escapeKeyDown")));
  }, q = (G) => (Y) => {
    (X = G.onClick) == null || X.call(G, Y), Y.target === Y.currentTarget && f && f(Y, "backdropClick");
      const Y = GH(e);
      delete Y.onTransitionEnter, delete Y.onTransitionExited;
        ...Y,
        onKeyDown: D(X),
      const Y = G;
        ...Y,
        onClick: q(Y),
        open: h
      }, Y = () => {
        O(!0), a && a(), o && F();
        onEnter: zj(G, (c == null ? void 0 : c.props.onEnter) ?? NF),
        onExited: zj(Y, (c == null ? void 0 : c.props.onExited) ?? NF)
    portalRef: H,
    isTopModal: B,
    hasTransition: P
function jne(e) {
  return ln("MuiModal", e);
fn("MuiModal", ["root", "hidden", "backdrop"]);
const Fne = (e) => {
  }, jne, r);
}, zne = Ue("div", {
}))), Bne = Ue(RV, {
}), fD = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    BackdropComponent: o = Bne,
    children: h,
    component: v,
    disablePortal: P = !1,
    hideBackdrop: A = !1,
    keepMounted: k = !1,
    onBackdropClick: j,
    onClose: B,
    onTransitionEnter: H,
    onTransitionExited: F,
    open: D,
    slots: U = {},
    theme: K,
    disablePortal: P,
    hideBackdrop: A,
    keepMounted: k
    getRootProps: Y,
    exited: V,
  } = Lne({
    exited: V
  }, ue = Fne(de), he = {};
  if (h.props.tabIndex === void 0 && (he.tabIndex = "-1"), ie) {
      ...U
  }, [fe, pe] = bn("root", {
    elementType: zne,
      component: v
    getSlotProps: Y,
  }), [be, we] = bn("backdrop", {
        j && j(ce), _e != null && _e.onClick && _e.onClick(ce);
  return !k && !D && (!ie || V) ? null : /* @__PURE__ */ $.jsx(WS, {
    disablePortal: P,
      children: [!A && o ? /* @__PURE__ */ $.jsx(be, {
      }) : null, /* @__PURE__ */ $.jsx(qS, {
        open: D,
        children: /* @__PURE__ */ x.cloneElement(h, he)
process.env.NODE_ENV !== "production" && (fD.propTypes = {
  children: ap.isRequired,
  container: u.oneOfType([Tl, u.func]),
function Hne(e) {
  return ln("MuiDivider", e);
const $F = fn("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), Vne = (e) => {
  }, Hne, r);
}, Une = Ue("div", {
      borderColor: e.vars ? `rgba(${e.vars.palette.dividerChannel} / 0.08)` : rn(e.palette.divider, 0.08)
}))), Wne = Ue("span", {
}))), qf = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    flexItem: h = !1,
    role: v = f !== "hr" ? "separator" : void 0,
    flexItem: h,
    role: v,
  }, O = Vne(E);
  return /* @__PURE__ */ $.jsx(Une, {
    role: v,
    "aria-orientation": v === "separator" && (f !== "hr" || c === "vertical") ? c : void 0,
    children: s ? /* @__PURE__ */ $.jsx(Wne, {
qf && (qf.muiSkipListHighlight = !0);
process.env.NODE_ENV !== "production" && (qf.propTypes = {
function Gne(e, t, n) {
  const r = t.getBoundingClientRect(), o = n && n.getBoundingClientRect(), s = _l(t);
    const h = s.getComputedStyle(t);
    a = h.getPropertyValue("-webkit-transform") || h.getPropertyValue("transform");
    const h = a.split("(")[1].split(")")[0].split(",");
    c = parseInt(h[4], 10), f = parseInt(h[5], 10);
function LV(e) {
function BE(e, t, n) {
  const r = LV(n), o = Gne(e, t, r);
const jV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = za(), o = {
    container: h,
    easing: v = o,
    onExited: P,
    timeout: A = s,
    TransitionComponent: k = Cu,
    ...j
  } = t, B = x.useRef(null), H = Ir(lp(f), B, n), F = (te) => (re) => {
    te && (re === void 0 ? te(B.current) : te(B.current, re));
  }, D = F((te, re) => {
    BE(g, te, h), eD(te), C && C(te, re);
  }), q = F((te, re) => {
    const Q = Gv({
      timeout: A,
      easing: v
  }), U = F(T), K = F(I), ee = F((te) => {
    const re = Gv({
      timeout: A,
      easing: v
    te.style.webkitTransition = r.transitions.create("-webkit-transform", re), te.style.transition = r.transitions.create("transform", re), BE(g, te, h), O && O(te);
  }), G = F((te) => {
    te.style.webkitTransition = "", te.style.transition = "", P && P(te);
  }), Y = (te) => {
    a && a(B.current, te);
    B.current && BE(g, B.current, h);
  }, [g, h]);
    const te = BI(() => {
      B.current && BE(g, B.current, h);
    }), re = _l(B.current);
  }, [g, w, h]), x.useEffect(() => {
  }, [w, X]), /* @__PURE__ */ $.jsx(k, {
    nodeRef: B,
    onEnter: D,
    onEntered: U,
    onExiting: K,
    addEndListener: Y,
    timeout: A,
    ...j,
      ref: H,
process.env.NODE_ENV !== "production" && (jV.propTypes = {
  children: ap.isRequired,
  container: ja(u.oneOfType([Tl, u.func]), (e) => {
      const t = LV(e.container);
function qne(e) {
  return ln("MuiDrawer", e);
fn("MuiDrawer", ["root", "docked", "paper", "anchorLeft", "anchorRight", "anchorTop", "anchorBottom", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const FV = (e, t) => {
}, Kne = (e) => {
  return mt(o, qne, t);
}, Yne = Ue(fD, {
  overridesResolver: FV
}))), Xne = Ue("div", {
  shouldForwardProp: Ds,
  overridesResolver: FV
}), Qne = Ue(la, {
}))), zV = {
function Jne(e) {
function Zne({
  return e === "rtl" && Jne(t) ? zV[t] : t;
const BV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
  }), o = za(), s = my(), a = {
    children: h,
    elevation: v = 16,
    PaperProps: P = {},
    transitionDuration: A = a,
    variant: k = "temporary",
    slots: j = {},
    slotProps: B = {},
    ...H
  } = r, F = x.useRef(!1);
    F.current = !0;
  const D = Zne({
  }, c), U = {
    elevation: v,
    variant: k,
    ...H
  }, K = Kne(U), ee = {
      ...j
      paper: P,
      ...B,
      backdrop: QI(B.backdrop || {
        transitionDuration: A
  }, [G, Y] = bn("root", {
    elementType: Yne,
    className: et(K.root, K.modal, g),
    ownerState: U,
      ...H,
  }), [X, te] = bn("paper", {
    elementType: Qne,
    className: et(K.paper, P.className),
    ownerState: U,
      elevation: k === "temporary" ? v : 0,
  }), [re, Q] = bn("docked", {
    elementType: Xne,
    className: et(K.root, K.docked, g),
    ownerState: U,
    additionalProps: H
  }), [V, ie] = bn("transition", {
    elementType: jV,
    ownerState: U,
      direction: zV[D],
      timeout: A,
      appear: F.current
    children: h
  if (k === "permanent")
  const ue = /* @__PURE__ */ $.jsx(V, {
  return k === "persistent" ? /* @__PURE__ */ $.jsx(re, {
    ...Y,
process.env.NODE_ENV !== "production" && (BV.propTypes = {
  elevation: nm,
const ere = (e) => {
  }, h = mt(f, xte, t);
    ...h
}, tre = Ue(q_, {
  shouldForwardProp: (e) => Ds(e) || e === "classes",
    return [...W_(e, t), !n.disableUnderline && t.underline];
    [`&.${Pa.focused}`]: {
    [`&.${Pa.disabled}`]: {
        [`&.${Pa.focused}:after`]: {
        [`&.${Pa.error}`]: {
        [`&:hover:not(.${Pa.disabled}, .${Pa.error}):before`]: {
        [`&.${Pa.disabled}:before`]: {
    }, ...Object.entries(e.palette).filter(no()).map(([a]) => {
})), nre = Ue(K_, {
  overridesResolver: G_
}))), Y_ = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    inputComponent: h = "input",
    slotProps: v,
    inputComponent: h,
  }, O = ere(r), P = {
  }, I = v ?? a ? Ri(P, v ?? a) : P, M = w.root ?? s.Root ?? tre, A = w.input ?? s.Input ?? nre;
  return /* @__PURE__ */ $.jsx(vm, {
      input: A
    inputComponent: h,
process.env.NODE_ENV !== "production" && (Y_.propTypes = {
  inputRef: pa,
Y_.muiName = "Input";
function rre(e) {
  return ln("MuiFormControl", e);
fn("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const ore = (e) => {
  return mt(o, rre, t);
}, ire = Ue("div", {
}), X_ = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    error: h = !1,
    fullWidth: v = !1,
    ...P
    error: h,
    fullWidth: v,
  }, M = ore(I), [A, k] = x.useState(() => {
    let Y = !1;
      if (!gT(X, ["Input", "Select"]))
      const te = gT(X, ["Select"]) ? X.props.input : X;
      te && yte(te.props) && (Y = !0);
    }), Y;
  }), [j, B] = x.useState(() => {
    let Y = !1;
      gT(X, ["Input", "Select"]) && (HT(X.props, !0) || HT(X.props.inputProps, !0)) && (Y = !0);
    }), Y;
  }), [H, F] = x.useState(!1);
  f && H && F(!1);
  const D = g !== void 0 && !f ? g : H;
  const U = x.useRef(!1);
  process.env.NODE_ENV !== "production" && (q = () => (U.current && console.error(["MUI: There are multiple `InputBase` components inside a FormControl.", "This creates visual inconsistencies, only use one `InputBase`."].join(`
`)), U.current = !0, () => {
    U.current = !1;
  const K = x.useCallback(() => {
    B(!0);
    B(!1);
    adornedStart: A,
    setAdornedStart: k,
    error: h,
    filled: j,
    focused: D,
    fullWidth: v,
      F(!1);
      F(!0);
    onFilled: K,
  }), [A, a, f, h, j, D, v, w, q, ee, K, T, E, O]);
  return /* @__PURE__ */ $.jsx(wC.Provider, {
    children: /* @__PURE__ */ $.jsx(ire, {
      ...P,
process.env.NODE_ENV !== "production" && (X_.propTypes = {
function sre(e) {
  return ln("MuiFormControlLabel", e);
const uS = fn("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]), are = (e) => {
  return mt(a, sre, t);
}, lre = Ue("label", {
      [`& .${uS.label}`]: t.label
  [`&.${uS.disabled}`]: {
  [`& .${uS.label}`]: {
    [`&.${uS.disabled}`]: {
}))), ure = Ue("span", {
  [`&.${uS.error}`]: {
}))), xM = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    disableTypography: h,
    label: v,
    slotProps: P = {},
  } = r, A = Md(), k = f ?? c.props.disabled ?? (A == null ? void 0 : A.disabled), j = E ?? c.props.required, B = {
    disabled: k,
    required: j
    typeof c.props[G] > "u" && typeof r[G] < "u" && (B[G] = r[G]);
  const H = gm({
    muiFormControl: A,
  }), F = {
    disabled: k,
    required: j,
    error: H.error
  }, D = are(F), q = {
      ...P
  }, [U, K] = bn("typography", {
    elementType: un,
    ownerState: F
  let ee = v;
  return ee != null && ee.type !== un && !h && (ee = /* @__PURE__ */ $.jsx(U, {
    ...K,
    className: et(D.label, K == null ? void 0 : K.className),
  })), /* @__PURE__ */ $.jsxs(lre, {
    className: et(D.root, s),
    ownerState: F,
    children: [/* @__PURE__ */ x.cloneElement(c, B), j ? /* @__PURE__ */ $.jsxs("div", {
      children: [ee, /* @__PURE__ */ $.jsxs(ure, {
        ownerState: F,
        className: D.asterisk,
process.env.NODE_ENV !== "production" && (xM.propTypes = {
  inputRef: pa,
function cre(e) {
  return ln("MuiFormHelperText", e);
const LF = fn("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
var jF;
const dre = (e) => {
  } = e, h = {
  return mt(h, cre, t);
}, fre = Ue("p", {
  [`&.${LF.disabled}`]: {
  [`&.${LF.error}`]: {
}))), HV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    filled: h,
    margin: v,
  } = r, E = Md(), O = gm({
  }), P = {
  delete P.ownerState;
  const I = dre(P);
  return /* @__PURE__ */ $.jsx(fre, {
    ownerState: P,
      jF || (jF = /* @__PURE__ */ $.jsx("span", {
process.env.NODE_ENV !== "production" && (HV.propTypes = {
function pre(e) {
  return ln("MuiFormLabel", e);
const xS = fn("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), hre = (e) => {
  return mt(f, pre, t);
}, mre = Ue("label", {
  variants: [...Object.entries(e.palette).filter(no()).map(([t]) => ({
      [`&.${xS.focused}`]: {
      [`&.${xS.disabled}`]: {
      [`&.${xS.error}`]: {
}))), gre = Ue("span", {
  [`&.${xS.error}`]: {
}))), VV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    error: h,
    focused: v,
  } = r, T = Md(), E = gm({
  }, P = hre(O);
  return /* @__PURE__ */ $.jsxs(mre, {
    className: et(P.root, s),
    children: [o, E.required && /* @__PURE__ */ $.jsxs(gre, {
      className: P.asterisk,
process.env.NODE_ENV !== "production" && (VV.propTypes = {
const EM = /* @__PURE__ */ x.createContext();
process.env.NODE_ENV !== "production" && (EM.displayName = "GridContext");
function vre(e) {
  return ln("MuiGrid", e);
}
const yre = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], bre = ["column-reverse", "column", "row-reverse", "row"], wre = ["nowrap", "wrap-reverse", "wrap"], Vw = ["auto", !0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], KS = fn("MuiGrid", [
  "root",
  "container",
  "item",
  "zeroMinWidth",
  // spacings
  ...yre.map((e) => `spacing-xs-${e}`),
  // direction values
  ...bre.map((e) => `direction-xs-${e}`),
  // wrap values
  ...wre.map((e) => `wrap-xs-${e}`),
  // grid sizes for all breakpoints
  ...Vw.map((e) => `grid-xs-${e}`),
  ...Vw.map((e) => `grid-sm-${e}`),
  ...Vw.map((e) => `grid-md-${e}`),
  ...Vw.map((e) => `grid-lg-${e}`),
  ...Vw.map((e) => `grid-xl-${e}`)
]);
function Sre({
  theme: e,
  ownerState: t
}) {
  let n;
  return e.breakpoints.keys.reduce((r, o) => {
    let s = {};
    if (t[o] && (n = t[o]), !n)
      return r;
    if (n === !0)
      s = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    else if (n === "auto")
      s = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    else {
      const a = em({
        values: t.columns,
        breakpoints: e.breakpoints.values
      }), c = typeof a == "object" ? a[o] : a;
      if (c == null)
        return r;
      const f = `${Math.round(n / c * 1e8) / 1e6}%`;
      let h = {};
      if (t.container && t.item && t.columnSpacing !== 0) {
        const g = e.spacing(t.columnSpacing);
        if (g !== "0px") {
          const v = `calc(${f} + ${g})`;
          h = {
            flexBasis: v,
            maxWidth: v
          };
        }
      }
      s = {
        flexBasis: f,
        flexGrow: 0,
        maxWidth: f,
        ...h
      };
    }
    return e.breakpoints.values[o] === 0 ? Object.assign(r, s) : r[e.breakpoints.up(o)] = s, r;
  }, {});
}
function Cre({
  theme: e,
  ownerState: t
}) {
  const n = em({
    values: t.direction,
    breakpoints: e.breakpoints.values
  });
  return fa({
    theme: e
  }, n, (r) => {
    const o = {
      flexDirection: r
    };
    return r.startsWith("column") && (o[`& > .${KS.item}`] = {
      maxWidth: "none"
    }), o;
  });
}
function UV({
  breakpoints: e,
  values: t
}) {
  let n = "";
  Object.keys(t).forEach((o) => {
    n === "" && t[o] !== 0 && (n = o);
  });
  const r = Object.keys(e).sort((o, s) => e[o] - e[s]);
  return r.slice(0, r.indexOf(n));
}
function xre({
  theme: e,
  ownerState: t
}) {
  const {
    container: n,
    rowSpacing: r
  } = t;
  let o = {};
  if (n && r !== 0) {
    const s = em({
      values: r,
      breakpoints: e.breakpoints.values
    });
    let a;
    typeof s == "object" && (a = UV({
      breakpoints: e.breakpoints.values,
      values: s
    })), o = fa({
      theme: e
    }, s, (c, f) => {
      const h = e.spacing(c);
      return h !== "0px" ? {
        marginTop: `calc(-1 * ${h})`,
        [`& > .${KS.item}`]: {
          paddingTop: h
        }
      } : a != null && a.includes(f) ? {} : {
        marginTop: 0,
        [`& > .${KS.item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return o;
}
function Ere({
  theme: e,
  ownerState: t
}) {
  const {
    container: n,
    columnSpacing: r
  } = t;
  let o = {};
  if (n && r !== 0) {
    const s = em({
      values: r,
      breakpoints: e.breakpoints.values
    });
    let a;
    typeof s == "object" && (a = UV({
      breakpoints: e.breakpoints.values,
      values: s
    })), o = fa({
      theme: e
    }, s, (c, f) => {
      const h = e.spacing(c);
      if (h !== "0px") {
        const g = `calc(-1 * ${h})`;
        return {
          width: `calc(100% + ${h})`,
          marginLeft: g,
          [`& > .${KS.item}`]: {
            paddingLeft: h
          }
        };
      }
      return a != null && a.includes(f) ? {} : {
        width: "100%",
        marginLeft: 0,
        [`& > .${KS.item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return o;
}
function Tre(e, t, n = {}) {
  if (!e || e <= 0)
    return [];
  if (typeof e == "string" && !Number.isNaN(Number(e)) || typeof e == "number")
    return [n[`spacing-xs-${String(e)}`]];
  const r = [];
  return t.forEach((o) => {
    const s = e[o];
    Number(s) > 0 && r.push(n[`spacing-${o}-${String(s)}`]);
  }), r;
}
const _re = Ue("div", {
  name: "MuiGrid",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e, {
      container: r,
      direction: o,
      item: s,
      spacing: a,
      wrap: c,
      zeroMinWidth: f,
      breakpoints: h
    } = n;
    let g = [];
    r && (g = Tre(a, h, t));
    const v = [];
    return h.forEach((w) => {
      const C = n[w];
      C && v.push(t[`grid-${w}-${String(C)}`]);
    }), [t.root, r && t.container, s && t.item, f && t.zeroMinWidth, ...g, o !== "row" && t[`direction-xs-${String(o)}`], c !== "wrap" && t[`wrap-xs-${String(c)}`], ...v];
  }
})(
  // FIXME(romgrk): Can't use memoTheme here
  ({
    ownerState: e
  }) => ({
    boxSizing: "border-box",
    ...e.container && {
      display: "flex",
      flexWrap: "wrap",
      width: "100%"
    },
    ...e.item && {
      margin: 0
      // For instance, it's useful when used with a `figure` element.
    },
    ...e.zeroMinWidth && {
      minWidth: 0
    },
    ...e.wrap !== "wrap" && {
      flexWrap: e.wrap
    }
  }),
  Cre,
  xre,
  Ere,
  Sre
);
function Ore(e, t) {
  if (!e || e <= 0)
    return [];
  if (typeof e == "string" && !Number.isNaN(Number(e)) || typeof e == "number")
    return [`spacing-xs-${String(e)}`];
  const n = [];
  return t.forEach((r) => {
    const o = e[r];
    if (Number(o) > 0) {
      const s = `spacing-${r}-${String(o)}`;
      n.push(s);
    }
  }), n;
}
const Rre = (e) => {
  const {
    classes: t,
    container: n,
    direction: r,
    item: o,
    spacing: s,
    wrap: a,
    zeroMinWidth: c,
    breakpoints: f
  } = e;
  let h = [];
  n && (h = Ore(s, f));
  const g = [];
  f.forEach((w) => {
    const C = e[w];
    C && g.push(`grid-${w}-${String(C)}`);
  });
  const v = {
    root: ["root", n && "container", o && "item", c && "zeroMinWidth", ...h, r !== "row" && `direction-xs-${String(r)}`, a !== "wrap" && `wrap-xs-${String(a)}`, ...g]
  };
  return mt(v, vre, t);
}, oa = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    props: t,
    name: "MuiGrid"
  }), {
    breakpoints: o
  } = za(), s = mC(r), {
    className: a,
    columns: c,
    columnSpacing: f,
    component: h = "div",
    container: g = !1,
    direction: v = "row",
    item: w = !1,
    rowSpacing: C,
    spacing: T = 0,
    wrap: E = "wrap",
    zeroMinWidth: O = !1,
    ...P
  } = s, I = C || T, M = f || T, A = x.useContext(EM), k = g ? c || 12 : A, j = {}, B = {
    ...P
  };
  o.keys.forEach((D) => {
    P[D] != null && (j[D] = P[D], delete B[D]);
  });
  const H = {
    ...s,
    columns: k,
    container: g,
    direction: v,
    item: w,
    rowSpacing: I,
    columnSpacing: M,
    wrap: E,
    zeroMinWidth: O,
    spacing: T,
    ...j,
    breakpoints: o.keys
  }, F = Rre(H);
  return /* @__PURE__ */ $.jsx(EM.Provider, {
    value: k,
    children: /* @__PURE__ */ $.jsx(_re, {
      ownerState: H,
      className: et(F.root, a),
      as: h,
      ref: n,
      ...B
    })
  });
});
process.env.NODE_ENV !== "production" && (oa.propTypes = {
  //  Warning 
  //  These PropTypes are generated from the TypeScript type definitions. 
  //     To update them, edit the d.ts file and run `pnpm proptypes`.     
  // 
  /**
   * The content of the component.
   */
  children: u.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: u.object,
  /**
   * @ignore
   */
  className: u.string,
  /**
   * The number of columns.
   * @default 12
   */
  columns: u.oneOfType([u.arrayOf(u.number), u.number, u.object]),
  /**
   * Defines the horizontal space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  columnSpacing: u.oneOfType([u.arrayOf(u.oneOfType([u.number, u.string])), u.number, u.object, u.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: u.elementType,
  /**
   * If `true`, the component will have the flex *container* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  container: u.bool,
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'row'
   */
  direction: u.oneOfType([u.oneOf(["column-reverse", "column", "row-reverse", "row"]), u.arrayOf(u.oneOf(["column-reverse", "column", "row-reverse", "row"])), u.object]),
  /**
   * If `true`, the component will have the flex *item* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  item: u.bool,
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `lg` breakpoint and wider screens if not overridden.
   * @default false
   */
  lg: u.oneOfType([u.oneOf(["auto"]), u.number, u.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `md` breakpoint and wider screens if not overridden.
   * @default false
   */
  md: u.oneOfType([u.oneOf(["auto"]), u.number, u.bool]),
  /**
   * Defines the vertical space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  rowSpacing: u.oneOfType([u.arrayOf(u.oneOfType([u.number, u.string])), u.number, u.object, u.string]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `sm` breakpoint and wider screens if not overridden.
   * @default false
   */
  sm: u.oneOfType([u.oneOf(["auto"]), u.number, u.bool]),
  /**
   * Defines the space between the type `item` components.
   * It can only be used on a type `container` component.
   * @default 0
   */
  spacing: u.oneOfType([u.arrayOf(u.oneOfType([u.number, u.string])), u.number, u.object, u.string]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: u.oneOfType([u.arrayOf(u.oneOfType([u.func, u.object, u.bool])), u.func, u.object]),
  /**
   * Defines the `flex-wrap` style property.
   * It's applied for all screen sizes.
   * @default 'wrap'
   */
  wrap: u.oneOf(["nowrap", "wrap-reverse", "wrap"]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `xl` breakpoint and wider screens if not overridden.
   * @default false
   */
  xl: u.oneOfType([u.oneOf(["auto"]), u.number, u.bool]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for all the screen sizes with the lowest priority.
   * @default false
   */
  xs: u.oneOfType([u.oneOf(["auto"]), u.number, u.bool]),
  /**
   * If `true`, it sets `min-width: 0` on the item.
   * Refer to the limitations section of the documentation to better understand the use case.
   * @default false
   */
  zeroMinWidth: u.bool
});
if (process.env.NODE_ENV !== "production") {
  const e = BH("Grid", oa);
  oa.propTypes = {
    // eslint-disable-next-line react/forbid-foreign-prop-types
    ...oa.propTypes,
    direction: e("container"),
    lg: e("item"),
    md: e("item"),
    sm: e("item"),
    spacing: e("container"),
    wrap: e("container"),
    xs: e("item"),
    zeroMinWidth: e("item")
  };
}
const VT = QQ({
  useThemeProps: (e) => gn({
  useTheme: za
process.env.NODE_ENV !== "production" && (VT.propTypes = {
  const e = VT, t = BH("Grid2", e);
function TM(e) {
const kre = {
    transform: TM(1)
}, mP = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), Jv = /* @__PURE__ */ x.forwardRef(function(t, n) {
    onEntered: h,
    onExit: v,
    TransitionComponent: O = Cu,
    ...P
  } = t, I = Aa(), M = x.useRef(), A = za(), k = x.useRef(null), j = Ir(k, lp(s), n), B = (G) => (Y) => {
      const X = k.current;
      Y === void 0 ? G(X) : G(X, Y);
  }, H = B(g), F = B((G, Y) => {
    eD(G);
    } = Gv({
    E === "auto" ? (Q = A.transitions.getAutoHeightDuration(G.clientHeight), M.current = Q) : Q = X, G.style.transition = [A.transitions.create("opacity", {
    }), A.transitions.create("transform", {
      duration: mP ? Q : Q * 0.666,
    })].join(","), f && f(G, Y);
  }), D = B(h), q = B(C), U = B((G) => {
      duration: Y,
    } = Gv({
    E === "auto" ? (re = A.transitions.getAutoHeightDuration(G.clientHeight), M.current = re) : re = Y, G.style.transition = [A.transitions.create("opacity", {
    }), A.transitions.create("transform", {
      duration: mP ? re : re * 0.666,
      delay: mP ? X : X || re * 0.333,
    })].join(","), G.style.opacity = 0, G.style.transform = TM(0.75), v && v(G);
  }), K = B(w), ee = (G) => {
    E === "auto" && I.start(M.current || 0, G), r && r(k.current, G);
    nodeRef: k,
    onEnter: F,
    onEntered: D,
    onEntering: H,
    onExit: U,
    onExited: K,
    ...P,
      ownerState: Y,
        transform: TM(0.75),
        ...kre[G],
      ref: j,
process.env.NODE_ENV !== "production" && (Jv.propTypes = {
  children: ap.isRequired,
Jv && (Jv.muiSupportAuto = !0);
const Pre = (e) => {
  }, Ste, t);
}, Mre = Ue(q_, {
  shouldForwardProp: (e) => Ds(e) || e === "classes",
    return [...W_(e, t), !n.disableUnderline && t.underline];
        [`&.${Ff.focused}:after`]: {
        [`&.${Ff.error}`]: {
        [`&:hover:not(.${Ff.disabled}, .${Ff.error}):before`]: {
        [`&.${Ff.disabled}:before`]: {
    }, ...Object.entries(e.palette).filter(no()).map(([r]) => ({
})), Ire = Ue(K_, {
  overridesResolver: G_
})({}), Q_ = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    multiline: h = !1,
    slots: v = {},
  } = r, T = Pre(r), O = {
  }, P = g ?? a ? Ri(g ?? a, O) : O, I = v.root ?? s.Root ?? Mre, M = v.input ?? s.Input ?? Ire;
  return /* @__PURE__ */ $.jsx(vm, {
    slotProps: P,
    multiline: h,
process.env.NODE_ENV !== "production" && (Q_.propTypes = {
  inputRef: pa,
Q_.muiName = "Input";
function Dre(e) {
  return ln("MuiInputAdornment", e);
const FF = fn("MuiInputAdornment", ["root", "filled", "standard", "outlined", "positionStart", "positionEnd", "disablePointerEvents", "hiddenLabel", "sizeSmall"]);
var zF;
const Are = (e, t) => {
}, Nre = (e) => {
  return mt(c, Dre, t);
}, $re = Ue("div", {
  overridesResolver: Are
      [`&.${FF.positionStart}&:not(.${FF.hiddenLabel})`]: {
}))), pD = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    position: h,
    ...v
  } = r, w = Md() || {};
    position: h,
  }, E = Nre(T);
  return /* @__PURE__ */ $.jsx(wC.Provider, {
    children: /* @__PURE__ */ $.jsx($re, {
      ...v,
      children: typeof o == "string" && !f ? /* @__PURE__ */ $.jsx(un, {
        children: [h === "start" ? (
          zF || (zF = /* @__PURE__ */ $.jsx("span", {
process.env.NODE_ENV !== "production" && (pD.propTypes = {
function Lre(e) {
  return ln("MuiInputLabel", e);
fn("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const jre = (e) => {
  }, h = mt(f, Lre, t);
    ...h
}, Fre = Ue(VV, {
  shouldForwardProp: (e) => Ds(e) || e === "classes",
      [`& .${xS.asterisk}`]: t.asterisk
}))), J_ = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    ...h
  } = r, g = Md();
  let v = a;
  typeof v > "u" && g && (v = g.filled || g.focused || g.adornedStart);
  const w = gm({
    shrink: v,
  }, T = jre(C);
  return /* @__PURE__ */ $.jsx(Fre, {
    "data-shrink": v,
    ...h,
process.env.NODE_ENV !== "production" && (J_.propTypes = {
function zre(e) {
  return ln("MuiLinearProgress", e);
fn("MuiLinearProgress", ["root", "colorPrimary", "colorSecondary", "determinate", "indeterminate", "buffer", "query", "dashed", "dashedColorPrimary", "dashedColorSecondary", "bar", "bar1", "bar2", "barColorPrimary", "barColorSecondary", "bar1Indeterminate", "bar1Determinate", "bar1Buffer", "bar2Indeterminate", "bar2Buffer"]);
const _M = 4, OM = Tc`
`, Bre = typeof OM != "string" ? ip`
        animation: ${OM} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
      ` : null, RM = Tc`
`, Hre = typeof RM != "string" ? ip`
        animation: ${RM} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
      ` : null, kM = Tc`
`, Vre = typeof kM != "string" ? ip`
        animation: ${kM} 3s infinite linear;
      ` : null, Ure = (e) => {
  return mt(o, zre, t);
}, hD = (e, t) => e.vars ? e.vars.palette.LinearProgress[`${t}Bg`] : e.palette.mode === "light" ? tp(e.palette[t].main, 0.62) : ep(e.palette[t].main, 0.5), Wre = Ue("span", {
  variants: [...Object.entries(e.palette).filter(no()).map(([t]) => ({
      backgroundColor: hD(e, t)
}))), Gre = Ue("span", {
  }, ...Object.entries(e.palette).filter(no()).map(([t]) => {
    const n = hD(e, t);
})), Vre || {
  animation: `${kM} 3s infinite linear`
}), qre = Ue("span", {
  }, ...Object.entries(e.palette).filter(no()).map(([t]) => ({
      transition: `transform .${_M}s linear`
      transition: `transform .${_M}s linear`
    style: Bre || {
      animation: `${OM} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite`
}))), Kre = Ue("span", {
  variants: [...Object.entries(e.palette).filter(no()).map(([t]) => ({
  }, ...Object.entries(e.palette).filter(no()).map(([t]) => ({
      backgroundColor: hD(e, t),
      transition: `transform .${_M}s linear`
    style: Hre || {
      animation: `${RM} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite`
}))), WV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    ...h
  }, v = Ure(g), w = my(), C = {}, T = {
  return /* @__PURE__ */ $.jsxs(Wre, {
    className: et(v.root, o),
    ...h,
    children: [f === "buffer" ? /* @__PURE__ */ $.jsx(Gre, {
      className: v.dashed,
    }) : null, /* @__PURE__ */ $.jsx(qre, {
      className: v.bar1,
    }), f === "determinate" ? null : /* @__PURE__ */ $.jsx(Kre, {
      className: v.bar2,
process.env.NODE_ENV !== "production" && (WV.propTypes = {
const Zv = /* @__PURE__ */ x.createContext({});
process.env.NODE_ENV !== "production" && (Zv.displayName = "ListContext");
function Yre(e) {
  return ln("MuiList", e);
fn("MuiList", ["root", "padding", "dense", "subheader"]);
const Xre = (e) => {
  }, Yre, t);
}, Qre = Ue("ul", {
}), GV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    subheader: h,
  } = r, v = x.useMemo(() => ({
  }, C = Xre(w);
  return /* @__PURE__ */ $.jsx(Zv.Provider, {
    value: v,
    children: /* @__PURE__ */ $.jsxs(Qre, {
      children: [h, o]
process.env.NODE_ENV !== "production" && (GV.propTypes = {
function Jre(e) {
  return ln("MuiListItemIcon", e);
const BF = fn("MuiListItemIcon", ["root", "alignItemsFlexStart"]), Zre = (e) => {
  }, Jre, n);
}, eoe = Ue("div", {
}))), om = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
  } = r, a = x.useContext(Zv), c = {
  }, f = Zre(c);
  return /* @__PURE__ */ $.jsx(eoe, {
process.env.NODE_ENV !== "production" && (om.propTypes = {
function toe(e) {
  return ln("MuiListItemText", e);
const kv = fn("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), noe = (e) => {
  }, toe, t);
}, roe = Ue("div", {
      [`& .${kv.primary}`]: t.primary
      [`& .${kv.secondary}`]: t.secondary
  [`.${lF.root}:where(& .${kv.primary})`]: {
  [`.${lF.root}:where(& .${kv.secondary})`]: {
}), im = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    primaryTypographyProps: h,
    secondaryTypographyProps: v,
  } = x.useContext(Zv);
  let O = f ?? o, P = g;
    secondary: !!P,
  }, M = noe(I), A = {
      primary: h,
      secondary: v,
  }, [k, j] = bn("root", {
    elementType: roe,
      ...A,
  }), [B, H] = bn("primary", {
    elementType: un,
    externalForwardedProps: A,
  }), [F, D] = bn("secondary", {
    elementType: un,
    externalForwardedProps: A,
  return O != null && O.type !== un && !a && (O = /* @__PURE__ */ $.jsx(B, {
    component: H != null && H.variant ? void 0 : "span",
    ...H,
  })), P != null && P.type !== un && !a && (P = /* @__PURE__ */ $.jsx(F, {
    ...D,
    children: P
  })), /* @__PURE__ */ $.jsxs(k, {
    ...j,
    children: [O, P]
process.env.NODE_ENV !== "production" && (im.propTypes = {
function gP(e, t, n) {
function HF(e, t, n) {
function qV(e, t) {
function Uw(e, t, n, r, o, s) {
    if (!c.hasAttribute("tabindex") || !qV(c, s) || f)
const SC = /* @__PURE__ */ x.forwardRef(function(t, n) {
    disableListWrap: h = !1,
    variant: v = "selectedMenu",
  Lr(() => {
      direction: A
      const k = !C.current.style.width;
      if (M.clientHeight < C.current.clientHeight && k) {
        const j = `${HH(_l(M))}px`;
        C.current.style[A === "rtl" ? "paddingLeft" : "paddingRight"] = j, C.current.style.width = `calc(100% + ${j})`;
    const A = C.current, k = M.key;
    const B = go(A).activeElement;
    if (k === "ArrowDown")
      M.preventDefault(), Uw(A, B, h, f, gP);
    else if (k === "ArrowUp")
      M.preventDefault(), Uw(A, B, h, f, HF);
    else if (k === "Home")
      M.preventDefault(), Uw(A, null, h, f, gP);
    else if (k === "End")
      M.preventDefault(), Uw(A, null, h, f, HF);
    else if (k.length === 1) {
      const H = T.current, F = k.toLowerCase(), D = performance.now();
      H.keys.length > 0 && (D - H.lastTime > 500 ? (H.keys = [], H.repeating = !0, H.previousKeyMatched = !0) : H.repeating && F !== H.keys[0] && (H.repeating = !1)), H.lastTime = D, H.keys.push(F);
      const q = B && !H.repeating && qV(B, H);
      H.previousKeyMatched && (q || Uw(A, B, !1, f, gP, H)) ? M.preventDefault() : H.previousKeyMatched = !1;
  }, O = Ir(C, n);
  let P = -1;
  x.Children.forEach(a, (M, A) => {
      P === A && (P += 1, P >= a.length && (P = -1));
    process.env.NODE_ENV !== "production" && wu.isFragment(M) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
`)), M.props.disabled || (v === "selectedMenu" && M.props.selected || P === -1) && (P = A), P === A && (M.props.disabled || M.props.muiSkipListHighlight || M.type.muiSkipListHighlight) && (P += 1, P >= a.length && (P = -1));
  const I = x.Children.map(a, (M, A) => {
    if (A === P) {
      const k = {};
      return s && (k.autoFocus = !0), M.props.tabIndex === void 0 && v === "selectedMenu" && (k.tabIndex = 0), /* @__PURE__ */ x.cloneElement(M, k);
  return /* @__PURE__ */ $.jsx(GV, {
process.env.NODE_ENV !== "production" && (SC.propTypes = {
function ooe(e) {
  return ln("MuiPopover", e);
fn("MuiPopover", ["root", "paper"]);
function VF(e, t) {
function UF(e, t) {
function WF(e) {
function cS(e) {
const ioe = (e) => {
  }, ooe, t);
}, soe = Ue(fD, {
})({}), KV = Ue(la, {
}), YV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    children: h,
    container: v,
    slotProps: P = {},
    transitionDuration: A = "auto",
    TransitionProps: k = {},
    disableScrollLock: j = !1,
    ...B
  } = r, H = x.useRef(), F = {
    transitionDuration: A,
    TransitionProps: k
  }, D = ioe(F), q = x.useCallback(() => {
    const we = cS(s), _e = we && we.nodeType === 1 ? we : go(H.current).body, ce = _e.getBoundingClientRect();
      top: ce.top + VF(ce, a.vertical),
      left: ce.left + UF(ce, a.horizontal)
  }, [s, a.horizontal, a.vertical, c, f]), U = x.useCallback((we) => ({
    vertical: VF(we, I.vertical),
    horizontal: UF(we, I.horizontal)
  }), [I.horizontal, I.vertical]), K = x.useCallback((we) => {
    }, ce = U(_e);
        transformOrigin: WF(ce)
    const tt = Ne + _e.height, Le = Be + _e.width, rt = _l(cS(s)), ot = rt.innerHeight - C, wt = rt.innerWidth - C;
    } else if (Le > wt) {
      const gt = Le - wt;
      transformOrigin: WF(ce)
  }, [s, f, q, U, C]), [ee, G] = x.useState(T), Y = x.useCallback(() => {
    const we = H.current;
    const _e = K(we);
  }, [K]);
  x.useEffect(() => (j && window.addEventListener("scroll", Y), () => window.removeEventListener("scroll", Y)), [s, j, Y]);
    Y();
    T && Y();
      Y();
  } : null, [T, Y]), x.useEffect(() => {
    const we = BI(() => {
      Y();
    }), _e = _l(cS(s));
  }, [s, T, Y]);
  let re = A;
      transition: k,
      ...P
  }, [V, ie] = bn("transition", {
    elementType: Jv,
    ownerState: F,
  A === "auto" && !V.muiSupportAuto && (re = void 0);
  const de = v || (s ? go(cS(s)).body : void 0), [ue, {
  }] = bn("root", {
    elementType: soe,
      ...B
        backdrop: QI(typeof P.backdrop == "function" ? P.backdrop(F) : P.backdrop, {
    ownerState: F,
    className: et(D.root, g)
  }), [pe, be] = bn("paper", {
    ref: H,
    className: D.paper,
    elementType: KV,
    ownerState: F
    ...!SM(ue) && {
      disableScrollLock: j
    children: /* @__PURE__ */ $.jsx(V, {
        children: h
process.env.NODE_ENV !== "production" && (YV.propTypes = {
  action: pa,
  anchorEl: ja(u.oneOfType([Tl, u.func]), (e) => {
      const t = cS(e.anchorEl);
  container: u.oneOfType([Tl, u.func]),
  elevation: nm,
    component: zI
function aoe(e) {
  return ln("MuiMenu", e);
fn("MuiMenu", ["root", "paper", "list"]);
const loe = {
}, uoe = {
}, coe = (e) => {
  }, aoe, t);
}, doe = Ue(YV, {
  shouldForwardProp: (e) => Ds(e) || e === "classes",
})({}), foe = Ue(KV, {
}), poe = Ue(SC, {
}), XV = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    onClose: h,
    PaperProps: v = {},
    slots: P = {},
  } = r, A = my(), k = {
    PaperProps: v,
  }, j = coe(k), B = o && !c && g, H = x.useRef(null), F = (re, Q) => {
    H.current && H.current.adjustStyleForScrollbar(re, {
      direction: A ? "rtl" : "ltr"
  }, D = (re) => {
    re.key === "Tab" && (re.preventDefault(), h && h(re, "tabKeyDown"));
    /* @__PURE__ */ x.isValidElement(re) && (process.env.NODE_ENV !== "production" && wu.isFragment(re) && console.error(["MUI: The Menu component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
  const U = {
    slots: P,
      paper: v,
  }, K = YH({
    elementType: P.root,
    ownerState: k,
    className: [j.root, a]
  }), [ee, G] = bn("paper", {
    className: j.paper,
    elementType: foe,
    externalForwardedProps: U,
    ownerState: k
  }), [Y, X] = bn("list", {
    className: et(j.list, f.className),
    elementType: poe,
    externalForwardedProps: U,
        var V;
        D(Q), (V = re.onKeyDown) == null || V.call(re, Q);
    ownerState: k
  }), te = typeof U.slotProps.transition == "function" ? U.slotProps.transition(k) : U.slotProps.transition;
  return /* @__PURE__ */ $.jsx(doe, {
    onClose: h,
      horizontal: A ? "right" : "left"
    transformOrigin: A ? loe : uoe,
      root: P.root,
      backdrop: P.backdrop,
      ...P.transition && {
        transition: P.transition
      root: K,
      backdrop: typeof I.backdrop == "function" ? I.backdrop(k) : I.backdrop,
          F(...re), (Q = te == null ? void 0 : te.onEntering) == null || Q.call(te, ...re);
    ownerState: k,
    children: /* @__PURE__ */ $.jsx(Y, {
      actions: H,
      autoFocusItem: B,
process.env.NODE_ENV !== "production" && (XV.propTypes = {
  anchorEl: u.oneOfType([Tl, u.func]),
function hoe(e) {
  return ln("MuiMenuItem", e);
const Ww = fn("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), moe = (e, t) => {
}, goe = (e) => {
  }, hoe, a);
}, voe = Ue(cm, {
  shouldForwardProp: (e) => Ds(e) || e === "classes",
  overridesResolver: moe
  [`&.${Ww.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : rn(e.palette.primary.main, e.palette.action.selectedOpacity),
    [`&.${Ww.focusVisible}`]: {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.focusOpacity}))` : rn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.focusOpacity)
  [`&.${Ww.selected}:hover`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : rn(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity),
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : rn(e.palette.primary.main, e.palette.action.selectedOpacity)
  [`&.${Ww.focusVisible}`]: {
  [`&.${Ww.disabled}`]: {
  [`& + .${$F.root}`]: {
  [`& + .${$F.inset}`]: {
  [`& .${kv.root}`]: {
  [`& .${kv.inset}`]: {
  [`& .${BF.root}`]: {
      [`& .${BF.root} svg`]: {
}))), Sl = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    focusVisibleClassName: h,
    tabIndex: v,
  } = r, T = x.useContext(Zv), E = x.useMemo(() => ({
  Lr(() => {
  const P = {
  }, I = goe(r), M = Ir(O, n);
  let A;
  return r.disabled || (A = v !== void 0 ? v : -1), /* @__PURE__ */ $.jsx(Zv.Provider, {
    children: /* @__PURE__ */ $.jsx(voe, {
      tabIndex: A,
      focusVisibleClassName: et(I.focusVisible, h),
      ownerState: P,
process.env.NODE_ENV !== "production" && (Sl.propTypes = {
function yoe(e) {
  return ln("MuiNativeSelect", e);
const mD = fn("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), boe = (e) => {
  return mt(c, yoe, t);
}, QV = Ue("select", {
  [`&.${mD.disabled}`]: {
})), woe = Ue(QV, {
  shouldForwardProp: Ds,
      [`&.${mD.multiple}`]: t.multiple
})({}), JV = Ue("svg", {
  [`&.${mD.disabled}`]: {
})), Soe = Ue(JV, {
})({}), ZV = /* @__PURE__ */ x.forwardRef(function(t, n) {
    ...h
  }, v = boe(g);
    children: [/* @__PURE__ */ $.jsx(woe, {
      className: et(v.select, r),
      ...h
    }), t.multiple ? null : /* @__PURE__ */ $.jsx(Soe, {
      className: v.icon
process.env.NODE_ENV !== "production" && (ZV.propTypes = {
  inputRef: pa,
var GF;
const Coe = Ue("fieldset", {
  shouldForwardProp: Ds
}), xoe = Ue("legend", {
  shouldForwardProp: Ds
function eU(e) {
  return /* @__PURE__ */ $.jsx(Coe, {
    children: /* @__PURE__ */ $.jsx(xoe, {
        GF || (GF = /* @__PURE__ */ $.jsx("span", {
process.env.NODE_ENV !== "production" && (eU.propTypes = {
const Eoe = (e) => {
  }, Cte, t);
}, Toe = Ue(q_, {
  shouldForwardProp: (e) => Ds(e) || e === "classes",
  overridesResolver: W_
    [`&:hover .${pl.notchedOutline}`]: {
      [`&:hover .${pl.notchedOutline}`]: {
    [`&.${pl.focused} .${pl.notchedOutline}`]: {
    variants: [...Object.entries(e.palette).filter(no()).map(([n]) => ({
        [`&.${pl.focused} .${pl.notchedOutline}`]: {
        [`&.${pl.error} .${pl.notchedOutline}`]: {
        [`&.${pl.disabled} .${pl.notchedOutline}`]: {
})), _oe = Ue(eU, {
})), Ooe = Ue(K_, {
  overridesResolver: G_
}))), Z_ = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    notched: h,
    slotProps: v = {},
  } = r, T = Eoe(r), E = Md(), O = gm({
  }), P = {
  }, I = g.root ?? o.Root ?? Toe, M = g.input ?? o.Input ?? Ooe, [A, k] = bn("notchedOutline", {
    elementType: _oe,
    ownerState: P,
      slotProps: v
  return /* @__PURE__ */ $.jsx(vm, {
    slotProps: v,
    renderSuffix: (j) => /* @__PURE__ */ $.jsx(A, {
      ...k,
      notched: typeof h < "u" ? h : !!(j.startAdornment || j.filled || j.focused)
process.env.NODE_ENV !== "production" && (Z_.propTypes = {
  inputRef: pa,
Z_.muiName = "Input";
const Roe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "FirstPage"), koe = Tn(/* @__PURE__ */ $.jsx("path", {
function tU(e) {
  return ln("MuiSelect", e);
const Gw = fn("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
var qF;
const Poe = Ue(QV, {
        [`&.${Gw.select}`]: t.select
        [`&.${Gw.select}`]: t[n.variant]
        [`&.${Gw.error}`]: t.error
        [`&.${Gw.multiple}`]: t.multiple
  [`&.${Gw.select}`]: {
}), Moe = Ue(JV, {
})({}), Ioe = Ue("input", {
  shouldForwardProp: (e) => aV(e) && e !== "classes",
function KF(e, t) {
function Doe(e) {
const Aoe = (e) => {
  return mt(c, tU, t);
}, nU = /* @__PURE__ */ x.forwardRef(function(t, n) {
    defaultOpen: h,
    disabled: v,
    MenuProps: P = {},
    onBlur: A,
    onChange: k,
    onClose: j,
    onFocus: B,
    onOpen: H,
    open: F,
    readOnly: D,
    required: U,
    SelectDisplayProps: K = {},
    value: Y,
  } = t, [re, Q] = tm({
    controlled: Y,
  }), [V, ie] = tm({
    controlled: F,
    default: h,
  } = x.useRef(F != null), [pe, be] = x.useState(), we = Ir(n, E), _e = x.useCallback((We) => {
    h && V && he && !fe && (be(a ? null : ce.clientWidth), ue.current.focus());
    const We = go(ue.current).getElementById(O);
    We ? H && H(St) : j && j(St), fe || (be(a ? null : ce.clientWidth), ie(We));
  }, tt = x.Children.toArray(c), Le = (We) => {
    const St = tt.find((Lt) => Lt.props.value === We.target.value);
    St !== void 0 && (Q(St.props.value), k && k(We, St));
    let Lt;
        Lt = Array.isArray(re) ? re.slice() : [];
        const Cn = re.indexOf(We.props.value);
        Cn === -1 ? Lt.push(We.props.value) : Lt.splice(Cn, 1);
        Lt = We.props.value;
      if (We.props.onClick && We.props.onClick(St), re !== Lt && (Q(Lt), k)) {
        const Cn = St.nativeEvent || St, pn = new Cn.constructor(Cn.type, Cn);
        Object.defineProperty(pn, "target", {
            value: Lt,
        }), k(pn, We);
    D || [
  }, wt = he !== null && V, gt = (We) => {
    !wt && A && (Object.defineProperty(We, "target", {
    }), A(We));
  (HT({
    process.env.NODE_ENV !== "production" && wu.isFragment(We) && console.error(["MUI: The Select component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join(`
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: The `value` prop must be an array when using the `Select` component with `multiple`." : wc(2));
      St = re.some((Lt) => KF(Lt, We.props.value)), St && Et && ut.push(We.props.children);
      St = KF(re, We.props.value), St && Et && (Ft = We.props.children);
      onKeyUp: (Lt) => {
        Lt.key === " " && Lt.preventDefault(), We.props.onKeyUp && We.props.onKeyUp(Lt);
  }, [Tt, tt, I, M, re]), Et && (I ? ut.length === 0 ? nt = null : nt = ut.reduce((We, St, Lt) => (We.push(St), Lt < ut.length - 1 && We.push(", "), We), []) : nt = Ft);
  typeof ee < "u" ? Xe = ee : Xe = v ? null : 0;
  const Oe = K.id || (M ? `mui-component-select-${M}` : void 0), Ie = {
  }, pt = Aoe(Ie), yt = {
    ...P.PaperProps,
    ...(bt = P.slotProps) == null ? void 0 : bt.paper
  }, zt = mr();
    children: [/* @__PURE__ */ $.jsx(Poe, {
      "aria-disabled": v ? "true" : void 0,
      "aria-required": U ? "true" : void 0,
      onMouseDown: v || D ? null : Ne,
      onFocus: B,
      ...K,
      className: et(K.className, pt.select, f),
      children: Doe(nt) ? (
        qF || (qF = /* @__PURE__ */ $.jsx("span", {
    }), /* @__PURE__ */ $.jsx(Ioe, {
      onChange: Le,
      disabled: v,
      required: U,
    }), /* @__PURE__ */ $.jsx(Moe, {
    }), /* @__PURE__ */ $.jsx(XV, {
      ...P,
        ...P.slotProps,
          ...P.MenuListProps
process.env.NODE_ENV !== "production" && (nU.propTypes = {
  inputRef: pa,
const Noe = (e) => {
  }, tU, t);
}, gD = {
  shouldForwardProp: (e) => Ds(e) && e !== "variant",
}, $oe = Ue(Q_, gD)(""), Loe = Ue(Z_, gD)(""), joe = Ue(Y_, gD)(""), yy = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    displayEmpty: h = !1,
    IconComponent: g = _V,
    id: v,
    multiple: P = !1,
    onOpen: A,
    open: k,
    renderValue: j,
    SelectDisplayProps: B,
    variant: H = "outlined",
    ...F
  } = r, D = I ? ZV : nU, q = Md(), U = gm({
  }), K = U.variant || H, ee = {
    variant: K,
  }, G = Noe(ee), {
    root: Y,
    standard: /* @__PURE__ */ $.jsx($oe, {
    outlined: /* @__PURE__ */ $.jsx(Loe, {
    filled: /* @__PURE__ */ $.jsx(joe, {
  }[K], re = Ir(n, lp(te));
      inputComponent: D,
        error: U.error,
        variant: K,
        multiple: P,
          id: v
          displayEmpty: h,
          onOpen: A,
          open: k,
          renderValue: j,
            id: v,
            ...B
        classes: C ? Ri(X, C.classes) : X,
      ...(P && I || h) && K === "outlined" ? {
        variant: K
      ...F
process.env.NODE_ENV !== "production" && (yy.propTypes = {
yy.muiName = "Select";
function Foe(e) {
  return ln("MuiSkeleton", e);
fn("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
const zoe = (e) => {
  }, Foe, t);
}, PM = Tc`
`, MM = Tc`
`, Boe = typeof PM != "string" ? ip`
        animation: ${PM} 2s ease-in-out 0.5s infinite;
      ` : null, Hoe = typeof MM != "string" ? ip`
          animation: ${MM} 2s linear 0.5s infinite;
      ` : null, Voe = Ue("span", {
  const t = AJ(e.shape.borderRadius) || "px", n = NJ(e.shape.borderRadius);
    backgroundColor: e.vars ? e.vars.palette.Skeleton.bg : rn(e.palette.text.primary, e.palette.mode === "light" ? 0.11 : 0.13),
      style: Boe || {
        animation: `${PM} 2s ease-in-out 0.5s infinite`
      style: Hoe || {
          animation: `${MM} 2s linear 0.5s infinite`
})), rU = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    variant: h = "text",
    ...v
    variant: h,
    hasChildren: !!v.children
  }, C = zoe(w);
  return /* @__PURE__ */ $.jsx(Voe, {
    ...v,
process.env.NODE_ENV !== "production" && (rU.propTypes = {
function Uoe(e) {
  return ln("MuiTooltip", e);
const Po = fn("MuiTooltip", ["popper", "popperInteractive", "popperArrow", "popperClose", "tooltip", "tooltipArrow", "touch", "tooltipPlacementLeft", "tooltipPlacementRight", "tooltipPlacementTop", "tooltipPlacementBottom", "arrow"]);
function Woe(e) {
const Goe = (e) => {
  return mt(a, Uoe, t);
}, qoe = Ue(cp, {
      [`&[data-popper-placement*="bottom"] .${Po.arrow}`]: {
      [`&[data-popper-placement*="top"] .${Po.arrow}`]: {
      [`&[data-popper-placement*="right"] .${Po.arrow}`]: {
      [`&[data-popper-placement*="left"] .${Po.arrow}`]: {
      [`&[data-popper-placement*="right"] .${Po.arrow}`]: {
      [`&[data-popper-placement*="right"] .${Po.arrow}`]: {
      [`&[data-popper-placement*="left"] .${Po.arrow}`]: {
      [`&[data-popper-placement*="left"] .${Po.arrow}`]: {
}))), Koe = Ue("div", {
  backgroundColor: e.vars ? e.vars.palette.Tooltip.bg : rn(e.palette.grey[700], 0.92),
  [`.${Po.popper}[data-popper-placement*="left"] &`]: {
  [`.${Po.popper}[data-popper-placement*="right"] &`]: {
  [`.${Po.popper}[data-popper-placement*="top"] &`]: {
  [`.${Po.popper}[data-popper-placement*="bottom"] &`]: {
      lineHeight: `${Woe(16 / 14)}em`,
      [`.${Po.popper}[data-popper-placement*="left"] &`]: {
      [`.${Po.popper}[data-popper-placement*="right"] &`]: {
      [`.${Po.popper}[data-popper-placement*="left"] &`]: {
      [`.${Po.popper}[data-popper-placement*="right"] &`]: {
      [`.${Po.popper}[data-popper-placement*="left"] &`]: {
      [`.${Po.popper}[data-popper-placement*="right"] &`]: {
      [`.${Po.popper}[data-popper-placement*="left"] &`]: {
      [`.${Po.popper}[data-popper-placement*="right"] &`]: {
      [`.${Po.popper}[data-popper-placement*="top"] &`]: {
      [`.${Po.popper}[data-popper-placement*="bottom"] &`]: {
}))), Yoe = Ue("span", {
  color: e.vars ? e.vars.palette.Tooltip.bg : rn(e.palette.grey[700], 0.9),
let HE = !1;
const YF = new z_();
let qw = {
function VE(e, t) {
const vD = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    describeChild: h = !1,
    disableHoverListener: v = !1,
    followCursor: P = !1,
    leaveTouchDelay: A = 1500,
    onClose: k,
    onOpen: j,
    open: B,
    placement: H = "bottom",
    PopperComponent: F,
    PopperProps: D = {},
    slots: U = {},
    title: K,
    ...Y
  }), te = za(), re = my(), [Q, V] = x.useState(), [ie, de] = x.useState(null), ue = x.useRef(!1), he = w || P, ge = Aa(), fe = Aa(), pe = Aa(), be = Aa(), [we, _e] = tm({
    controlled: B,
    } = x.useRef(B !== void 0);
      Q && Q.disabled && !Wt && K !== "" && Q.tagName.toLowerCase() === "button" && console.warn(["MUI: You are providing a disabled `button` child to the Tooltip component.", "A disabled element does not fire events.", "Tooltip needs to listen to the child element's events to display the title.", "", "Add a simple wrapper element, such as a `span`."].join(`
    }, [K, Q, Wt]);
  const Ce = mr(I), Ne = x.useRef(), Be = Fn(() => {
    YF.clear(), HE = !0, _e(!0), j && !ce && j(Wt);
  }, Le = Fn(
      YF.start(800 + M, () => {
        HE = !1;
      }), _e(!1), k && ce && k(Wt), ge.start(te.transitions.duration.shortest, () => {
    ue.current && Wt.type !== "touchstart" || (Q && Q.removeAttribute("title"), fe.clear(), pe.clear(), T || HE && E ? fe.start(HE ? E : T, () => {
      Le(Wt);
    DT(Wt.target) || (wt(!1), ot(Wt));
    Q || V(Wt.currentTarget), DT(Wt.target) && (wt(!0), rt(Wt));
    const gr = X.props;
    gr.onTouchStart && gr.onTouchStart(Wt);
    X.props.onTouchEnd && X.props.onTouchEnd(Wt), Be(), pe.start(A, () => {
      Le(Wt);
    function Wt(gr) {
      gr.key === "Escape" && Le(gr);
  }, [Le, ce]);
  const Tt = Ir(lp(X), V, n);
  !K && K !== 0 && (ce = !1);
    const gr = X.props;
    gr.onMouseMove && gr.onMouseMove(Wt), qw = {
  }, Xe = {}, Oe = typeof K == "string";
  h ? (Xe.title = !ce && Oe && !v ? K : null, Xe["aria-describedby"] = ce ? Ce : null) : (Xe["aria-label"] = Oe ? K : null, Xe["aria-labelledby"] = ce && !Oe ? Ce : null);
    ...Y,
    className: et(Y.className, X.props.className),
    ...P ? {
  C || (Ie.onTouchStart = ut, Ie.onTouchEnd = Et), v || (Ie.onMouseOver = VE(rt, Ie.onMouseOver), Ie.onMouseLeave = VE(ot, Ie.onMouseLeave), he || (pt.onMouseOver = rt, pt.onMouseLeave = ot)), g || (Ie.onFocus = VE(nt, Ie.onFocus), Ie.onBlur = VE(gt, Ie.onBlur), he || (pt.onFocus = nt, pt.onBlur = gt)), process.env.NODE_ENV !== "production" && X.props.title && console.error(["MUI: You have provided a `title` prop to the child of <Tooltip />.", `Remove this title prop \`${X.props.title}\` or the Tooltip component.`].join(`
    placement: H,
    PopperComponentProp: F,
    var gr, Zo;
    return (gr = D.popperOptions) != null && gr.modifiers && (Wt = Wt.concat(D.popperOptions.modifiers)), (Zo = zt == null ? void 0 : zt.popperOptions) != null && Zo.modifiers && (Wt = Wt.concat(zt.popperOptions.modifiers)), {
      ...D.popperOptions,
  }, [ie, D.popperOptions, zt == null ? void 0 : zt.popperOptions]), We = Goe(yt), St = typeof q.transition == "function" ? q.transition(yt) : q.transition, Lt = {
      ...U
        ...D,
  }, [Cn, pn] = bn("popper", {
    elementType: qoe,
    externalForwardedProps: Lt,
    className: et(We.popper, D == null ? void 0 : D.className)
  }), [Or, lr] = bn("transition", {
    elementType: Jv,
    externalForwardedProps: Lt,
  }), [Fr, Rr] = bn("tooltip", {
    elementType: Koe,
    externalForwardedProps: Lt,
  }), [Qo, Jo] = bn("arrow", {
    elementType: Yoe,
    externalForwardedProps: Lt,
    children: [/* @__PURE__ */ x.cloneElement(X, Ie), /* @__PURE__ */ $.jsx(Cn, {
      as: F ?? cp,
      placement: H,
      anchorEl: P ? {
          top: qw.y,
          left: qw.x,
          right: qw.x,
          bottom: qw.y,
      ...pn,
      }) => /* @__PURE__ */ $.jsx(Or, {
        ...lr,
        children: /* @__PURE__ */ $.jsxs(Fr, {
          ...Rr,
          children: [K, o ? /* @__PURE__ */ $.jsx(Qo, {
            ...Jo
process.env.NODE_ENV !== "production" && (vD.propTypes = {
  children: ap.isRequired,
const Vn = oJ({
  useThemeProps: (e) => gn({
process.env.NODE_ENV !== "production" && (Vn.propTypes = {
const oU = /* @__PURE__ */ x.createContext();
process.env.NODE_ENV !== "production" && (oU.displayName = "TableContext");
const iU = /* @__PURE__ */ x.createContext();
process.env.NODE_ENV !== "production" && (iU.displayName = "Tablelvl2Context");
function Xoe(e) {
  return ln("MuiTableCell", e);
}
const Qoe = fn("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), Joe = (e) => {
  return mt(c, Xoe, t);
}, Zoe = Ue("td", {
    ${e.palette.mode === "light" ? tp(rn(e.palette.divider, 1), 0.88) : ep(rn(e.palette.divider, 1), 0.68)}`,
      [`&.${Qoe.paddingCheckbox}`]: {
}))), UT = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    size: h,
    variant: v,
  } = r, C = x.useContext(oU), T = x.useContext(iU), E = T && T.variant === "head";
  let P = f;
  O === "td" ? P = void 0 : !P && E && (P = "col");
  const I = v || T && T.variant, M = {
    size: h || (C && C.size ? C.size : "medium"),
  }, A = Joe(M);
  let k = null;
  return g && (k = g === "asc" ? "ascending" : "descending"), /* @__PURE__ */ $.jsx(Zoe, {
    className: et(A.root, s),
    "aria-sort": k,
    scope: P,
process.env.NODE_ENV !== "production" && (UT.propTypes = {
function eie(e) {
  return ln("MuiToolbar", e);
fn("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const tie = (e) => {
  }, eie, t);
}, nie = Ue("div", {
}))), yD = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
  } = r, h = {
  }, g = tie(h);
  return /* @__PURE__ */ $.jsx(nie, {
    ownerState: h,
process.env.NODE_ENV !== "production" && (yD.propTypes = {
const rie = Tn(/* @__PURE__ */ $.jsx("path", {
}), "KeyboardArrowLeft"), oie = Tn(/* @__PURE__ */ $.jsx("path", {
}), "KeyboardArrowRight"), sU = /* @__PURE__ */ x.forwardRef(function(t, n) {
    page: h,
    showFirstButton: v,
  } = t, O = my(), P = (V) => {
    f(V, 0);
  }, I = (V) => {
    f(V, h - 1);
  }, M = (V) => {
    f(V, h + 1);
  }, A = (V) => {
    f(V, Math.max(0, Math.ceil(o / g) - 1));
  }, k = C.firstButton ?? hu, j = C.lastButton ?? hu, B = C.nextButton ?? hu, H = C.previousButton ?? hu, F = C.firstButtonIcon ?? Roe, D = C.lastButtonIcon ?? koe, q = C.nextButtonIcon ?? oie, U = C.previousButtonIcon ?? rie, K = O ? j : k, ee = O ? B : H, G = O ? H : B, Y = O ? k : j, X = O ? T.lastButton : T.firstButton, te = O ? T.nextButton : T.previousButton, re = O ? T.previousButton : T.nextButton, Q = O ? T.firstButton : T.lastButton;
    children: [v && /* @__PURE__ */ $.jsx(K, {
      onClick: P,
      disabled: s || h === 0,
      "aria-label": a("first", h),
      title: a("first", h),
      children: O ? /* @__PURE__ */ $.jsx(D, {
      }) : /* @__PURE__ */ $.jsx(F, {
      disabled: s || h === 0,
      "aria-label": a("previous", h),
      title: a("previous", h),
      }) : /* @__PURE__ */ $.jsx(U, {
      disabled: s || (o !== -1 ? h >= Math.ceil(o / g) - 1 : !1),
      "aria-label": a("next", h),
      title: a("next", h),
      children: O ? /* @__PURE__ */ $.jsx(U, {
    }), w && /* @__PURE__ */ $.jsx(Y, {
      onClick: A,
      disabled: s || h >= Math.ceil(o / g) - 1,
      "aria-label": a("last", h),
      title: a("last", h),
      children: O ? /* @__PURE__ */ $.jsx(F, {
      }) : /* @__PURE__ */ $.jsx(D, {
process.env.NODE_ENV !== "production" && (sU.propTypes = {
function iie(e) {
  return ln("MuiTablePagination", e);
const sm = fn("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]);
var XF;
const sie = Ue(UT, {
}))), aie = Ue(yD, {
    [`& .${sm.actions}`]: t.actions,
  [`& .${sm.actions}`]: {
}))), lie = Ue("div", {
}), uie = Ue("p", {
}))), cie = Ue(yy, {
    [`& .${sm.selectIcon}`]: t.selectIcon,
    [`& .${sm.select}`]: t.select,
  [`& .${sm.select}`]: {
}), die = Ue(Sl, {
})({}), fie = Ue("p", {
function pie({
function hie(e) {
const mie = (e) => {
  }, iie, t);
}, aU = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    ActionsComponent: o = sU,
    component: c = UT,
    disabled: h = !1,
    getItemAriaLabel: g = hie,
    labelDisplayedRows: v = pie,
    rowsPerPage: P,
    showFirstButton: A = !1,
    showLastButton: k = !1,
    slotProps: j = {},
    slots: B = {},
    ...H
  } = r, F = r, D = mie(F), q = (j == null ? void 0 : j.select) ?? M, U = q.native ? "option" : die;
  let K;
  (c === UT || c === "td") && (K = a || 1e3);
  const ee = mr(q.id), G = mr(q.labelId), Y = () => f === -1 ? (O + 1) * P : P === -1 ? f : Math.min(f, (O + 1) * P), X = {
    slots: B,
    slotProps: j
  }, [te, re] = bn("root", {
    className: D.root,
    elementType: sie,
      ...H
    ownerState: F,
      colSpan: K
  }), [Q, V] = bn("toolbar", {
    className: D.toolbar,
    elementType: aie,
    ownerState: F
  }), [ie, de] = bn("spacer", {
    className: D.spacer,
    elementType: lie,
    ownerState: F
  }), [ue, he] = bn("selectLabel", {
    className: D.selectLabel,
    elementType: uie,
    ownerState: F,
  }), [ge, fe] = bn("select", {
    className: D.select,
    elementType: cie,
    ownerState: F
  }), [pe, be] = bn("menuItem", {
    className: D.menuItem,
    elementType: U,
    ownerState: F
  }), [we, _e] = bn("displayedRows", {
    className: D.displayedRows,
    elementType: fie,
    ownerState: F
      ...V,
          input: XF || (XF = /* @__PURE__ */ $.jsx(vm, {}))
        value: P,
          root: et(D.input, D.selectRoot, (q.classes || {}).root),
          select: et(D.select, (q.classes || {}).select),
          icon: et(D.selectIcon, (q.classes || {}).icon)
        disabled: h,
        children: v({
          from: f === 0 ? 0 : O * P + 1,
          to: Y(),
        className: D.actions,
        rowsPerPage: P,
        showFirstButton: A,
        showLastButton: k,
        slotProps: j.actions,
        slots: B.actions,
        disabled: h
process.env.NODE_ENV !== "production" && (aU.propTypes = {
  count: nm.isRequired,
  page: ja(nm.isRequired, (e) => {
  rowsPerPage: nm.isRequired,
function gie(e) {
  return ln("MuiTextField", e);
}
fn("MuiTextField", ["root"]);
const vie = {
  standard: Q_,
  filled: Y_,
  outlined: Z_
}, yie = (e) => {
  }, gie, t);
}, bie = Ue(X_, {
})({}), Xh = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const r = gn({
    defaultValue: h,
    error: v = !1,
    inputProps: P,
    label: A,
    maxRows: k,
    minRows: j,
    multiline: B = !1,
    name: H,
    onBlur: F,
    onChange: D,
    placeholder: U,
    required: K = !1,
    SelectProps: Y,
    variant: V = "outlined",
    error: v,
    multiline: B,
    required: K,
    variant: V
  }, ue = yie(de);
  const he = mr(E), ge = T && he ? `${he}-helper-text` : void 0, fe = A && he ? `${he}-label` : void 0, pe = vie[V], be = {
      htmlInput: P,
      select: Y,
  V === "outlined" && (_e && typeof _e.shrink < "u" && (we.notched = _e.shrink), we.label = A), G && ((!Y || !Y.native) && (we.id = void 0), we["aria-describedby"] = void 0);
  const [ce, Ce] = bn("root", {
    elementType: bie,
      error: v,
      required: K,
      variant: V
  }), [Ne, Be] = bn("input", {
  }), [tt, Le] = bn("inputLabel", {
    elementType: J_,
  }), [rt, ot] = bn("htmlInput", {
  }), [wt, gt] = bn("formHelperText", {
    elementType: HV,
  }), [nt, Ft] = bn("select", {
    elementType: yy,
    defaultValue: h,
    multiline: B,
    name: H,
    maxRows: k,
    minRows: j,
    onBlur: F,
    onChange: D,
    placeholder: U,
    children: [A != null && A !== "" && /* @__PURE__ */ $.jsx(tt, {
      ...Le,
      children: A
process.env.NODE_ENV !== "production" && (Xh.propTypes = {
  inputRef: pa,
const wie = (e) => {
  return e ? t = e : typeof fetch > "u" ? t = (...n) => Promise.resolve().then(() => by).then(({ default: r }) => r(...n)) : t = fetch, (...n) => t(...n);
class bD extends Error {
class QF extends bD {
class JF extends bD {
class ZF extends bD {
var IM;
})(IM || (IM = {}));
var Sie = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
class Cie {
  constructor(t, { headers: n = {}, customFetch: r, region: o = IM.Any } = {}) {
    this.url = t, this.headers = n, this.region = o, this.fetch = wie(r);
    return Sie(this, arguments, void 0, function* (n, r = {}) {
        let h = {}, { region: g } = r;
        const v = new URL(`${this.url}/${n}`);
        g && g !== "any" && (h["x-region"] = g, v.searchParams.set("forceFunctionRegion", g));
        c && (s && !Object.prototype.hasOwnProperty.call(s, "Content-Type") || !s) && (typeof Blob < "u" && c instanceof Blob || c instanceof ArrayBuffer ? (h["Content-Type"] = "application/octet-stream", w = c) : typeof c == "string" ? (h["Content-Type"] = "text/plain", w = c) : typeof FormData < "u" && c instanceof FormData ? w = c : (h["Content-Type"] = "application/json", w = JSON.stringify(c)));
        const C = yield this.fetch(v.toString(), {
          headers: Object.assign(Object.assign(Object.assign({}, h), this.headers), s),
        }).catch((P) => {
          throw P.name === "AbortError" ? P : new QF(P);
          throw new JF(C);
          throw new ZF(C);
        return s instanceof Error && s.name === "AbortError" ? { data: null, error: new QF(s) } : {
          response: s instanceof ZF || s instanceof JF ? s.context : void 0
var ia = {}, wD = {}, e1 = {}, CC = {}, t1 = {}, n1 = {}, xie = function() {
}, ey = xie();
const Eie = ey.fetch, lU = ey.fetch.bind(ey), uU = ey.Headers, Tie = ey.Request, _ie = ey.Response, by = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  Headers: uU,
  Request: Tie,
  Response: _ie,
  default: lU,
  fetch: Eie
}, Symbol.toStringTag, { value: "Module" })), Oie = /* @__PURE__ */ Z9(by);
var r1 = {};
Object.defineProperty(r1, "__esModule", { value: !0 });
let Rie = class extends Error {
r1.default = Rie;
var cU = El && El.__importDefault || function(e) {
Object.defineProperty(n1, "__esModule", { value: !0 });
const kie = cU(Oie), Pie = cU(r1);
let Mie = class {
    this.shouldThrowOnError = !1, this.method = t.method, this.url = t.url, this.headers = new Headers(t.headers), this.schema = t.schema, this.body = t.body, this.shouldThrowOnError = (n = t.shouldThrowOnError) !== null && n !== void 0 ? n : !1, this.signal = t.signal, this.isMaybeSingle = (r = t.isMaybeSingle) !== null && r !== void 0 ? r : !1, t.fetch ? this.fetch = t.fetch : typeof fetch > "u" ? this.fetch = kie.default : this.fetch = fetch;
      var a, c, f, h;
      let g = null, v = null, w = null, C = s.status, T = s.statusText;
          I === "" || (this.headers.get("Accept") === "text/csv" || this.headers.get("Accept") && (!((a = this.headers.get("Accept")) === null || a === void 0) && a.includes("application/vnd.pgrst.plan+text")) ? v = I : v = JSON.parse(I));
        const O = (c = this.headers.get("Prefer")) === null || c === void 0 ? void 0 : c.match(/count=(exact|planned|estimated)/), P = (f = s.headers.get("content-range")) === null || f === void 0 ? void 0 : f.split("/");
        O && P && P.length > 1 && (w = parseInt(P[1])), this.isMaybeSingle && this.method === "GET" && Array.isArray(v) && (v.length > 1 ? (g = {
          details: `Results contain ${v.length} rows, application/vnd.pgrst.object+json requires 1 row`,
        }, v = null, w = null, C = 406, T = "Not Acceptable") : v.length === 1 ? v = v[0] : v = null);
          g = JSON.parse(O), Array.isArray(g) && s.status === 404 && (v = [], g = null, C = 200, T = "OK");
        if (g && this.isMaybeSingle && (!((h = g == null ? void 0 : g.details) === null || h === void 0) && h.includes("0 rows")) && (g = null, C = 200, T = "OK"), g && this.shouldThrowOnError)
          throw new Pie.default(g);
        data: v,
n1.default = Mie;
var Iie = El && El.__importDefault || function(e) {
Object.defineProperty(t1, "__esModule", { value: !0 });
const Die = Iie(n1);
let Aie = class extends Die.default {
    ].filter(Boolean).join("|"), h = (c = this.headers.get("Accept")) !== null && c !== void 0 ? c : "application/json";
    return this.headers.set("Accept", `application/vnd.pgrst.plan+${a}; for="${h}"; options=${f};`), a === "json" ? this : this;
t1.default = Aie;
var Nie = El && El.__importDefault || function(e) {
Object.defineProperty(CC, "__esModule", { value: !0 });
const $ie = Nie(t1);
let Lie = class extends $ie.default {
CC.default = Lie;
var jie = El && El.__importDefault || function(e) {
Object.defineProperty(e1, "__esModule", { value: !0 });
const Kw = jie(CC);
let Fie = class {
    return this.url.searchParams.set("select", c), o && this.headers.append("Prefer", `count=${o}`), new Kw.default({
    return new Kw.default({
      const f = t.reduce((h, g) => h.concat(Object.keys(g)), []);
        const h = [...new Set(f)].map((g) => `"${g}"`);
        this.url.searchParams.set("columns", h.join(","));
    return new Kw.default({
    return n && this.headers.append("Prefer", `count=${n}`), new Kw.default({
    return t && this.headers.append("Prefer", `count=${t}`), new Kw.default({
e1.default = Fie;
var dU = El && El.__importDefault || function(e) {
Object.defineProperty(wD, "__esModule", { value: !0 });
const zie = dU(e1), Bie = dU(CC);
let Hie = class fU {
    return new zie.default(n, {
    return new fU(this.url, {
    let h;
    r || o ? (c = r ? "HEAD" : "GET", Object.entries(n).filter(([v, w]) => w !== void 0).map(([v, w]) => [v, Array.isArray(w) ? `{${w.join(",")}}` : `${w}`]).forEach(([v, w]) => {
      f.searchParams.append(v, w);
    })) : (c = "POST", h = n);
    return s && g.set("Prefer", `count=${s}`), new Bie.default({
      body: h,
wD.default = Hie;
var wy = El && El.__importDefault || function(e) {
Object.defineProperty(ia, "__esModule", { value: !0 });
ia.PostgrestError = ia.PostgrestBuilder = ia.PostgrestTransformBuilder = ia.PostgrestFilterBuilder = ia.PostgrestQueryBuilder = ia.PostgrestClient = void 0;
const pU = wy(wD);
ia.PostgrestClient = pU.default;
const hU = wy(e1);
ia.PostgrestQueryBuilder = hU.default;
const mU = wy(CC);
ia.PostgrestFilterBuilder = mU.default;
const gU = wy(t1);
ia.PostgrestTransformBuilder = gU.default;
const vU = wy(n1);
ia.PostgrestBuilder = vU.default;
const yU = wy(r1);
ia.PostgrestError = yU.default;
var Vie = ia.default = {
  PostgrestClient: pU.default,
  PostgrestQueryBuilder: hU.default,
  PostgrestFilterBuilder: mU.default,
  PostgrestTransformBuilder: gU.default,
  PostgrestBuilder: vU.default,
  PostgrestError: yU.default
  PostgrestClient: Uie,
  PostgrestQueryBuilder: P0e,
  PostgrestFilterBuilder: M0e,
  PostgrestTransformBuilder: I0e,
  PostgrestBuilder: D0e,
  PostgrestError: A0e
} = Vie;
class Wie {
const Gie = "2.75.0", qie = `realtime-js/${Gie}`, Kie = "1.0.0", DM = 1e4, Yie = 1e3, Xie = 100;
var ES;
})(ES || (ES = {}));
var mi;
})(mi || (mi = {}));
var cu;
})(cu || (cu = {}));
var AM;
})(AM || (AM = {}));
var Uh;
})(Uh || (Uh = {}));
class Qie {
    const h = JSON.parse(r.decode(t.slice(a, t.byteLength)));
    return { ref: null, topic: c, event: f, payload: h };
class bU {
var qr;
})(qr || (qr = {}));
const e2 = (e, t, n = {}) => {
  return t ? Object.keys(t).reduce((s, a) => (s[a] = Jie(a, e, t, o), s), {}) : {};
}, Jie = (e, t, n, r) => {
  return s && !r.includes(s) ? wU(s, a) : NM(a);
}, wU = (e, t) => {
    return nse(t, n);
    case qr.bool:
      return Zie(t);
    case qr.float4:
    case qr.float8:
    case qr.int2:
    case qr.int4:
    case qr.int8:
    case qr.numeric:
    case qr.oid:
      return ese(t);
    case qr.json:
    case qr.jsonb:
      return tse(t);
    case qr.timestamp:
      return rse(t);
    case qr.abstime:
    case qr.date:
    case qr.daterange:
    case qr.int4range:
    case qr.int8range:
    case qr.money:
    case qr.reltime:
    case qr.text:
    case qr.time:
    case qr.timestamptz:
    case qr.timetz:
    case qr.tsrange:
    case qr.tstzrange:
      return NM(t);
      return NM(t);
}, NM = (e) => e, Zie = (e) => {
}, ese = (e) => {
}, tse = (e) => {
}, nse = (e, t) => {
    return s.map((c) => wU(t, c));
}, rse = (e) => typeof e == "string" ? e.replace(" ", "T") : e, SU = (e) => {
class vP {
  constructor(t, n, r = {}, o = DM) {
var t2;
})(t2 || (t2 = {}));
class TS {
      this.joinRef = this.channel._joinRef(), this.state = TS.syncState(this.state, o, s, a), this.pendingDiffs.forEach((f) => {
        this.state = TS.syncDiff(this.state, f, s, a);
      this.inPendingSyncState() ? this.pendingDiffs.push(o) : (this.state = TS.syncDiff(this.state, o, s, a), c());
    return this.map(s, (h, g) => {
      a[h] || (f[h] = g);
    }), this.map(a, (h, g) => {
      const v = s[h];
      if (v) {
        const w = g.map((O) => O.presence_ref), C = v.map((O) => O.presence_ref), T = g.filter((O) => C.indexOf(O.presence_ref) < 0), E = v.filter((O) => w.indexOf(O.presence_ref) < 0);
        T.length > 0 && (c[h] = T), E.length > 0 && (f[h] = E);
        c[h] = g;
      var h;
      const g = (h = t[c]) !== null && h !== void 0 ? h : [];
        const v = t[c].map((C) => C.presence_ref), w = g.filter((C) => v.indexOf(C.presence_ref) < 0);
      let h = t[c];
      if (!h)
      const g = f.map((v) => v.presence_ref);
      h = h.filter((v) => g.indexOf(v.presence_ref) < 0), t[c] = h, o(c, h, f), h.length === 0 && delete t[c];
var n2;
})(n2 || (n2 = {}));
var _S;
})(_S || (_S = {}));
var Cd;
})(Cd || (Cd = {}));
class SD {
    if (this.topic = t, this.params = n, this.socket = r, this.bindings = {}, this.state = mi.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = t.replace(/^realtime:/i, ""), this.params.config = Object.assign({
    }, n.config), this.timeout = this.socket.timeout, this.joinPush = new vP(this, cu.join, this.params, this.timeout), this.rejoinTimer = new bU(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => {
      this.state = mi.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach((a) => a.send()), this.pushBuffer = [];
      this.rejoinTimer.reset(), this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`), this.state = mi.closed, this.socket._remove(this);
      this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, a), this.state = mi.errored, this.rejoinTimer.scheduleTimeout());
      this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = mi.errored, this.rejoinTimer.scheduleTimeout());
      this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, a), this.state = mi.errored, this.rejoinTimer.scheduleTimeout());
    }), this._on(cu.reply, {}, (a, c) => {
    }), this.presence = new TS(this), this.broadcastEndpointURL = SU(this.socket.endPoint), this.private = this.params.config.private || !1, !this.private && (!((s = (o = this.params.config) === null || o === void 0 ? void 0 : o.broadcast) === null || s === void 0) && s.replay))
    if (this.socket.isConnected() || this.socket.connect(), this.state == mi.closed) {
      const { config: { broadcast: a, presence: c, private: f } } = this.params, h = (o = (r = this.bindings.postgres_changes) === null || r === void 0 ? void 0 : r.map((C) => C.filter)) !== null && o !== void 0 ? o : [], g = !!this.bindings[_S.PRESENCE] && this.bindings[_S.PRESENCE].length > 0 || ((s = this.params.config.presence) === null || s === void 0 ? void 0 : s.enabled) === !0, v = {}, w = {
        postgres_changes: h,
      this.socket.accessTokenValue && (v.access_token = this.socket.accessTokenValue), this._onError((C) => t == null ? void 0 : t(Cd.CHANNEL_ERROR, C)), this._onClose(() => t == null ? void 0 : t(Cd.CLOSED)), this.updateJoinPayload(Object.assign({ config: w }, v)), this.joinedOnce = !0, this._rejoin(n), this.joinPush.receive("ok", async ({ postgres_changes: C }) => {
          t == null || t(Cd.SUBSCRIBED);
          const E = this.bindings.postgres_changes, O = (T = E == null ? void 0 : E.length) !== null && T !== void 0 ? T : 0, P = [];
            const M = E[I], { filter: { event: A, schema: k, table: j, filter: B } } = M, H = C && C[I];
            if (H && H.event === A && H.schema === k && H.table === j && H.filter === B)
              P.push(Object.assign(Object.assign({}, M), { id: H.id }));
              this.unsubscribe(), this.state = mi.errored, t == null || t(Cd.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
          this.bindings.postgres_changes = P, t && t(Cd.SUBSCRIBED);
        this.state = mi.errored, t == null || t(Cd.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(C).join(", ") || "error")));
        t == null || t(Cd.TIMED_OUT);
    return this.state === mi.joined && t === _S.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`), this.unsubscribe().then(() => this.subscribe())), this._on(t, n, r);
        const h = await this._fetchWithTimeout(this.broadcastEndpointURL, f, (r = n.timeout) !== null && r !== void 0 ? r : this.timeout);
        return await ((o = h.body) === null || o === void 0 ? void 0 : o.cancel()), h.ok ? "ok" : "error";
      } catch (h) {
        return h.name === "AbortError" ? "timed out" : "error";
        const h = this._push(t.type, t, n.timeout || this.timeout);
        t.type === "broadcast" && !(!((f = (c = (a = this.params) === null || a === void 0 ? void 0 : a.config) === null || c === void 0 ? void 0 : c.broadcast) === null || f === void 0) && f.ack) && s("ok"), h.receive("ok", () => s("ok")), h.receive("error", () => s("error")), h.receive("timeout", () => s("timed out"));
    this.state = mi.leaving;
      this.socket.log("channel", `leave ${this.topic}`), this._trigger(cu.close, "leave", this._joinRef());
      r = new vP(this, cu.leave, {}, t), r.receive("ok", () => {
    this.pushBuffer.forEach((t) => t.destroy()), this.pushBuffer = [], this.rejoinTimer.reset(), this.joinPush.destroy(), this.state = mi.closed, this.bindings = {};
    let o = new vP(this, t, n, r);
    if (t.startTimeout(), this.pushBuffer.push(t), this.pushBuffer.length > Xie) {
    const a = t.toLocaleLowerCase(), { close: c, error: f, leave: h, join: g } = cu;
    if (r && [c, f, h, g].indexOf(a) >= 0 && r !== this._joinRef())
      var T, E, O, P, I, M;
          const A = C.id, k = (T = C.filter) === null || T === void 0 ? void 0 : T.event;
          return A && ((E = n.ids) === null || E === void 0 ? void 0 : E.includes(A)) && (k === "*" || (k == null ? void 0 : k.toLocaleLowerCase()) === ((O = n.data) === null || O === void 0 ? void 0 : O.type.toLocaleLowerCase()));
          const A = (I = (P = C == null ? void 0 : C.filter) === null || P === void 0 ? void 0 : P.event) === null || I === void 0 ? void 0 : I.toLocaleLowerCase();
          return A === "*" || A === ((M = n == null ? void 0 : n.event) === null || M === void 0 ? void 0 : M.toLocaleLowerCase());
        const T = w.data, { schema: E, table: O, commit_timestamp: P, type: I, errors: M } = T;
          commit_timestamp: P,
    return this.state === mi.closed;
    return this.state === mi.joined;
    return this.state === mi.joining;
    return this.state === mi.leaving;
      return !(((s = o.type) === null || s === void 0 ? void 0 : s.toLocaleLowerCase()) === r && SD.isEqual(o.filter, n));
    this._on(cu.close, {}, t);
    this._on(cu.error, {}, (n) => t(n));
    this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = mi.joining, this.joinPush.resend(t));
    return (t.type === "INSERT" || t.type === "UPDATE") && (n.new = e2(t.columns, t.record)), (t.type === "UPDATE" || t.type === "DELETE") && (n.old = e2(t.columns, t.old_record)), n;
const yP = () => {
}, UE = {
}, ose = [1e3, 2e3, 5e3, 1e4], ise = 1e4, sse = `
class ase {
    if (this.accessTokenValue = null, this.apiKey = null, this.channels = new Array(), this.endPoint = "", this.httpEndpoint = "", this.headers = {}, this.params = {}, this.timeout = DM, this.transport = null, this.heartbeatIntervalMs = UE.HEARTBEAT_INTERVAL, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.heartbeatCallback = yP, this.ref = 0, this.reconnectTimer = null, this.logger = yP, this.conn = null, this.sendBuffer = [], this.serializer = new Qie(), this.stateChangeCallbacks = {
      return o ? s = o : typeof fetch > "u" ? s = (...a) => Promise.resolve().then(() => by).then(({ default: c }) => c(...a)).catch((c) => {
    this.apiKey = n.params.apikey, this.endPoint = `${t}/${AM.websocket}`, this.httpEndpoint = SU(t), this._initializeOptions(n), this._setupReconnectionTimer(), this.fetch = this._resolveFetch(n == null ? void 0 : n.fetch);
          this.conn = Wie.createWebSocket(this.endpointURL());
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: Kie }));
      case ES.connecting:
        return Uh.Connecting;
      case ES.open:
        return Uh.Open;
      case ES.closing:
        return Uh.Closing;
        return Uh.Closed;
    return this.connectionState() === Uh.Open;
      const s = new SD(`realtime:${t}`, n, this);
      this._wasManualDisconnect = !1, (t = this.conn) === null || t === void 0 || t.close(Yie, "heartbeat timeout"), setTimeout(() => {
      }, UE.HEARTBEAT_TIMEOUT_FALLBACK);
        } catch (h) {
          this.log("error", "error in heartbeat callback", h);
      this.log("receive", `${f} ${r} ${o} ${c}`.trim(), s), this.channels.filter((h) => h._isMember(r)).forEach((h) => h._trigger(o, s, a)), this._triggerStateCallbacks("message", n);
    this.channels.forEach((t) => t._trigger(cu.error));
      const r = new Blob([sse], { type: "application/javascript" });
        version: qie
      n && r.updateJoinPayload(o), r.joinedOnce && r._isJoined() && r._push(cu.access_token, {
    this.reconnectTimer = new bU(async () => {
      }, UE.RECONNECT_DELAY);
    var n, r, o, s, a, c, f, h, g;
    if (this.transport = (n = t == null ? void 0 : t.transport) !== null && n !== void 0 ? n : null, this.timeout = (r = t == null ? void 0 : t.timeout) !== null && r !== void 0 ? r : DM, this.heartbeatIntervalMs = (o = t == null ? void 0 : t.heartbeatIntervalMs) !== null && o !== void 0 ? o : UE.HEARTBEAT_INTERVAL, this.worker = (s = t == null ? void 0 : t.worker) !== null && s !== void 0 ? s : !1, this.accessToken = (a = t == null ? void 0 : t.accessToken) !== null && a !== void 0 ? a : null, this.heartbeatCallback = (c = t == null ? void 0 : t.heartbeatCallback) !== null && c !== void 0 ? c : yP, t != null && t.params && (this.params = t.params), t != null && t.logger && (this.logger = t.logger), (t != null && t.logLevel || t != null && t.log_level) && (this.logLevel = t.logLevel || t.log_level, this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel })), this.reconnectAfterMs = (f = t == null ? void 0 : t.reconnectAfterMs) !== null && f !== void 0 ? f : (v) => ose[v - 1] || ise, this.encode = (h = t == null ? void 0 : t.encode) !== null && h !== void 0 ? h : (v, w) => w(JSON.stringify(v)), this.decode = (g = t == null ? void 0 : t.decode) !== null && g !== void 0 ? g : this.serializer.decode.bind(this.serializer), this.worker) {
class CD extends Error {
function Ko(e) {
class lse extends CD {
class $M extends CD {
var use = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
const CU = (e) => {
  return e ? t = e : typeof fetch > "u" ? t = (...n) => Promise.resolve().then(() => by).then(({ default: r }) => r(...n)) : t = fetch, (...n) => t(...n);
}, cse = () => use(void 0, void 0, void 0, function* () {
  return typeof Response > "u" ? (yield Promise.resolve().then(() => by)).Response : Response;
}), LM = (e) => {
    return e.map((n) => LM(n));
    t[o] = LM(r);
}, dse = (e) => {
var bm = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
const bP = (e) => e.msg || e.message || e.error_description || e.error || JSON.stringify(e), fse = (e, t, n) => bm(void 0, void 0, void 0, function* () {
  const r = yield cse();
    t(new lse(bP(o), s, a));
    t(new $M(bP(o), o));
  }) : t(new $M(bP(e), e));
}), pse = (e, t, n, r) => {
  return e === "GET" || !r ? o : (dse(r) ? (o.headers = Object.assign({ "Content-Type": "application/json" }, t == null ? void 0 : t.headers), o.body = JSON.stringify(r)) : o.body = r, t != null && t.duplex && (o.duplex = t.duplex), Object.assign(Object.assign({}, o), n));
function xC(e, t, n, r, o, s) {
  return bm(this, void 0, void 0, function* () {
      e(n, pse(t, r, o, s)).then((f) => {
      }).then((f) => a(f)).catch((f) => fse(f, c, r));
function WT(e, t, n, r) {
  return bm(this, void 0, void 0, function* () {
    return xC(e, "GET", t, n, r);
function uc(e, t, n, r, o) {
  return bm(this, void 0, void 0, function* () {
    return xC(e, "POST", t, r, o, n);
function jM(e, t, n, r, o) {
  return bm(this, void 0, void 0, function* () {
    return xC(e, "PUT", t, r, o, n);
function hse(e, t, n, r) {
  return bm(this, void 0, void 0, function* () {
    return xC(e, "HEAD", t, Object.assign(Object.assign({}, n), { noResolveJson: !0 }), r);
function xU(e, t, n, r, o) {
  return bm(this, void 0, void 0, function* () {
    return xC(e, "DELETE", t, r, o, n);
var mse = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
class gse {
    return mse(this, void 0, void 0, function* () {
        if (Ko(t))
var vse = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
class yse {
    return new gse(this.downloadFn, this.shouldThrowOnError);
    return vse(this, void 0, void 0, function* () {
        if (Ko(t))
var ta = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
const bse = {
}, r2 = {
class wse {
    this.shouldThrowOnError = !1, this.url = t, this.headers = n, this.bucketId = r, this.fetch = CU(o);
    return ta(this, void 0, void 0, function* () {
        const a = Object.assign(Object.assign({}, r2), o);
        const h = this._removeEmptyFolders(n), g = this._getFinalPath(h), v = yield (t == "PUT" ? jM : uc)(this.fetch, `${this.url}/object/${g}`, s, Object.assign({ headers: c }, a != null && a.duplex ? { duplex: a.duplex } : {}));
          data: { path: h, id: v.Id, fullPath: v.Key },
        if (Ko(s))
    return ta(this, void 0, void 0, function* () {
    return ta(this, void 0, void 0, function* () {
        const h = Object.assign({ upsert: r2.upsert }, o), g = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(h.upsert) });
        typeof Blob < "u" && r instanceof Blob ? (f = new FormData(), f.append("cacheControl", h.cacheControl), f.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (f = r, f.append("cacheControl", h.cacheControl)) : (f = r, g["cache-control"] = `max-age=${h.cacheControl}`, g["content-type"] = h.contentType);
        const v = yield jM(this.fetch, c.toString(), f, { headers: g });
          data: { path: s, fullPath: v.Key },
        if (Ko(f))
    return ta(this, void 0, void 0, function* () {
        const s = yield uc(this.fetch, `${this.url}/object/upload/sign/${r}`, {}, { headers: o }), a = new URL(this.url + s.url), c = a.searchParams.get("token");
          throw new CD("No token returned by API");
        if (Ko(r))
    return ta(this, void 0, void 0, function* () {
    return ta(this, void 0, void 0, function* () {
        return { data: yield uc(this.fetch, `${this.url}/object/move`, {
        if (Ko(o))
    return ta(this, void 0, void 0, function* () {
        return { data: { path: (yield uc(this.fetch, `${this.url}/object/copy`, {
        if (Ko(o))
    return ta(this, void 0, void 0, function* () {
        let o = this._getFinalPath(t), s = yield uc(this.fetch, `${this.url}/object/sign/${o}`, Object.assign({ expiresIn: n }, r != null && r.transform ? { transform: r.transform } : {}), { headers: this.headers });
        if (Ko(o))
    return ta(this, void 0, void 0, function* () {
        const o = yield uc(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn: n, paths: t }, { headers: this.headers }), s = r != null && r.download ? `&download=${r.download === !0 ? "" : r.download}` : "";
        if (Ko(o))
    const o = typeof (n == null ? void 0 : n.transform) < "u" ? "render/image/authenticated" : "object", s = this.transformOptsToQueryString((n == null ? void 0 : n.transform) || {}), a = s ? `?${s}` : "", c = this._getFinalPath(t), f = () => WT(this.fetch, `${this.url}/${o}/${c}${a}`, {
    return new yse(f, this.shouldThrowOnError);
    return ta(this, void 0, void 0, function* () {
        const r = yield WT(this.fetch, `${this.url}/object/info/${n}`, {
        return { data: LM(r), error: null };
        if (Ko(r))
    return ta(this, void 0, void 0, function* () {
        return yield hse(this.fetch, `${this.url}/object/${n}`, {
        if (Ko(r) && r instanceof $M) {
    let h = o.join("&");
    return h !== "" && (h = `?${h}`), {
      data: { publicUrl: encodeURI(`${this.url}/${c}/public/${r}${h}`) }
    return ta(this, void 0, void 0, function* () {
        return { data: yield xU(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: t }, { headers: this.headers }), error: null };
        if (Ko(n))
    return ta(this, void 0, void 0, function* () {
        const o = Object.assign(Object.assign(Object.assign({}, bse), n), { prefix: t || "" });
        return { data: yield uc(this.fetch, `${this.url}/object/list/${this.bucketId}`, o, { headers: this.headers }, r), error: null };
        if (Ko(o))
    return ta(this, void 0, void 0, function* () {
        return { data: yield uc(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, r, { headers: this.headers }, n), error: null };
        if (Ko(r))
const Sse = "2.75.0", Cse = { "X-Client-Info": `storage-js/${Sse}` };
var pv = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
class xse {
    o != null && o.useNewHostname && /supabase\.(co|in|red)$/.test(s.hostname) && !s.hostname.includes("storage.supabase.") && (s.hostname = s.hostname.replace("supabase.", "storage.supabase.")), this.url = s.href.replace(/\/$/, ""), this.headers = Object.assign(Object.assign({}, Cse), n), this.fetch = CU(r);
    return pv(this, void 0, void 0, function* () {
        return { data: yield WT(this.fetch, `${this.url}/bucket`, { headers: this.headers }), error: null };
        if (Ko(t))
    return pv(this, void 0, void 0, function* () {
        return { data: yield WT(this.fetch, `${this.url}/bucket/${t}`, { headers: this.headers }), error: null };
        if (Ko(n))
    return pv(this, arguments, void 0, function* (n, r = {
        return { data: yield uc(this.fetch, `${this.url}/bucket`, {
        if (Ko(o))
    return pv(this, void 0, void 0, function* () {
        return { data: yield jM(this.fetch, `${this.url}/bucket/${t}`, {
        if (Ko(r))
    return pv(this, void 0, void 0, function* () {
        return { data: yield uc(this.fetch, `${this.url}/bucket/${t}/empty`, {}, { headers: this.headers }), error: null };
        if (Ko(n))
    return pv(this, void 0, void 0, function* () {
        return { data: yield xU(this.fetch, `${this.url}/bucket/${t}`, {}, { headers: this.headers }), error: null };
        if (Ko(n))
class Ese extends xse {
    return new wse(this.url, this.headers, t, this.fetch);
const Tse = "2.75.0";
let dS = "";
typeof Deno < "u" ? dS = "deno" : typeof document < "u" ? dS = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? dS = "react-native" : dS = "node";
const _se = { "X-Client-Info": `supabase-js-${dS}/${Tse}` }, Ose = {
  headers: _se
}, Rse = {
}, kse = {
}, Pse = {};
var Mse = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
const Ise = (e) => {
  return e ? t = e : typeof fetch > "u" ? t = lU : t = fetch, (...n) => t(...n);
}, Dse = () => typeof Headers > "u" ? uU : Headers, Ase = (e, t, n) => {
  const r = Ise(n), o = Dse();
  return (s, a) => Mse(void 0, void 0, void 0, function* () {
    let h = new o(a == null ? void 0 : a.headers);
    return h.has("apikey") || h.set("apikey", e), h.has("Authorization") || h.set("Authorization", `Bearer ${f}`), r(s, Object.assign(Object.assign({}, a), { headers: h }));
var Nse = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
function $se(e) {
function Lse(e, t) {
  const { db: o, auth: s, realtime: a, global: c } = e, { db: f, auth: h, realtime: g, global: v } = t, w = {
    auth: Object.assign(Object.assign({}, h), s),
    global: Object.assign(Object.assign(Object.assign({}, v), c), { headers: Object.assign(Object.assign({}, (n = v == null ? void 0 : v.headers) !== null && n !== void 0 ? n : {}), (r = c == null ? void 0 : c.headers) !== null && r !== void 0 ? r : {}) }),
    accessToken: () => Nse(this, void 0, void 0, function* () {
function jse(e) {
    return new URL($se(t));
const EU = "2.75.0", Tv = 30 * 1e3, FM = 3, wP = FM * Tv, Fse = "http://localhost:9999", zse = "supabase.auth.token", Bse = { "X-Client-Info": `gotrue-js/${EU}` }, zM = "X-Supabase-Api-Version", TU = {
}, Hse = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i, Vse = 10 * 60 * 1e3;
class YS extends Error {
function dn(e) {
class Use extends YS {
function Wse(e) {
  return dn(e) && e.name === "AuthApiError";
class Wh extends YS {
class dp extends YS {
class Nf extends dp {
function Gse(e) {
  return dn(e) && e.name === "AuthSessionMissingError";
class hv extends dp {
class WE extends dp {
class GE extends dp {
function qse(e) {
  return dn(e) && e.name === "AuthImplicitGrantRedirectError";
class o2 extends dp {
class BM extends dp {
function SP(e) {
  return dn(e) && e.name === "AuthRetryableFetchError";
class i2 extends dp {
class HM extends dp {
const GT = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""), s2 = ` 	
\r=`.split(""), Kse = (() => {
  for (let t = 0; t < s2.length; t += 1)
    e[s2[t].charCodeAt(0)] = -2;
  for (let t = 0; t < GT.length; t += 1)
    e[GT[t].charCodeAt(0)] = t;
function a2(e, t, n) {
      n(GT[r]), t.queuedBits -= 6;
      n(GT[r]), t.queuedBits -= 6;
function _U(e, t, n) {
  const r = Kse[e];
function l2(e) {
    Qse(a, r, n);
    _U(e.charCodeAt(a), o, s);
function Yse(e, t) {
function Xse(e, t) {
    Yse(r, t);
function Qse(e, t, n) {
function Fv(e) {
    _U(e.charCodeAt(o), n, r);
function Jse(e) {
  return Xse(e, (n) => t.push(n)), new Uint8Array(t);
function Qh(e) {
  return e.forEach((o) => a2(o, n, r)), a2(null, n, r), t.join("");
function Zse(e) {
function eae() {
const Oa = () => typeof window < "u" && typeof document < "u", Mh = {
}, OU = () => {
  if (!Oa())
  if (Mh.tested)
    return Mh.writable;
    globalThis.localStorage.setItem(e, e), globalThis.localStorage.removeItem(e), Mh.tested = !0, Mh.writable = !0;
    Mh.tested = !0, Mh.writable = !1;
  return Mh.writable;
function tae(e) {
const RU = (e) => {
  return e ? t = e : typeof fetch > "u" ? t = (...n) => Promise.resolve().then(() => by).then(({ default: r }) => r(...n)) : t = fetch, (...n) => t(...n);
}, nae = (e) => typeof e == "object" && e !== null && "status" in e && "ok" in e && "json" in e && typeof e.json == "function", _v = async (e, t, n) => {
}, Ih = async (e, t) => {
}, Af = async (e, t) => {
class o1 {
    this.promise = new o1.promiseConstructor((t, n) => {
o1.promiseConstructor = Promise;
function CP(e) {
    throw new HM("Invalid JWT structure");
    if (!Hse.test(t[r]))
      throw new HM("JWT not in base64url format");
    header: JSON.parse(l2(t[0])),
    payload: JSON.parse(l2(t[1])),
    signature: Fv(t[2]),
async function rae(e) {
function oae(e, t) {
function iae(e) {
function sae() {
  return crypto.getRandomValues(t), Array.from(t, iae).join("");
async function aae(e) {
async function lae(e) {
  const n = await aae(e);
async function mv(e, t, n = !1) {
  const r = sae();
  n && (o += "/PASSWORD_RECOVERY"), await _v(e, `${t}-code-verifier`, o);
  const s = await lae(r);
const uae = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function cae(e) {
  const t = e.headers.get(zM);
  if (!t || !t.match(uae))
function dae(e) {
function fae(e) {
const pae = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function gv(e) {
  if (!pae.test(e))
function xP() {
function u2(e) {
var hae = function(e, t) {
const Fh = (e) => e.msg || e.message || e.error_description || e.error || JSON.stringify(e), mae = [502, 503, 504];
async function c2(e) {
  if (!nae(e))
    throw new BM(Fh(e), 0);
  if (mae.includes(e.status))
    throw new BM(Fh(e), e.status);
    throw new Wh(Fh(s), s);
  const o = cae(e);
  if (o && o.getTime() >= TU["2024-01-01"].timestamp && typeof n == "object" && n && typeof n.code == "string" ? r = n.code : typeof n == "object" && n && typeof n.error_code == "string" && (r = n.error_code), r) {
      throw new i2(Fh(n), e.status, ((t = n.weak_password) === null || t === void 0 ? void 0 : t.reasons) || []);
      throw new Nf();
    throw new i2(Fh(n), e.status, n.weak_password.reasons);
  throw new Use(Fh(n), e.status || 500, r);
const gae = (e, t, n, r) => {
async function Rn(e, t, n, r) {
  s[zM] || (s[zM] = TU["2024-01-01"].name), r != null && r.jwt && (s.Authorization = `Bearer ${r.jwt}`);
  const c = Object.keys(a).length ? "?" + new URLSearchParams(a).toString() : "", f = await vae(e, t, n + c, {
async function vae(e, t, n, r, o, s) {
  const a = gae(t, r, o, s);
    throw console.error(f), new BM(Fh(f), 0);
  if (c.ok || await c2(c), r != null && r.noResolveJson)
    await c2(f);
function au(e) {
  wae(e) && (n = Object.assign({}, e), e.expires_at || (n.expires_at = Zse(e.expires_in)));
function d2(e) {
  const t = au(e);
function zf(e) {
function yae(e) {
function bae(e) {
  const { action_link: t, email_otp: n, hashed_token: r, redirect_to: o, verification_type: s } = e, a = hae(e, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]), c = {
function f2(e) {
function wae(e) {
const EP = ["global", "local", "others"];
var Sae = function(e, t) {
class Cae {
    this.url = t, this.headers = n, this.fetch = RU(r), this.mfa = {
  async signOut(t, n = EP[0]) {
    if (EP.indexOf(n) < 0)
      throw new Error(`@supabase/auth-js: Parameter scope must be one of ${EP.join(", ")}`);
      return await Rn(this.fetch, "POST", `${this.url}/logout?scope=${n}`, {
      if (dn(r))
      return await Rn(this.fetch, "POST", `${this.url}/invite`, {
        xform: zf
      if (dn(r))
      const { options: n } = t, r = Sae(t, ["options"]), o = Object.assign(Object.assign({}, r), n);
      return "newEmail" in r && (o.new_email = r == null ? void 0 : r.newEmail, delete o.newEmail), await Rn(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        xform: bae,
      if (dn(n))
      return await Rn(this.fetch, "POST", `${this.url}/admin/users`, {
        xform: zf
      if (dn(n))
      const h = { nextPage: null, lastPage: 0, total: 0 }, g = await Rn(this.fetch, "GET", `${this.url}/admin/users`, {
        xform: f2
      const v = await g.json(), w = (a = g.headers.get("x-total-count")) !== null && a !== void 0 ? a : 0, C = (f = (c = g.headers.get("link")) === null || c === void 0 ? void 0 : c.split(",")) !== null && f !== void 0 ? f : [];
        h[`${O}Page`] = E;
      }), h.total = parseInt(w)), { data: Object.assign(Object.assign({}, v), h), error: null };
    } catch (h) {
      if (dn(h))
        return { data: { users: [] }, error: h };
      throw h;
    gv(t);
      return await Rn(this.fetch, "GET", `${this.url}/admin/users/${t}`, {
        xform: zf
      if (dn(n))
    gv(t);
      return await Rn(this.fetch, "PUT", `${this.url}/admin/users/${t}`, {
        xform: zf
      if (dn(r))
    gv(t);
      return await Rn(this.fetch, "DELETE", `${this.url}/admin/users/${t}`, {
        xform: zf
      if (dn(r))
    gv(t.userId);
      const { data: n, error: r } = await Rn(this.fetch, "GET", `${this.url}/admin/users/${t.userId}/factors`, {
      if (dn(n))
    gv(t.userId), gv(t.id);
      return { data: await Rn(this.fetch, "DELETE", `${this.url}/admin/users/${t.userId}/factors/${t.id}`, {
      if (dn(n))
      const h = { nextPage: null, lastPage: 0, total: 0 }, g = await Rn(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
        xform: f2
      const v = await g.json(), w = (a = g.headers.get("x-total-count")) !== null && a !== void 0 ? a : 0, C = (f = (c = g.headers.get("link")) === null || c === void 0 ? void 0 : c.split(",")) !== null && f !== void 0 ? f : [];
        h[`${O}Page`] = E;
      }), h.total = parseInt(w)), { data: Object.assign(Object.assign({}, v), h), error: null };
    } catch (h) {
      if (dn(h))
        return { data: { clients: [] }, error: h };
      throw h;
      return await Rn(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
      if (dn(n))
      return await Rn(this.fetch, "GET", `${this.url}/admin/oauth/clients/${t}`, {
      if (dn(n))
      return await Rn(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${t}`, {
      if (dn(n))
      return await Rn(this.fetch, "POST", `${this.url}/admin/oauth/clients/${t}/regenerate_secret`, {
      if (dn(n))
function p2(e = {}) {
const vv = {
  debug: !!(globalThis && OU() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
class kU extends Error {
class xae extends kU {
async function Eae(e, t, n) {
  vv.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", e, t);
    r.abort(), vv.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", e);
      vv.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", e, o.name);
        vv.debug && console.log("@supabase/gotrue-js: navigatorLock: released", e, o.name);
        throw vv.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", e), new xae(`Acquiring an exclusive Navigator LockManager lock "${e}" immediately failed`);
      if (vv.debug)
function Tae() {
function PU(e) {
function _ae(e) {
function Oae(e) {
function Rae(e) {
  const { chainId: n, domain: r, expirationTime: o, issuedAt: s = /* @__PURE__ */ new Date(), nonce: a, notBefore: c, requestId: f, resources: h, scheme: g, uri: v, version: w } = e;
    if (!v)
  const C = PU(e.address), T = g ? `${g}://${r}` : r, E = e.statement ? `${e.statement}
  let P = `URI: ${v}
  if (o && (P += `
Expiration Time: ${o.toISOString()}`), c && (P += `
Not Before: ${c.toISOString()}`), f && (P += `
Request ID: ${f}`), h) {
    for (const M of h) {
    P += I;
${P}`;
class qo extends Error {
class qT extends qo {
function kae({ error: e, options: t }) {
      return new qo({
      return new qo({
      return new qo({
      return new qo({
      return new qo({
      return new qo({
      return s.pubKeyCredParams.filter((c) => c.type === "public-key").length === 0 ? new qo({
      }) : new qo({
      if (IU(a)) {
          return new qo({
      } else return new qo({
        return new qo({
      return new qo({
  return new qo({
function Pae({ error: e, options: t }) {
      return new qo({
      return new qo({
      if (IU(r)) {
          return new qo({
      } else return new qo({
      return new qo({
  return new qo({
var MU = function(e, t) {
class Mae {
const Iae = new Mae();
function Dae(e) {
  const { challenge: t, user: n, excludeCredentials: r } = e, o = MU(
  ), s = Fv(t).buffer, a = Object.assign(Object.assign({}, n), { id: Fv(n.id).buffer }), c = Object.assign(Object.assign({}, o), {
      const h = r[f];
      c.excludeCredentials[f] = Object.assign(Object.assign({}, h), {
        id: Fv(h.id).buffer,
        type: h.type || "public-key",
        transports: h.transports
function Aae(e) {
  const { challenge: t, allowCredentials: n } = e, r = MU(
  ), o = Fv(t).buffer, s = Object.assign(Object.assign({}, r), { challenge: o });
        id: Fv(c.id).buffer,
function Nae(e) {
      attestationObject: Qh(new Uint8Array(e.response.attestationObject)),
      clientDataJSON: Qh(new Uint8Array(e.response.clientDataJSON))
function $ae(e) {
      authenticatorData: Qh(new Uint8Array(o.authenticatorData)),
      clientDataJSON: Qh(new Uint8Array(o.clientDataJSON)),
      signature: Qh(new Uint8Array(o.signature)),
      userHandle: o.userHandle ? Qh(new Uint8Array(o.userHandle)) : void 0
function IU(e) {
function h2() {
  return !!(Oa() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof ((e = navigator == null ? void 0 : navigator.credentials) === null || e === void 0 ? void 0 : e.create) == "function" && typeof ((t = navigator == null ? void 0 : navigator.credentials) === null || t === void 0 ? void 0 : t.get) == "function");
async function Lae(e) {
      error: new qT("Browser returned unexpected credential type", t)
      error: new qT("Empty credential response", t)
      error: kae({
async function jae(e) {
      error: new qT("Browser returned unexpected credential type", t)
      error: new qT("Empty credential response", t)
      error: Pae({
const Fae = {
}, zae = {
function KT(...e) {
            t(c) ? r[s] = KT(c, a) : r[s] = KT(a);
function Bae(e, t) {
  return KT(Fae, e, t || {});
function Hae(e, t) {
  return KT(zae, e, t || {});
class Vae {
      const f = o ?? Iae.createNewAbortSignal();
        const { user: h } = a.webauthn.credential_options.publicKey;
        h.name || (h.name = `${h.id}:${r}`), h.displayName || (h.displayName = h.name);
          const h = Bae(a.webauthn.credential_options.publicKey, s == null ? void 0 : s.create), { data: g, error: v } = await Lae({
            publicKey: h,
          } : { data: null, error: v };
          const h = Hae(a.webauthn.credential_options.publicKey, s == null ? void 0 : s.request), { data: g, error: v } = await jae(Object.assign(Object.assign({}, a.webauthn.credential_options), { publicKey: h, signal: f }));
          } : { data: null, error: v };
      return dn(a) ? { data: null, error: a } : {
        error: new Wh("Unexpected error in challenge", a)
        error: new YS("rpId is required for WebAuthn authentication")
      if (!h2())
          error: new Wh("Browser does not support WebAuthn", null)
      return dn(a) ? { data: null, error: a } : {
        error: new Wh("Unexpected error in authenticate", a)
        error: new YS("rpId is required for WebAuthn registration")
      if (!h2())
          error: new Wh("Browser does not support WebAuthn", null)
          var v;
          return (v = g.data) === null || v === void 0 ? void 0 : v.all.find((w) => w.factor_type === "webauthn" && w.friendly_name === t && w.status !== "unverified");
      const { data: f, error: h } = await this._challenge({
      }) : { data: null, error: h };
      return dn(a) ? { data: null, error: a } : {
        error: new Wh("Unexpected error in register", a)
Tae();
const Uae = {
  url: Fse,
  storageKey: zse,
  headers: Bse,
async function m2(e, t, n) {
const yv = {};
class XS {
    return (n = (t = yv[this.storageKey]) === null || t === void 0 ? void 0 : t.jwks) !== null && n !== void 0 ? n : { keys: [] };
    yv[this.storageKey] = Object.assign(Object.assign({}, yv[this.storageKey]), { jwks: t });
    return (n = (t = yv[this.storageKey]) === null || t === void 0 ? void 0 : t.cachedAt) !== null && n !== void 0 ? n : Number.MIN_SAFE_INTEGER;
    yv[this.storageKey] = Object.assign(Object.assign({}, yv[this.storageKey]), { cachedAt: t });
    this.userStorage = null, this.memoryStorage = null, this.stateChangeEmitters = /* @__PURE__ */ new Map(), this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.hasCustomAuthorizationHeader = !1, this.suppressGetSessionWarning = !1, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log, this.instanceID = XS.nextInstanceID, XS.nextInstanceID += 1, this.instanceID > 0 && Oa() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    const o = Object.assign(Object.assign({}, Uae), t);
    if (this.logDebugMessages = !!o.debug, typeof o.debug == "function" && (this.logger = o.debug), this.persistSession = o.persistSession, this.storageKey = o.storageKey, this.autoRefreshToken = o.autoRefreshToken, this.admin = new Cae({
    }), this.url = o.url, this.headers = o.headers, this.fetch = RU(o.fetch), this.lock = o.lock || m2, this.detectSessionInUrl = o.detectSessionInUrl, this.flowType = o.flowType, this.hasCustomAuthorizationHeader = o.hasCustomAuthorizationHeader, o.lock ? this.lock = o.lock : Oa() && (!((n = globalThis == null ? void 0 : globalThis.navigator) === null || n === void 0) && n.locks) ? this.lock = Eae : this.lock = m2, this.jwks || (this.jwks = { keys: [] }, this.jwks_cached_at = Number.MIN_SAFE_INTEGER), this.mfa = {
      webauthn: new Vae(this)
    }, this.persistSession ? (o.storage ? this.storage = o.storage : OU() ? this.storage = globalThis.localStorage : (this.memoryStorage = {}, this.storage = p2(this.memoryStorage)), o.userStorage && (this.userStorage = o.userStorage)) : (this.memoryStorage = {}, this.storage = p2(this.memoryStorage)), Oa() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
    return this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${EU}) ${(/* @__PURE__ */ new Date()).toISOString()}`, ...t), this;
      const n = tae(window.location.href);
      if (this._isImplicitGrantCallback(n) ? r = "implicit" : await this._isPKCECallback(n) && (r = "pkce"), Oa() && this.detectSessionInUrl && r !== "none") {
          if (this._debug("#_initialize()", "error detecting session from URL", s), qse(s)) {
      return dn(n) ? { error: n } : {
        error: new Wh("Unexpected error during initialization", n)
      const s = await Rn(this.fetch, "POST", `${this.url}/signup`, {
        xform: au
      const f = a.session, h = a.user;
      return a.session && (await this._saveSession(a.session), await this._notifyAllSubscribers("SIGNED_IN", f)), { data: { user: h, session: f }, error: null };
      if (dn(s))
        const { email: g, password: v, options: w } = t;
        this.flowType === "pkce" && ([C, T] = await mv(this.storage, this.storageKey)), s = await Rn(this.fetch, "POST", `${this.url}/signup`, {
            password: v,
          xform: au
        const { phone: g, password: v, options: w } = t;
        s = await Rn(this.fetch, "POST", `${this.url}/signup`, {
            password: v,
          xform: au
        throw new WE("You must provide either an email or phone number and a password");
      const f = a.session, h = a.user;
      return a.session && (await this._saveSession(a.session), await this._notifyAllSubscribers("SIGNED_IN", f)), { data: { user: h, session: f }, error: null };
      if (dn(s))
        n = await Rn(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          xform: d2
        n = await Rn(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          xform: d2
        throw new WE("You must provide either an email or phone number and a password");
      return o ? { data: { user: null, session: null }, error: o } : !r || !r.session || !r.user ? { data: { user: null, session: null }, error: new hv() } : (r.session && (await this._saveSession(r.session), await this._notifyAllSubscribers("SIGNED_IN", r.session)), {
      if (dn(n))
    var n, r, o, s, a, c, f, h, g, v, w;
      const { chain: E, wallet: O, statement: P, options: I } = t;
      if (Oa())
          const F = window;
          if ("ethereum" in F && typeof F.ethereum == "object" && "request" in F.ethereum && typeof F.ethereum.request == "function")
            M = F.ethereum;
      const A = new URL((n = I == null ? void 0 : I.url) !== null && n !== void 0 ? n : window.location.href), k = await M.request({
      }).then((F) => F).catch(() => {
      if (!k || k.length === 0)
      const j = PU(k[0]);
      let B = (r = I == null ? void 0 : I.signInWithEthereum) === null || r === void 0 ? void 0 : r.chainId;
      if (!B) {
        const F = await M.request({
        B = _ae(F);
      const H = {
        domain: A.host,
        address: j,
        statement: P,
        uri: A.href,
        chainId: B,
        requestId: (h = I == null ? void 0 : I.signInWithEthereum) === null || h === void 0 ? void 0 : h.requestId,
      C = Rae(H), T = await M.request({
        params: [Oae(C), j]
      const { data: E, error: O } = await Rn(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
        }, !((v = t.options) === null || v === void 0) && v.captchaToken ? { gotrue_meta_security: { captcha_token: (w = t.options) === null || w === void 0 ? void 0 : w.captchaToken } } : null),
        xform: au
        error: new hv()
      if (dn(E))
    var n, r, o, s, a, c, f, h, g, v, w, C;
      const { chain: O, wallet: P, statement: I, options: M } = t;
      let A;
      if (Oa())
        if (typeof P == "object")
          A = P;
          const j = window;
          if ("solana" in j && typeof j.solana == "object" && ("signIn" in j.solana && typeof j.solana.signIn == "function" || "signMessage" in j.solana && typeof j.solana.signMessage == "function"))
            A = j.solana;
        if (typeof P != "object" || !(M != null && M.url))
        A = P;
      const k = new URL((n = M == null ? void 0 : M.url) !== null && n !== void 0 ? n : window.location.href);
      if ("signIn" in A && A.signIn) {
        const j = await A.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: (/* @__PURE__ */ new Date()).toISOString() }, M == null ? void 0 : M.signInWithSolana), {
          domain: k.host,
          uri: k.href
        let B;
        if (Array.isArray(j) && j[0] && typeof j[0] == "object")
          B = j[0];
        else if (j && typeof j == "object" && "signedMessage" in j && "signature" in j)
          B = j;
        if ("signedMessage" in B && "signature" in B && (typeof B.signedMessage == "string" || B.signedMessage instanceof Uint8Array) && B.signature instanceof Uint8Array)
          T = typeof B.signedMessage == "string" ? B.signedMessage : new TextDecoder().decode(B.signedMessage), E = B.signature;
        if (!("signMessage" in A) || typeof A.signMessage != "function" || !("publicKey" in A) || typeof A != "object" || !A.publicKey || !("toBase58" in A.publicKey) || typeof A.publicKey.toBase58 != "function")
          `${k.host} wants you to sign in with your Solana account:`,
          A.publicKey.toBase58(),
          `URI: ${k.href}`,
          ...!((h = M == null ? void 0 : M.signInWithSolana) === null || h === void 0) && h.requestId ? [`Request ID: ${M.signInWithSolana.requestId}`] : [],
          ...!((v = (g = M == null ? void 0 : M.signInWithSolana) === null || g === void 0 ? void 0 : g.resources) === null || v === void 0) && v.length ? [
            ...M.signInWithSolana.resources.map((B) => `- ${B}`)
        const j = await A.signMessage(new TextEncoder().encode(T), "utf8");
        if (!j || !(j instanceof Uint8Array))
        E = j;
      const { data: O, error: P } = await Rn(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
        body: Object.assign({ chain: "solana", message: T, signature: Qh(E) }, !((w = t.options) === null || w === void 0) && w.captchaToken ? { gotrue_meta_security: { captcha_token: (C = t.options) === null || C === void 0 ? void 0 : C.captchaToken } } : null),
        xform: au
      if (P)
        throw P;
        error: new hv()
      } : (O.session && (await this._saveSession(O.session), await this._notifyAllSubscribers("SIGNED_IN", O.session)), { data: Object.assign({}, O), error: P });
      if (dn(O))
    const n = await Ih(this.storage, `${this.storageKey}-code-verifier`), [r, o] = (n ?? "").split("/");
      const { data: s, error: a } = await Rn(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
        xform: au
      if (await Af(this.storage, `${this.storageKey}-code-verifier`), a)
        error: new hv()
      if (dn(s))
      const { options: n, provider: r, token: o, access_token: s, nonce: a } = t, c = await Rn(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        xform: au
      }), { data: f, error: h } = c;
      return h ? { data: { user: null, session: null }, error: h } : !f || !f.session || !f.user ? {
        error: new hv()
      } : (f.session && (await this._saveSession(f.session), await this._notifyAllSubscribers("SIGNED_IN", f.session)), { data: f, error: h });
      if (dn(n))
        let h = null, g = null;
        this.flowType === "pkce" && ([h, g] = await mv(this.storage, this.storageKey));
        const { error: v } = await Rn(this.fetch, "POST", `${this.url}/otp`, {
            code_challenge: h,
        return { data: { user: null, session: null }, error: v };
        const { phone: c, options: f } = t, { data: h, error: g } = await Rn(this.fetch, "POST", `${this.url}/otp`, {
        return { data: { user: null, session: null, messageId: h == null ? void 0 : h.message_id }, error: g };
      throw new WE("You must provide either an email or phone number.");
      if (dn(c))
      const { data: a, error: c } = await Rn(this.fetch, "POST", `${this.url}/verify`, {
        xform: au
      const f = a.session, h = a.user;
      return f != null && f.access_token && (await this._saveSession(f), await this._notifyAllSubscribers(t.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", f)), { data: { user: h, session: f }, error: null };
      if (dn(o))
      return this.flowType === "pkce" && ([s, a] = await mv(this.storage, this.storageKey)), await Rn(this.fetch, "POST", `${this.url}/sso`, {
        xform: yae
      if (dn(s))
          throw new Nf();
        const { error: o } = await Rn(this.fetch, "GET", `${this.url}/reauthenticate`, {
      if (dn(t))
        const { email: r, type: o, options: s } = t, { error: a } = await Rn(this.fetch, "POST", n, {
        const { phone: r, type: o, options: s } = t, { data: a, error: c } = await Rn(this.fetch, "POST", n, {
      throw new WE("You must provide either an email or phone number and a type");
      if (dn(n))
      const n = await Ih(this.storage, this.storageKey);
      const r = t.expires_at ? t.expires_at * 1e3 - Date.now() < wP : !1;
          const a = await Ih(this.userStorage, this.storageKey + "-user");
          a != null && a.user ? t.user = a.user : t.user = xP();
            get: (f, h, g) => (!a && h === "user" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), a = !0, this.suppressGetSessionWarning = !0), Reflect.get(f, h, g))
      return t ? await Rn(this.fetch, "GET", `${this.url}/user`, {
        xform: zf
        return !(!((r = a.session) === null || r === void 0) && r.access_token) && !this.hasCustomAuthorizationHeader ? { data: { user: null }, error: new Nf() } : await Rn(this.fetch, "GET", `${this.url}/user`, {
          xform: zf
      if (dn(n))
        return Gse(n) && (await this._removeSession(), await Af(this.storage, `${this.storageKey}-code-verifier`)), { data: { user: null }, error: n };
          throw new Nf();
        this.flowType === "pkce" && t.email != null && ([c, f] = await mv(this.storage, this.storageKey));
        const { data: h, error: g } = await Rn(this.fetch, "PUT", `${this.url}/user`, {
          xform: zf
        return a.user = h.user, await this._saveSession(a), await this._notifyAllSubscribers("USER_UPDATED", a), { data: { user: a.user }, error: null };
      if (dn(r))
        throw new Nf();
      const { payload: a } = CP(t.access_token);
      if (dn(n))
          throw new Nf();
      if (dn(n))
      if (!Oa())
        throw new GE("No browser detected.");
        throw new GE(t.error_description || "Error in URL with unspecified error_description", {
            throw new o2("Not a valid PKCE flow url.");
            throw new GE("Not a valid implicit grant flow url.");
          throw new o2("No code detected.");
        const A = new URL(window.location.href);
        return A.searchParams.delete("code"), window.history.replaceState(window.history.state, "", A.toString()), { data: { session: I.session, redirectType: null }, error: null };
      }
      const { provider_token: r, provider_refresh_token: o, access_token: s, refresh_token: a, expires_in: c, expires_at: f, token_type: h } = t;
      if (!s || !c || !a || !h)
        throw new GE("No session defined in URL");
      const g = Math.round(Date.now() / 1e3), v = parseInt(c);
      let w = g + v;
      C * 1e3 <= Tv && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${C}s, should have been closer to ${v}s`);
      const T = w - v;
      const P = {
        expires_in: v,
        token_type: h,
      return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), { data: { session: P, redirectType: t.type }, error: null };
      if (dn(r))
    const n = await Ih(this.storage, `${this.storageKey}-code-verifier`);
        if (c && !(Wse(c) && (c.status === 404 || c.status === 401 || c.status === 403)))
      return t !== "others" && (await this._removeSession(), await Af(this.storage, `${this.storageKey}-code-verifier`)), { error: null };
    const n = eae(), r = {
    this.flowType === "pkce" && ([r, o] = await mv(
      return await Rn(this.fetch, "POST", `${this.url}/recover`, {
      if (dn(s))
      if (dn(n))
        var a, c, f, h, g;
        const { data: v, error: w } = s;
        return await Rn(this.fetch, "GET", C, {
          jwt: (g = (h = v.session) === null || h === void 0 ? void 0 : h.access_token) !== null && g !== void 0 ? g : void 0
      return Oa() && !(!((n = t.options) === null || n === void 0) && n.skipBrowserRedirect) && window.location.assign(r == null ? void 0 : r.url), { data: { provider: t.provider, url: r == null ? void 0 : r.url }, error: null };
      if (dn(r))
        const { options: a, provider: c, token: f, access_token: h, nonce: g } = t, v = await Rn(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
            access_token: h,
          xform: au
        }), { data: w, error: C } = v;
          error: new hv()
        if (dn(o))
        return await Rn(this.fetch, "DELETE", `${this.url}/user/identities/${t.identity_id}`, {
      if (dn(n))
      return await oae(async (o) => (o > 0 && await rae(200 * Math.pow(2, o - 1)), this._debug(n, "refreshing attempt", o), await Rn(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
        xform: au
        return s && SP(s) && // retryable only if the request can be sent before the backoff overflows the tick duration
        Date.now() + a - r < Tv;
      if (this._debug(n, "error", r), dn(r))
    return this._debug("#_handleProviderSignIn()", "provider", t, "options", n, "url", r), Oa() && !n.skipBrowserRedirect && window.location.assign(r), { data: { provider: t, url: r }, error: null };
      const o = await Ih(this.storage, this.storageKey);
        let a = await Ih(this.userStorage, this.storageKey + "-user");
        !this.storage.isServer && Object.is(this.storage, this.userStorage) && !a && (a = { user: o.user }, await _v(this.userStorage, this.storageKey + "-user", a)), o.user = (t = a == null ? void 0 : a.user) !== null && t !== void 0 ? t : xP();
        const a = await Ih(this.storage, this.storageKey + "-user");
        a && (a != null && a.user) ? (o.user = a.user, await Af(this.storage, this.storageKey + "-user"), await _v(this.storage, this.storageKey, o)) : o.user = xP();
      const s = ((n = o.expires_at) !== null && n !== void 0 ? n : 1 / 0) * 1e3 - Date.now() < wP;
      if (this._debug(r, `session has${s ? "" : " not"} expired with margin of ${wP}s`), s) {
          a && (console.error(a), SP(a) || (this._debug(r, "refresh failed with a non-retryable error, removing the session", a), await this._removeSession()));
      throw new Nf();
      this.refreshingDeferred = new o1();
        throw new Nf();
      if (this._debug(o, "error", s), dn(s)) {
        return SP(s) || await this._removeSession(), (n = this.refreshingDeferred) === null || n === void 0 || n.resolve(a), a;
      !r && n.user && await _v(this.userStorage, this.storageKey + "-user", {
      const s = u2(o);
      await _v(this.storage, this.storageKey, s);
      const o = u2(n);
      await _v(this.storage, this.storageKey, o);
    this._debug("#_removeSession()"), await Af(this.storage, this.storageKey), await Af(this.storage, this.storageKey + "-code-verifier"), await Af(this.storage, this.storageKey + "-user"), this.userStorage && await Af(this.userStorage, this.storageKey + "-user"), await this._notifyAllSubscribers("SIGNED_OUT", null);
      t && Oa() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", t);
    const t = setInterval(() => this._autoRefreshTokenTick(), Tv);
              const o = Math.floor((r.expires_at * 1e3 - t) / Tv);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${o} ticks, a tick lasts ${Tv}ms, refresh threshold is ${FM} ticks`), o <= FM && await this._callRefreshToken(r.refresh_token);
      if (t.isAcquireTimeout || t instanceof kU)
    if (this._debug("#_handleVisibilityChange()"), !Oa() || !(window != null && window.addEventListener))
      const [s, a] = await mv(this.storage, this.storageKey), c = new URLSearchParams({
        return s ? { data: null, error: s } : await Rn(this.fetch, "DELETE", `${this.url}/factors/${t.factorId}`, {
      if (dn(n))
        const c = Object.assign({ friendly_name: t.friendlyName, factor_type: t.factorType }, t.factorType === "phone" ? { phone: t.phone } : t.factorType === "totp" ? { issuer: t.issuer } : {}), { data: f, error: h } = await Rn(this.fetch, "POST", `${this.url}/factors`, {
        return h ? { data: null, error: h } : (t.factorType === "totp" && f.type === "totp" && (!((o = f == null ? void 0 : f.totp) === null || o === void 0) && o.qr_code) && (f.totp.qr_code = `data:image/svg+xml;utf-8,${f.totp.qr_code}`), { data: f, error: null });
      if (dn(n))
            webauthn: Object.assign(Object.assign({}, t.webauthn), { credential_response: t.webauthn.type === "create" ? Nae(t.webauthn.credential_response) : $ae(t.webauthn.credential_response) })
          } : { code: t.code }), { data: c, error: f } = await Rn(this.fetch, "POST", `${this.url}/factors/${t.factorId}/verify`, {
        if (dn(n))
          const a = await Rn(this.fetch, "POST", `${this.url}/factors/${t.factorId}/challenge`, {
                data: Object.assign(Object.assign({}, c), { webauthn: Object.assign(Object.assign({}, c.webauthn), { credential_options: Object.assign(Object.assign({}, c.webauthn.credential_options), { publicKey: Dae(c.webauthn.credential_options.publicKey) }) }) }),
                data: Object.assign(Object.assign({}, c), { webauthn: Object.assign(Object.assign({}, c.webauthn), { credential_options: Object.assign(Object.assign({}, c.webauthn.credential_options), { publicKey: Aae(c.webauthn.credential_options.publicKey) }) }) }),
        if (dn(n))
      const { payload: a } = CP(o.access_token);
      ((r = (n = o.user.factors) === null || n === void 0 ? void 0 : n.filter((v) => v.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (f = "aal2");
    if (r = this.jwks.keys.find((c) => c.kid === t), r && this.jwks_cached_at + Vse > o)
    const { data: s, error: a } = await Rn(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
      const { header: o, payload: s, signature: a, raw: { header: c, payload: f } } = CP(r);
      n != null && n.allowExpired || dae(s.exp);
      const h = !o.alg || o.alg.startsWith("HS") || !o.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : await this.fetchJwk(o.kid, n != null && n.keys ? { keys: n.keys } : n == null ? void 0 : n.jwks);
      if (!h) {
      const g = fae(o.alg), v = await crypto.subtle.importKey("jwk", h, g, !0, [
      if (!await crypto.subtle.verify(g, v, a, Jse(`${c}.${f}`)))
        throw new HM("Invalid JWT signature");
      if (dn(r))
XS.nextInstanceID = 0;
const Wae = XS;
class Gae extends Wae {
var qae = function(e, t, n, r) {
        h(r.next(g));
      } catch (v) {
        a(v);
        h(r.throw(g));
      } catch (v) {
        a(v);
    function h(g) {
    h((r = r.apply(e, t || [])).next());
class Kae {
    const c = jse(t);
    const f = `sb-${c.hostname.split(".")[0]}-auth-token`, h = {
      db: Rse,
      realtime: Pse,
      auth: Object.assign(Object.assign({}, kse), { storageKey: f }),
      global: Ose
    }, g = Lse(r ?? {}, h);
      get: (v, w) => {
    })) : this.auth = this._initSupabaseAuthClient((a = g.auth) !== null && a !== void 0 ? a : {}, this.headers, g.global.fetch), this.fetch = Ase(n, this._getAccessToken.bind(this), g.global.fetch), this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, g.realtime)), this.rest = new Uie(new URL("rest/v1", c).href, {
    }), this.storage = new Ese(this.storageUrl.href, this.headers, this.fetch, r == null ? void 0 : r.storage), g.accessToken || this._listenForAuthEvents();
    return new Cie(this.functionsUrl.href, {
    return qae(this, void 0, void 0, function* () {
  _initSupabaseAuthClient({ autoRefreshToken: t, persistSession: n, detectSessionInUrl: r, storage: o, userStorage: s, storageKey: a, flowType: c, lock: f, debug: h }, g, v) {
    return new Gae({
      debug: h,
      fetch: v,
    return new ase(this.realtimeUrl.href, Object.assign(Object.assign({}, t), { params: Object.assign({ apikey: this.supabaseKey }, t == null ? void 0 : t.params) }));
const Yae = (e, t, n) => new Kae(e, t, n);
function Xae() {
Xae() && console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
const Qae = { BASE_URL: "/admin/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, Jae = "https://jvjmmzbibpnlzhzzyncx.supabase.co", Zae = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imp2am1temJpYnBubHpoenp5bmN4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA1MjYyMzksImV4cCI6MjA3NjEwMjIzOX0.JyaY7kJbbZKKBCj_UX6M-t-eKoK9WJibcJjlLZnSvWA", ele = /* @__PURE__ */ new Set(["admin", "administrator", "owner", "superuser"]);
function EC(...e) {
function Mo(e, ...t) {
function ty(e) {
function Od(e) {
  const t = typeof import.meta < "u" ? Qae[e] : void 0, n = typeof process < "u" && (process != null && process.env) ? process.env[e] : void 0, r = Mo(globalThis, "process", "env", e);
  return EC(t, n, r);
}
const ny = Mo(globalThis, "HarmonySheetsSupabase") ?? Mo(globalThis, "harmonySheetsSupabase") ?? Mo(globalThis, "SUPABASE_CONFIG") ?? Mo(globalThis, "env") ?? Mo(globalThis, "__env") ?? {}, tle = EC(
  Mo(globalThis, "SUPABASE_URL"),
  Mo(globalThis, "Supabase", "url"),
  Mo(globalThis, "HarmonySheetsSupabase", "url"),
  Mo(globalThis, "__SUPABASE__", "url"),
  Mo(ny, "SUPABASE_URL"),
  Mo(ny, "supabaseUrl"),
  Od("SUPABASE_URL"),
  Od("VITE_SUPABASE_URL"),
  Od("PUBLIC_SUPABASE_URL"),
  ty("supabase-url"),
  ty("harmony-sheets-supabase-url")
) ?? Jae, nle = EC(
  Mo(globalThis, "SUPABASE_ANON_KEY"),
  Mo(globalThis, "Supabase", "anonKey"),
  Mo(globalThis, "HarmonySheetsSupabase", "anonKey"),
  Mo(globalThis, "__SUPABASE__", "anonKey"),
  Mo(ny, "SUPABASE_ANON_KEY"),
  Mo(ny, "supabaseAnonKey"),
  Od("SUPABASE_ANON_KEY"),
  Od("VITE_SUPABASE_ANON_KEY"),
  Od("PUBLIC_SUPABASE_ANON_KEY"),
  ty("supabase-anon-key"),
  ty("harmony-sheets-supabase-anon-key")
) ?? Zae, DU = EC(
  Mo(globalThis, "SUPABASE_ADMIN_EMAIL"),
  Mo(globalThis, "HarmonySheetsSupabase", "adminEmail"),
  Mo(ny, "SUPABASE_ADMIN_EMAIL"),
  Mo(ny, "adminEmail"),
  Od("SUPABASE_ADMIN_EMAIL"),
  Od("VITE_SUPABASE_ADMIN_EMAIL"),
  Od("PUBLIC_SUPABASE_ADMIN_EMAIL"),
  ty("supabase-admin-email"),
  ty("harmony-sheets-supabase-admin-email")
function fS(e) {
const zh = fS(DU);
function na(e, t) {
function rle(e) {
function VM(e) {
    return e.some(VM);
    return t ? ele.has(t) : !1;
  return typeof e == "object" ? Object.values(e).some(VM) : !1;
function AU() {
  return { url: tle, anonKey: nle };
function ole() {
  return DU ?? null;
function ile() {
  return zh || null;
function YT(e) {
  const t = fS(e.email);
  if (zh && t && t === zh)
  if (zh) {
      na(e, ["user_metadata", "adminEmail"]),
      na(e, ["user_metadata", "admin_email"]),
      na(e, ["user_metadata", "email"]),
      na(e, ["app_metadata", "adminEmail"]),
      na(e, ["app_metadata", "admin_email"])
      if (fS(c) === zh)
      na(e, ["user_metadata", "adminEmails"]),
      na(e, ["user_metadata", "admin_emails"]),
      na(e, ["app_metadata", "adminEmails"]),
      na(e, ["app_metadata", "admin_emails"])
          if (c.some((f) => fS(f) === zh))
        } else if (typeof c == "string" && c.split(/[\s,;]+/).map((h) => fS(h)).filter(Boolean).includes(zh))
    na(e, ["app_metadata", "roles"]),
    na(e, ["user_metadata", "roles"])
  const r = EC(
    na(e, ["app_metadata", "role"]),
    na(e, ["user_metadata", "role"])
    const a = na(e, s);
    if (rle(a) || VM(a))
const { url: sle, anonKey: ale } = AU(), gu = Yae(sle, ale), lle = Tn(/* @__PURE__ */ $.jsx("path", {
}), "Logout"), ule = Tn(/* @__PURE__ */ $.jsx("path", {
async function cle() {
  const { data: e, error: t } = await gu.from("products_with_prices").select("*").order("created_at", { ascending: !1 });
async function dle(e) {
  const { data: t, error: n } = await gu.functions.invoke("create_stripe_product", {
async function fle(e) {
  const { data: t, error: n } = await gu.functions.invoke("update_stripe_price", {
const ple = Tn(/* @__PURE__ */ $.jsx("path", {
}), "TrendingUp"), hle = Tn(/* @__PURE__ */ $.jsx("path", {
function NU({ kpis: e }) {
  const t = za(), n = rn(t.palette.success.main, 0.12), r = rn(t.palette.error.main, 0.12), o = rn(t.palette.primary.main, 0.08);
  return /* @__PURE__ */ $.jsx(VT, { container: !0, spacing: 3, columns: { xs: 1, md: 12 }, children: e.map((s) => {
    const a = s.change >= 0;
    return /* @__PURE__ */ $.jsx(VT, { size: { xs: 12, md: 4 }, children: /* @__PURE__ */ $.jsx(
      uD,
      {
        elevation: 0,
        sx: {
          height: "100%",
          borderRadius: 3,
          border: "1px solid",
          borderColor: rn(t.palette.primary.main, 0.12),
          backgroundColor: o,
          backdropFilter: "blur(6px)"
        },
        children: /* @__PURE__ */ $.jsx(cD, { children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 1, children: [
          /* @__PURE__ */ $.jsx(un, { variant: "overline", color: "text.secondary", children: s.label }),
          /* @__PURE__ */ $.jsx(un, { variant: "h5", fontWeight: 600, children: s.value }),
          /* @__PURE__ */ $.jsxs(
            Vn,
            {
              direction: "row",
              spacing: 1.5,
              alignItems: "center",
              sx: {
                px: 1.5,
                py: 0.75,
                borderRadius: 2,
                bgcolor: a ? n : r
              },
              children: [
                a ? /* @__PURE__ */ $.jsx(ple, { fontSize: "small", color: "success" }) : /* @__PURE__ */ $.jsx(hle, { fontSize: "small", color: "error" }),
                /* @__PURE__ */ $.jsxs(un, { variant: "body2", color: a ? "success.main" : "error.main", children: [
                  a ? "+" : "",
                  s.change,
                  "% vs last month"
                ] })
              ]
            }
          )
        ] }) })
      }
    ) }, s.label);
function TC(e) {
const Hf = (e, t, n) => Math.max(Math.min(e, n), t);
function pS(e) {
  return Hf(TC(e * 2.55), 0, 255);
function Kf(e) {
  return Hf(TC(e * 255), 0, 255);
function xd(e) {
  return Hf(TC(e / 2.55) / 100, 0, 1);
function g2(e) {
  return Hf(TC(e * 100), 0, 100);
const fl = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, UM = [..."0123456789ABCDEF"], mle = (e) => UM[e & 15], gle = (e) => UM[(e & 240) >> 4] + UM[e & 15], qE = (e) => (e & 240) >> 4 === (e & 15), vle = (e) => qE(e.r) && qE(e.g) && qE(e.b) && qE(e.a);
function yle(e) {
    r: 255 & fl[e[1]] * 17,
    g: 255 & fl[e[2]] * 17,
    b: 255 & fl[e[3]] * 17,
    a: t === 5 ? fl[e[4]] * 17 : 255
    r: fl[e[1]] << 4 | fl[e[2]],
    g: fl[e[3]] << 4 | fl[e[4]],
    b: fl[e[5]] << 4 | fl[e[6]],
    a: t === 9 ? fl[e[7]] << 4 | fl[e[8]] : 255
const ble = (e, t) => e < 255 ? t(e) : "";
function wle(e) {
  var t = vle(e) ? mle : gle;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + ble(e.a, t) : void 0;
const Sle = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function $U(e, t, n) {
function Cle(e, t, n) {
function xle(e, t, n) {
  const r = $U(e, 1, 0.5);
function Ele(e, t, n, r, o) {
function xD(e) {
  let f, h, g;
  return s !== a && (g = s - a, h = c > 0.5 ? g / (2 - s - a) : g / (s + a), f = Ele(n, r, o, g, s), f = f * 60 + 0.5), [f | 0, h || 0, c];
function ED(e, t, n, r) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, r)).map(Kf);
function TD(e, t, n) {
  return ED($U, e, t, n);
function Tle(e, t, n) {
  return ED(xle, e, t, n);
function _le(e, t, n) {
  return ED(Cle, e, t, n);
function LU(e) {
function Ole(e) {
  const t = Sle.exec(e);
  t[5] !== r && (n = t[6] ? pS(+t[5]) : Kf(+t[5]));
  const o = LU(+t[2]), s = +t[3] / 100, a = +t[4] / 100;
  return t[1] === "hwb" ? r = Tle(o, s, a) : t[1] === "hsv" ? r = _le(o, s, a) : r = TD(o, s, a), {
function Rle(e, t) {
  var n = xD(e);
  n[0] = LU(n[0] + t), n = TD(n), e.r = n[0], e.g = n[1], e.b = n[2];
function kle(e) {
  const t = xD(e), n = t[0], r = g2(t[1]), o = g2(t[2]);
  return e.a < 255 ? `hsla(${n}, ${r}%, ${o}%, ${xd(e.a)})` : `hsl(${n}, ${r}%, ${o}%)`;
const v2 = {
}, y2 = {
function Ple() {
  const e = {}, t = Object.keys(y2), n = Object.keys(v2);
      s = n[o], c = c.replace(s, v2[s]);
    s = parseInt(y2[a], 16), e[c] = [s >> 16 & 255, s >> 8 & 255, s & 255];
let KE;
function Mle(e) {
  KE || (KE = Ple(), KE.transparent = [0, 0, 0, 0]);
  const t = KE[e.toLowerCase()];
const Ile = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function Dle(e) {
  const t = Ile.exec(e);
      n = t[8] ? pS(a) : Hf(a * 255, 0, 255);
    return r = +t[1], o = +t[3], s = +t[5], r = 255 & (t[2] ? pS(r) : Hf(r, 0, 255)), o = 255 & (t[4] ? pS(o) : Hf(o, 0, 255)), s = 255 & (t[6] ? pS(s) : Hf(s, 0, 255)), {
function Ale(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${xd(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
const TP = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, bv = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function Nle(e, t, n) {
  const r = bv(xd(e.r)), o = bv(xd(e.g)), s = bv(xd(e.b));
    r: Kf(TP(r + n * (bv(xd(t.r)) - r))),
    g: Kf(TP(o + n * (bv(xd(t.g)) - o))),
    b: Kf(TP(s + n * (bv(xd(t.b)) - s))),
function YE(e, t, n) {
    let r = xD(e);
    r[t] = Math.max(0, Math.min(r[t] + r[t] * n, t === 0 ? 360 : 1)), r = TD(r), e.r = r[0], e.g = r[1], e.b = r[2];
function jU(e, t) {
function b2(e) {
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = Kf(e[3]))) : (t = jU(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = Kf(t.a)), t;
function $le(e) {
  return e.charAt(0) === "r" ? Dle(e) : Ole(e);
class QS {
    if (t instanceof QS)
    n === "object" ? r = b2(t) : n === "string" && (r = yle(t) || Mle(t) || $le(t)), this._rgb = r, this._valid = !!r;
    var t = jU(this._rgb);
    return t && (t.a = xd(t.a)), t;
    this._rgb = b2(t);
    return this._valid ? Ale(this._rgb) : void 0;
    return this._valid ? wle(this._rgb) : void 0;
    return this._valid ? kle(this._rgb) : void 0;
      const a = n === s ? 0.5 : n, c = 2 * a - 1, f = r.a - o.a, h = ((c * f === -1 ? c : (c + f) / (1 + c * f)) + 1) / 2;
      s = 1 - h, r.r = 255 & h * r.r + s * o.r + 0.5, r.g = 255 & h * r.g + s * o.g + 0.5, r.b = 255 & h * r.b + s * o.b + 0.5, r.a = a * r.a + (1 - a) * o.a, this.rgb = r;
    return t && (this._rgb = Nle(this._rgb, t._rgb, n)), this;
    return new QS(this.rgb);
    return this._rgb.a = Kf(t), this;
    const t = this._rgb, n = TC(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return YE(this._rgb, 2, t), this;
    return YE(this._rgb, 2, -t), this;
    return YE(this._rgb, 1, t), this;
    return YE(this._rgb, 1, -t), this;
    return Rle(this._rgb, t), this;
function yd() {
const Lle = /* @__PURE__ */ (() => {
function ho(e) {
function Oi(e) {
function sr(e) {
function ys(e) {
function sc(e, t) {
  return ys(e) ? e : t;
function Zn(e, t) {
const jle = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function to(e, t, n) {
function Mr(e, t, n, r) {
  if (Oi(e))
  else if (sr(e))
function XT(e, t) {
function QT(e) {
  if (Oi(e))
    return e.map(QT);
  if (sr(e)) {
      t[n[o]] = QT(e[n[o]]);
function FU(e) {
function Fle(e, t, n, r) {
  if (!FU(e))
  sr(o) && sr(s) ? JS(o, s, r) : t[e] = QT(s);
function JS(e, t, n) {
  const r = Oi(t) ? t : [
  if (!sr(e))
  const s = n.merger || Fle;
    if (a = r[c], !sr(a))
    for (let h = 0, g = f.length; h < g; ++h)
      s(f[h], e, a, n);
function OS(e, t) {
  return JS(e, t, {
    merger: zle
function zle(e, t, n) {
  if (!FU(e))
  sr(r) && sr(o) ? OS(r, o) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = QT(o));
const w2 = {
function Ble(e) {
function Hle(e) {
  const t = Ble(e);
function JT(e, t) {
  return (w2[t] || (w2[t] = Hle(t)))(e);
function _D(e) {
const ZT = (e) => typeof e < "u", np = (e) => typeof e == "function", S2 = (e, t) => {
function Vle(e) {
const vs = Math.PI, vu = 2 * vs, Ule = vu + vs, e_ = Number.POSITIVE_INFINITY, Wle = vs / 180, mu = vs / 2, Dh = vs / 4, C2 = vs * 2 / 3, zU = Math.log10, ry = Math.sign;
function RS(e, t, n) {
function x2(e) {
  e = RS(e, t, e / 1e3) ? t : e;
  const n = Math.pow(10, Math.floor(zU(e))), r = e / n;
function Gle(e) {
function qle(e) {
function t_(e) {
  return !qle(e) && !isNaN(parseFloat(e)) && isFinite(e);
function Kle(e, t) {
function Yle(e, t, n) {
function Jh(e) {
  return e * (vs / 180);
function Xle(e) {
  return e * (180 / vs);
function E2(e) {
  if (!ys(e))
function Qle(e, t) {
  return s < -0.5 * vs && (s += vu), {
function WM(e, t) {
function Jle(e, t) {
  return (e - t + Ule) % vu - vs;
function dc(e) {
  return (e % vu + vu) % vu;
function BU(e, t, n, r) {
  const o = dc(e), s = dc(t), a = dc(n), c = dc(s - o), f = dc(a - o), h = dc(o - s), g = dc(o - a);
  return o === s || o === a || r && s === a || c > f && h < g;
function mc(e, t, n) {
function Zle(e) {
  return mc(e, -32768, 32767);
function Pv(e, t, n, r = 1e-6) {
function OD(e, t, n) {
const GM = (e, t, n, r) => OD(e, n, r ? (o) => {
} : (o) => e[o][t] < n), eue = (e, t, n) => OD(e, n, (r) => e[r][t] >= n);
function tue(e, t, n) {
const HU = [
function nue(e, t) {
  }), HU.forEach((n) => {
    const r = "_onData" + _D(n), o = e[n];
function T2(e, t) {
  o !== -1 && r.splice(o, 1), !(r.length > 0) && (HU.forEach((s) => {
function rue(e) {
const VU = function() {
function UU(e, t) {
    n = o, r || (r = !0, VU.call(window, () => {
function oue(e, t) {
const WU = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", Ra = (e, t, n) => e === "start" ? t : e === "end" ? n : (t + n) / 2, iue = (e, t, n, r) => e === (r ? "left" : "right") ? n : e === "center" ? (t + n) / 2 : t, XE = (e) => e === 0 || e === 1, _2 = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * vu / n)), O2 = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * vu / n) + 1, kS = {
  easeInSine: (e) => -Math.cos(e * mu) + 1,
  easeOutSine: (e) => Math.sin(e * mu),
  easeInOutSine: (e) => -0.5 * (Math.cos(vs * e) - 1),
  easeInOutExpo: (e) => XE(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInElastic: (e) => XE(e) ? e : _2(e, 0.075, 0.3),
  easeOutElastic: (e) => XE(e) ? e : O2(e, 0.075, 0.3),
    return XE(e) ? e : e < 0.5 ? 0.5 * _2(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * O2(e * 2 - 1, 0.1125, 0.45);
  easeInBounce: (e) => 1 - kS.easeOutBounce(1 - e),
  easeInOutBounce: (e) => e < 0.5 ? kS.easeInBounce(e * 2) * 0.5 : kS.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
function RD(e) {
function R2(e) {
  return RD(e) ? e : new QS(e);
function _P(e) {
  return RD(e) ? e : new QS(e).saturate(0.5).darken(0.1).hexString();
const sue = [
], aue = [
function lue(e) {
      properties: aue
      properties: sue
function uue(e) {
const k2 = /* @__PURE__ */ new Map();
function cue(e, t) {
  let r = k2.get(n);
  return r || (r = new Intl.NumberFormat(e, t), k2.set(n, r)), r;
function GU(e, t, n) {
  return cue(t, n).format(e);
const due = {
    return Oi(e) ? e : "" + e;
      const h = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (h < 1e-4 || h > 1e15) && (o = "scientific"), s = fue(e, n);
    const a = zU(Math.abs(s)), c = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), f = {
    return Object.assign(f, this.options.ticks.format), GU(e, r, f);
function fue(e, t) {
var qU = {
  formatters: due
function pue(e) {
      callback: qU.formatters.values,
const fm = /* @__PURE__ */ Object.create(null), qM = /* @__PURE__ */ Object.create(null);
function PS(e, t) {
function OP(e, t, n) {
  return typeof t == "string" ? JS(PS(e, t), n) : JS(PS(e, ""), t);
class hue {
    }, this.hover = {}, this.hoverBackgroundColor = (r, o) => _P(o.backgroundColor), this.hoverBorderColor = (r, o) => _P(o.borderColor), this.hoverColor = (r, o) => _P(o.color), this.indexAxis = "x", this.interaction = {
    return OP(this, t, n);
    return PS(this, t);
    return OP(qM, t, n);
    return OP(fm, t, n);
    const s = PS(this, t), a = PS(this, r), c = "_" + n;
          const f = this[c], h = a[o];
          return sr(f) ? Object.assign({}, h, f) : Zn(f, h);
var Fo = /* @__PURE__ */ new hue({
  lue,
  uue,
  pue
function mue(e) {
  return !e || ho(e.size) || ho(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
function P2(e, t, n, r, o) {
function Ah(e, t, n) {
function M2(e, t) {
function KM(e, t, n, r) {
  KU(e, t, n, r, null);
function KU(e, t, n, r, o) {
  let s, a, c, f, h, g, v, w;
  let O = (T || 0) * Wle;
        o ? e.ellipse(n, r, o / 2, E, 0, 0, vu) : e.arc(n, r, E, 0, vu), e.closePath();
        g = o ? o / 2 : E, e.moveTo(n + Math.sin(O) * g, r - Math.cos(O) * E), O += C2, e.lineTo(n + Math.sin(O) * g, r - Math.cos(O) * E), O += C2, e.lineTo(n + Math.sin(O) * g, r - Math.cos(O) * E), e.closePath();
        h = E * 0.516, f = E - h, a = Math.cos(O + Dh) * f, v = Math.cos(O + Dh) * (o ? o / 2 - h : f), c = Math.sin(O + Dh) * f, w = Math.sin(O + Dh) * (o ? o / 2 - h : f), e.arc(n - v, r - c, h, O - vs, O - mu), e.arc(n + w, r - a, h, O - mu, O), e.arc(n + v, r + c, h, O, O + mu), e.arc(n - w, r + a, h, O + mu, O + vs), e.closePath();
        O += Dh;
        v = Math.cos(O) * (o ? o / 2 : E), a = Math.cos(O) * E, c = Math.sin(O) * E, w = Math.sin(O) * (o ? o / 2 : E), e.moveTo(n - v, r - c), e.lineTo(n + w, r - a), e.lineTo(n + v, r + c), e.lineTo(n - w, r + a), e.closePath();
        O += Dh;
        v = Math.cos(O) * (o ? o / 2 : E), a = Math.cos(O) * E, c = Math.sin(O) * E, w = Math.sin(O) * (o ? o / 2 : E), e.moveTo(n - v, r - c), e.lineTo(n + v, r + c), e.moveTo(n + w, r - a), e.lineTo(n - w, r + a);
        v = Math.cos(O) * (o ? o / 2 : E), a = Math.cos(O) * E, c = Math.sin(O) * E, w = Math.sin(O) * (o ? o / 2 : E), e.moveTo(n - v, r - c), e.lineTo(n + v, r + c), e.moveTo(n + w, r - a), e.lineTo(n - w, r + a), O += Dh, v = Math.cos(O) * (o ? o / 2 : E), a = Math.cos(O) * E, c = Math.sin(O) * E, w = Math.sin(O) * (o ? o / 2 : E), e.moveTo(n - v, r - c), e.lineTo(n + v, r + c), e.moveTo(n + w, r - a), e.lineTo(n - w, r + a);
function ZS(e, t, n) {
function i1(e, t) {
function s1(e) {
function gue(e, t, n, r, o) {
function vue(e, t, n, r) {
function yue(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), ho(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
function bue(e, t, n, r, o) {
    const s = e.measureText(r), a = t - s.actualBoundingBoxLeft, c = t + s.actualBoundingBoxRight, f = n - s.actualBoundingBoxAscent, h = n + s.actualBoundingBoxDescent, g = o.strikethrough ? (f + h) / 2 : h;
function wue(e, t) {
function n_(e, t, n, r, o, s = {}) {
  const a = Oi(t) ? t : [
  let f, h;
  for (e.save(), e.font = o.string, yue(e, s), f = 0; f < a.length; ++f)
    h = a[f], s.backdrop && wue(e, s.backdrop), c && (s.strokeColor && (e.strokeStyle = s.strokeColor), ho(s.strokeWidth) || (e.lineWidth = s.strokeWidth), e.strokeText(h, n, r, s.maxWidth)), e.fillText(h, n, r, s.maxWidth), bue(e, n, r, h, s), r += Number(o.lineHeight);
function YM(e, t) {
  e.arc(n + a.topLeft, r + a.topLeft, a.topLeft, 1.5 * vs, vs, !0), e.lineTo(n, r + s - a.bottomLeft), e.arc(n + a.bottomLeft, r + s - a.bottomLeft, a.bottomLeft, vs, mu, !0), e.lineTo(n + o - a.bottomRight, r + s), e.arc(n + o - a.bottomRight, r + s - a.bottomRight, a.bottomRight, mu, 0, !0), e.lineTo(n + o, r + a.topRight), e.arc(n + o - a.topRight, r + a.topRight, a.topRight, 0, -mu, !0), e.lineTo(n + a.topLeft, r);
const Sue = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, Cue = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function xue(e, t) {
  const n = ("" + e).match(Sue);
const Eue = (e) => +e || 0;
function YU(e, t) {
  const n = {}, r = sr(t), o = r ? Object.keys(t) : t, s = sr(e) ? r ? (a) => Zn(e[a], e[t[a]]) : (a) => e[a] : () => e;
    n[a] = Eue(s(a));
function Tue(e) {
  return YU(e, {
function MS(e) {
  return YU(e, [
function Su(e) {
  const t = Tue(e);
function aa(e, t) {
  e = e || {}, t = t || Fo.font;
  let n = Zn(e.size, t.size);
  let r = Zn(e.style, t.style);
  r && !("" + r).match(Cue) && (console.warn('Invalid font style specified: "' + r + '"'), r = void 0);
    family: Zn(e.family, t.family),
    lineHeight: xue(Zn(e.lineHeight, t.lineHeight), n),
    weight: Zn(e.weight, t.weight),
  return o.string = mue(o), o;
function QE(e, t, n, r) {
function _ue(e, t, n) {
  const { min: r, max: o } = e, s = jle(t, (o - r) / 2), a = (c, f) => n && c === 0 ? 0 : c + f;
function wm(e, t) {
function kD(e, t = [
  typeof r > "u" && (r = ZU("_fallback", e));
    override: (c) => kD([
      return QU(c, f, () => Aue(f, t, e, c));
      return D2(c).includes(f);
      return D2(c);
    set(c, f, h) {
      return c[f] = g[f] = h, delete c._keys, !0;
function oy(e, t, n, r) {
    _descriptors: XU(e, r),
    setContext: (s) => oy(e, s, n, r),
    override: (s) => oy(e.override(s), t, n, r)
      return QU(s, a, () => Rue(s, a, c));
function XU(e, t = {
    isScriptable: np(n) ? n : () => n,
    isIndexable: np(r) ? r : () => r
const Oue = (e, t) => e ? e + _D(t) : t, PD = (e, t) => sr(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function QU(e, t, n) {
function Rue(e, t, n) {
  return np(c) && a.isScriptable(t) && (c = kue(t, c, e, n)), Oi(c) && c.length && (c = Pue(t, c, e, a.isIndexable)), PD(t, c) && (c = oy(c, o, s && s[t], a)), c;
function kue(e, t, n, r) {
  return c.delete(e), PD(e, f) && (f = MD(o._scopes, o, e, f)), f;
function Pue(e, t, n, r) {
  if (sr(t[0])) {
    const f = t, h = o._scopes.filter((g) => g !== f);
      const v = MD(h, o, e, g);
      t.push(oy(v, s, a && a[e], c));
function JU(e, t, n) {
  return np(e) ? e(t, n) : e;
const Mue = (e, t) => e === !0 ? t : typeof e == "string" ? JT(t, e) : void 0;
function Iue(e, t, n, r, o) {
    const a = Mue(n, s);
      const c = JU(a._fallback, n, o);
function MD(e, t, n, r) {
  const o = t._rootScopes, s = JU(t._fallback, n, r), a = [
  let f = I2(c, a, n, s || n, r);
  return f === null || typeof s < "u" && s !== n && (f = I2(c, a, s, f, r), f === null) ? !1 : kD(Array.from(c), [
  ], o, s, () => Due(t, n, r));
function I2(e, t, n, r, o) {
    n = Iue(e, t, n, r, o);
function Due(e, t, n) {
  return Oi(o) && sr(n) ? n : o || {};
function Aue(e, t, n, r) {
    if (o = ZU(Oue(s, e), n), typeof o < "u")
      return PD(e, o) ? MD(n, r, e, o) : o;
function ZU(e, t) {
function D2(e) {
  return t || (t = e._keys = Nue(e._scopes)), t;
function Nue(e) {
const $ue = Number.EPSILON || 1e-14, iy = (e, t) => t < e.length && !e[t].skip && e[t], e5 = (e) => e === "x" ? "y" : "x";
function Lue(e, t, n, r) {
  const o = e.skip ? t : e, s = t, a = n.skip ? t : n, c = WM(s, o), f = WM(a, s);
  let h = c / (c + f), g = f / (c + f);
  h = isNaN(h) ? 0 : h, g = isNaN(g) ? 0 : g;
  const v = r * h, w = r * g;
      x: s.x - v * (a.x - o.x),
      y: s.y - v * (a.y - o.y)
function jue(e, t, n) {
  let o, s, a, c, f, h = iy(e, 0);
    if (f = h, h = iy(e, g + 1), !(!f || !h)) {
      if (RS(t[g], 0, $ue)) {
function Fue(e, t, n = "x") {
  const r = e5(n), o = e.length;
  let s, a, c, f = iy(e, 0);
  for (let h = 0; h < o; ++h) {
    if (a = c, c = f, f = iy(e, h + 1), !c)
    const g = c[n], v = c[r];
    a && (s = (g - a[n]) / 3, c[`cp1${n}`] = g - s, c[`cp1${r}`] = v - s * t[h]), f && (s = (f[n] - g) / 3, c[`cp2${n}`] = g + s, c[`cp2${r}`] = v + s * t[h]);
function zue(e, t = "x") {
  const n = e5(t), r = e.length, o = Array(r).fill(0), s = Array(r);
  let a, c, f, h = iy(e, 0);
    if (c = f, f = h, h = iy(e, a + 1), !!f) {
      if (h) {
        const g = h[t] - f[t];
        o[a] = g !== 0 ? (h[n] - f[n]) / g : 0;
      s[a] = c ? h ? ry(o[a - 1]) !== ry(o[a]) ? 0 : (o[a - 1] + o[a]) / 2 : o[a - 1] : o[a];
  jue(e, o, s), Fue(e, s, t);
function JE(e, t, n) {
function Bue(e, t) {
  let n, r, o, s, a, c = ZS(e[0], t);
    a = s, s = c, c = n < r - 1 && ZS(e[n + 1], t), s && (o = e[n], a && (o.cp1x = JE(o.cp1x, t.left, t.right), o.cp1y = JE(o.cp1y, t.top, t.bottom)), c && (o.cp2x = JE(o.cp2x, t.left, t.right), o.cp2y = JE(o.cp2y, t.top, t.bottom)));
function Hue(e, t, n, r, o) {
  if (t.spanGaps && (e = e.filter((h) => !h.skip)), t.cubicInterpolationMode === "monotone")
    zue(e, o);
    let h = r ? e[e.length - 1] : e[0];
      c = e[s], f = Lue(h, c, e[Math.min(s + 1, a - (r ? 0 : 1)) % a], t.tension), c.cp1x = f.previous.x, c.cp1y = f.previous.y, c.cp2x = f.next.x, c.cp2y = f.next.y, h = c;
  t.capBezierPoints && Bue(e, n);
function ID() {
function DD(e) {
function r_(e, t, n) {
const a1 = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function Vue(e, t) {
  return a1(e).getPropertyValue(t);
const Uue = [
function am(e, t, n) {
    const s = Uue[o];
const Wue = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot);
function Gue(e, t) {
  if (Wue(o, s, e.target))
    const h = t.getBoundingClientRect();
    c = r.clientX - h.left, f = r.clientY - h.top, a = !0;
function Bh(e, t) {
  const { canvas: n, currentDevicePixelRatio: r } = t, o = a1(n), s = o.boxSizing === "border-box", a = am(o, "padding"), c = am(o, "border", "width"), { x: f, y: h, box: g } = Gue(e, n), v = a.left + (g && c.left), w = a.top + (g && c.top);
    x: Math.round((f - v) / C * n.width / r),
    y: Math.round((h - w) / T * n.height / r)
function que(e, t, n) {
    const s = e && DD(e);
      const a = s.getBoundingClientRect(), c = a1(s), f = am(c, "border", "width"), h = am(c, "padding");
      t = a.width - h.width - f.width, n = a.height - h.height - f.height, r = r_(c.maxWidth, s, "clientWidth"), o = r_(c.maxHeight, s, "clientHeight");
    maxWidth: r || e_,
    maxHeight: o || e_
const Vf = (e) => Math.round(e * 10) / 10;
function Kue(e, t, n, r) {
  const o = a1(e), s = am(o, "margin"), a = r_(o.maxWidth, e, "clientWidth") || e_, c = r_(o.maxHeight, e, "clientHeight") || e_, f = que(e, t, n);
  let { width: h, height: g } = f;
    const w = am(o, "border", "width"), C = am(o, "padding");
    h -= C.width + w.width, g -= C.height + w.height;
  return h = Math.max(0, h - s.width), g = Math.max(0, r ? h / r : g - s.height), h = Vf(Math.min(h, a, f.maxWidth)), g = Vf(Math.min(g, c, f.maxHeight)), h && !g && (g = Vf(h / 2)), (t !== void 0 || n !== void 0) && r && f.height && g > f.height && (g = f.height, h = Vf(Math.floor(g * r))), {
    width: h,
function A2(e, t, n) {
  const r = t || 1, o = Vf(e.height * r), s = Vf(e.width * r);
  e.height = Vf(e.height), e.width = Vf(e.width);
const Yue = function() {
    ID() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
function N2(e, t) {
  const n = Vue(e, t), r = n && n.match(/^(\d+)(\.\d+)?px$/);
function Hh(e, t, n, r) {
function Xue(e, t, n, r) {
function Que(e, t, n, r) {
  }, a = Hh(e, o, n), c = Hh(o, s, n), f = Hh(s, t, n), h = Hh(a, c, n), g = Hh(c, f, n);
  return Hh(h, g, n);
const Jue = function(e, t) {
}, Zue = function() {
function zv(e, t, n) {
  return e ? Jue(t, n) : Zue();
function t5(e, t) {
function n5(e, t) {
function r5(e) {
    between: BU,
    compare: Jle,
    normalize: dc
    between: Pv,
function $2({ start: e, end: t, count: n, loop: r, style: o }) {
function ece(e, t, n) {
  const { property: r, start: o, end: s } = n, { between: a, normalize: c } = r5(r), f = t.length;
  let { start: h, end: g, loop: v } = e, w, C;
  if (v) {
    for (h += f, g += f, w = 0, C = f; w < C && a(c(t[h % f][r]), o, s); ++w)
      h--, g--;
    h %= f, g %= f;
  return g < h && (g += f), {
    start: h,
    loop: v,
function o5(e, t, n) {
  const { property: r, start: o, end: s } = n, a = t.length, { compare: c, between: f, normalize: h } = r5(r), { start: g, end: v, loop: w, style: C } = ece(e, t, n), T = [];
  let E = !1, O = null, P, I, M;
  const A = () => f(o, M, P) && c(o, M) !== 0, k = () => c(s, P) === 0 || f(s, M, P), j = () => E || A(), B = () => !E || k();
  for (let H = g, F = g; H <= v; ++H)
    I = t[H % a], !I.skip && (P = h(I[r]), P !== M && (E = f(P, o, s), O === null && j() && (O = c(P, o) === 0 ? H : F), O !== null && B() && (T.push($2({
      end: H,
    })), O = null), F = H, M = P));
  return O !== null && T.push($2({
    end: v,
function i5(e, t) {
    const s = o5(r[o], e.points, t);
function tce(e, t, n, r) {
function nce(e, t, n, r) {
    const h = e[f % o];
    h.skip || h.stop ? c.skip || (r = !1, s.push({
    }), t = a = h.stop ? f : null) : (a = f, c.skip && (t = f)), c = h;
function rce(e, t) {
  const s = !!e._loop, { start: a, end: c } = tce(n, o, s, r);
    return L2(e, [
  const f = c < a ? c + o : c, h = !!e._fullLoop && a === 0 && c === o - 1;
  return L2(e, nce(n, a, f, h), n, t);
function L2(e, t, n, r) {
  return !r || !r.setContext || !n ? t : oce(e, t, n, r);
function oce(e, t, n, r) {
  const o = e._chart.getContext(), s = j2(e.options), { _datasetIndex: a, options: { spanGaps: c } } = e, f = n.length, h = [];
  let g = s, v = t[0].start, w = v;
  function C(T, E, O, P) {
      T % f !== E % f && (h.push({
        style: P
      }), g = P, v = E % f);
    v = c ? v : T.start;
    let E = n[v % f], O;
    for (w = v + 1; w <= T.end; w++) {
      const P = n[w % f];
      O = j2(r.setContext(wm(o, {
        p1: P,
      }))), ice(O, g) && C(v, w - 1, T.loop, g), E = P, g = O;
    v < w - 1 && C(v, w - 1, T.loop, g);
  return h;
function j2(e) {
function ice(e, t) {
    return RD(s) ? (n.includes(s) || n.push(s), n.indexOf(s)) : s;
function ZE(e, t, n) {
function sce(e, t) {
    left: ZE(n, t, "left"),
    right: ZE(n, t, "right"),
    top: ZE(r, t, "top"),
    bottom: ZE(r, t, "bottom")
function s5(e, t) {
  const r = sce(t, e.chartArea);
class ace {
    this._request || (this._running = !0, this._request = VU.call(window, () => {
var bd = /* @__PURE__ */ new ace();
const F2 = "transparent", lce = {
    const r = R2(e || F2), o = r.valid && R2(t || F2);
class uce {
    o = QE([
    const a = QE([
    this._active = !0, this._fn = t.fn || lce[t.type || typeof a], this._easing = kS[t.easing] || kS.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = n, this._prop = r, this._from = a, this._to = o, this._promises = void 0;
      this._start = r, this._duration = Math.floor(Math.max(a, t.duration)), this._total += s, this._loop = !!t.loop, this._to = QE([
      ]), this._from = QE([
class a5 {
    if (!sr(t))
    const n = Object.keys(Fo.animation), r = this._properties;
      if (!sr(s))
      (Oi(s.properties) && s.properties || [
    const r = n.options, o = dce(t, r);
    return r.$shared && cce(t.options.$animations, r).then(() => {
      const h = a[f];
      if (h.charAt(0) === "$")
      if (h === "options") {
      const g = n[h];
      let v = s[h];
      const w = r.get(h);
      if (v)
        if (w && v.active()) {
          v.update(w, g, c);
          v.cancel();
        t[h] = g;
      s[h] = v = new uce(w, t, h, g), o.push(v);
      return bd.add(this._chart, r), !0;
function cce(e, t) {
function dce(e, t) {
function z2(e, t) {
function fce(e, t, n) {
  const r = z2(e, n), o = z2(t, n);
function pce(e) {
  return sr(e) ? (t = e.top, n = e.right, r = e.bottom, o = e.left) : t = n = r = o = e, {
function l5(e, t) {
function B2(e, t, n, r = {}) {
  let a, c, f, h;
    h = e.values[f], ys(h) && (s || t === 0 || ry(t) === ry(h)) && (t += h);
function hce(e, t) {
  let f, h, g;
  for (f = 0, h = a.length; f < h; ++f)
function RP(e, t) {
function mce(e, t, n) {
function gce(e) {
function vce(e, t, n) {
function H2(e, t, n, r) {
function V2(e, t) {
  const { chart: n, _cachedMeta: r } = e, o = n._stacks || (n._stacks = {}), { iScale: s, vScale: a, index: c } = r, f = s.axis, h = a.axis, g = mce(s, a, r), v = t.length;
  for (let C = 0; C < v; ++C) {
    const T = t[C], { [f]: E, [h]: O } = T, P = T._stacks || (T._stacks = {});
    w = P[h] = vce(o, g, E), w[c] = O, w._top = H2(w, a, !0, r.type), w._bottom = H2(w, a, !1, r.type);
function kP(e, t) {
function yce(e, t) {
  return wm(e, {
function bce(e, t, n) {
  return wm(e, {
function Yw(e, t) {
const PP = (e) => e === "reset" || e === "none", U2 = (e, t) => t ? e : Object.assign({}, e), wce = (e, t, n) => e && !t.hidden && t._stacked && {
  keys: l5(n, !0),
class bT {
    this.configure(), this.linkScales(), t._stacked = RP(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    this.index !== t && Yw(this._cachedMeta), this.index = t;
    const t = this.chart, n = this._cachedMeta, r = this.getDataset(), o = (v, w, C, T) => v === "x" ? w : v === "r" ? T : C, s = n.xAxisID = Zn(r.xAxisID, kP(t, "x")), a = n.yAxisID = Zn(r.yAxisID, kP(t, "y")), c = n.rAxisID = Zn(r.rAxisID, kP(t, "r")), f = n.indexAxis, h = n.iAxisID = o(f, s, a, c), g = n.vAxisID = o(f, a, s, c);
    n.xScale = this.getScaleForId(s), n.yScale = this.getScaleForId(a), n.rScale = this.getScaleForId(c), n.iScale = this.getScaleForId(h), n.vScale = this.getScaleForId(g);
    this._data && T2(this._data, this), t._stacked && Yw(t);
    if (sr(n)) {
      this._data = hce(n, o);
        T2(r, this);
        Yw(o), o._parsed = [];
      n && Object.isExtensible(n) && nue(n, this), this._syncList = [], this._data = n;
    n._stacked = RP(n.vScale, n), n.stack !== r.stack && (o = !0, Yw(n), n.stack = r.stack), this._resyncElements(t), (o || s !== n._stacked) && (V2(this, n._parsed), n._stacked = RP(n.vScale, n));
    let f = t === 0 && n === o.length ? !0 : r._sorted, h = t > 0 && r._parsed[t - 1], g, v, w;
      Oi(o[t]) ? w = this.parseArrayData(r, o, t, n) : sr(o[t]) ? w = this.parseObjectData(r, o, t, n) : w = this.parsePrimitiveData(r, o, t, n);
      const C = () => v[c] === null || h && v[c] < h[c];
        r._parsed[g + t] = v = w[g], f && (C() && (f = !1), h = v);
    a && V2(this, w);
    const { iScale: s, vScale: a } = t, c = s.axis, f = a.axis, h = s.getLabels(), g = s === a, v = new Array(o);
      T = w + r, v[w] = {
        [c]: g || s.parse(h[T], T),
    return v;
    let f, h, g, v;
    for (f = 0, h = o; f < h; ++f)
      g = f + r, v = n[g], c[f] = {
        x: s.parse(v[0], g),
        y: a.parse(v[1], g)
    const { xScale: s, yScale: a } = t, { xAxisKey: c = "x", yAxisKey: f = "y" } = this._parsing, h = new Array(o);
    let g, v, w, C;
    for (g = 0, v = o; g < v; ++g)
      w = g + r, C = n[w], h[g] = {
        x: s.parse(JT(C, c), w),
        y: a.parse(JT(C, f), w)
    return h;
      keys: l5(o, !0),
    return B2(c, a, s.index, {
    o && c && (o.values = c, a = B2(o, s, this._cachedMeta.index)), t.min = Math.min(t.min, a), t.max = Math.max(t.max, a);
    const r = this._cachedMeta, o = r._parsed, s = r._sorted && t === r.iScale, a = o.length, c = this._getOtherScale(t), f = wce(n, r, this.chart), h = {
    }, { min: g, max: v } = gce(c);
      return !ys(C[t.axis]) || g > E || v < E;
    for (w = 0; w < a && !(!T() && (this.updateRangeFromParsed(h, t, C, f), s)); ++w)
          this.updateRangeFromParsed(h, t, C, f);
    return h;
      a = n[o][t.axis], ys(a) && r.push(a);
    this.update(t || "default"), n._clip = pce(Zn(this.options.clip, fce(n.xScale, n.yScale, this.getMaxOverflow())));
    const t = this._ctx, n = this.chart, r = this._cachedMeta, o = r.data || [], s = n.chartArea, a = [], c = this._drawStart || 0, f = this._drawCount || o.length - c, h = this.options.drawActiveElementsOnTop;
      const v = o[g];
      v.hidden || (v.active && h ? a.push(v) : v.draw(t, s));
      s = a.$context || (a.$context = bce(this.getContext(), t, a)), s.parsed = this.getParsed(t), s.raw = o.data[t], s.index = s.dataIndex = t;
      s = this.$context || (this.$context = yce(this.chart.getContext(), this.index)), s.dataset = o, s.index = s.datasetIndex = this.index;
    const o = n === "active", s = this._cachedDataOpts, a = t + "-" + n, c = s[a], f = this.enableOptionSharing && ZT(r);
      return U2(c, f);
    const h = this.chart.config, g = h.datasetElementScopeKeys(this._type, t), v = o ? [
    ], w = h.getOptionScopes(this.getDataset(), g), C = Object.keys(Fo.elements[t]), T = () => this.getContext(r, o, n), E = h.resolveNamedOptions(w, C, T, v);
    return E.$shared && (E.$shared = f, s[a] = Object.freeze(U2(E, f))), E;
      const g = this.chart.config, v = g.datasetAnimationScopeKeys(this._type, n), w = g.getOptionScopes(this.getDataset(), v);
    const h = new a5(o, f && f.animations);
    return f && f._cacheable && (s[a] = Object.freeze(h)), h;
    return !n || PP(t) || this.chart._animationsDisabled;
    PP(o) ? Object.assign(t, r) : this._resolveAnimations(n, o).update(t, r);
    t && !PP(n) && this._resolveAnimations(void 0, n).update(t, r);
    for (const [c, f, h] of this._syncList)
      this[c](f, h);
    const f = (h) => {
      for (h.length += n, c = h.length - 1; c >= a; c--)
        h[c] = h[c - n];
      r._stacked && Yw(r, o);
Nn(bT, "defaults", {}), Nn(bT, "datasetElementType", null), Nn(bT, "dataElementType", null);
function Nh() {
class AD {
    Nn(this, "options");
    Object.assign(AD.prototype, t);
    return Nh();
    return Nh();
    return Nh();
    return Nh();
    return Nh();
    return Nh();
    return Nh();
var Sce = {
  _date: AD
function Cce(e, t, n, r) {
    const h = c._reversePixels ? eue : GM;
        const g = s[0], v = typeof g.getRange == "function" && g.getRange(t);
        if (v) {
          const w = h(s, t, n - v), C = h(s, t, n + v);
      const g = h(s, t, n);
        const { vScale: v } = o._cachedMeta, { _parsed: w } = e, C = w.slice(0, g.lo + 1).reverse().findIndex((E) => !ho(E[v.axis]));
        const T = w.slice(g.hi).findIndex((E) => !ho(E[v.axis]));
function l1(e, t, n, r, o) {
    const { index: h, data: g } = s[c], { lo: v, hi: w } = Cce(s[c], t, a, o);
    for (let C = v; C <= w; ++C) {
      T.skip || r(T, h, C);
function xce(e) {
function MP(e, t, n, r, o) {
  return !o && !e.isPointInArea(t) || l1(e, n, t, function(c, f, h) {
    !o && !ZS(c, e.chartArea, 0) || c.inRange(t.x, t.y, r) && s.push({
      index: h
function Ece(e, t, n, r) {
    const { startAngle: h, endAngle: g } = a.getProps([
    ], r), { angle: v } = Qle(a, {
    BU(v, h, g) && o.push({
  return l1(e, n, t, s), o;
function Tce(e, t, n, r, o, s) {
  const c = xce(n);
  function h(g, v, w) {
        datasetIndex: v,
      datasetIndex: v,
  return l1(e, n, t, h), a;
function IP(e, t, n, r, o, s) {
  return !s && !e.isPointInArea(t) ? [] : n === "r" && !r ? Ece(e, t, n, o) : Tce(e, t, n, r, o, s);
function W2(e, t, n, r, o) {
  return l1(e, n, t, (f, h, g) => {
      datasetIndex: h,
var _ce = {
      const o = Bh(t, e), s = n.axis || "x", a = n.includeInvisible || !1, c = n.intersect ? MP(e, o, s, r, a) : IP(e, o, s, !1, r, a), f = [];
      return c.length ? (e.getSortedVisibleDatasetMetas().forEach((h) => {
        const g = c[0].index, v = h.data[g];
        v && !v.skip && f.push({
          element: v,
          datasetIndex: h.index,
      const o = Bh(t, e), s = n.axis || "xy", a = n.includeInvisible || !1;
      let c = n.intersect ? MP(e, o, s, r, a) : IP(e, o, s, !1, r, a);
        const f = c[0].datasetIndex, h = e.getDatasetMeta(f).data;
        for (let g = 0; g < h.length; ++g)
            element: h[g],
      const o = Bh(t, e), s = n.axis || "xy", a = n.includeInvisible || !1;
      return MP(e, o, s, r, a);
      const o = Bh(t, e), s = n.axis || "xy", a = n.includeInvisible || !1;
      return IP(e, o, s, n.intersect, r, a);
      const o = Bh(t, e);
      return W2(e, o, "x", n.intersect, r);
      const o = Bh(t, e);
      return W2(e, o, "y", n.intersect, r);
const u5 = [
function Xw(e, t) {
function G2(e, t) {
  return e.filter((n) => u5.indexOf(n.pos) === -1 && n.box.axis === t);
function Qw(e, t) {
function Oce(e) {
function Rce(e) {
    if (!r || !u5.includes(o))
function kce(e, t) {
  const n = Rce(e), { vBoxMaxWidth: r, hBoxMaxHeight: o } = t;
    const { fullSize: f } = c.box, h = n[c.stack], g = h && c.stackWeight / h.weight;
function Pce(e) {
  const t = Oce(e), n = Qw(t.filter((h) => h.box.fullSize), !0), r = Qw(Xw(t, "left"), !0), o = Qw(Xw(t, "right")), s = Qw(Xw(t, "top"), !0), a = Qw(Xw(t, "bottom")), c = G2(t, "x"), f = G2(t, "y");
    chartArea: Xw(t, "chartArea"),
function q2(e, t, n, r) {
function c5(e, t) {
function Mce(e, t, n, r) {
  if (!sr(o)) {
    const v = r[n.stack] || {
    v.size = Math.max(v.size, n.horizontal ? s.height : s.width), n.size = v.size / v.count, e[o] += n.size;
  s.getPadding && c5(a, s.getPadding());
  const c = Math.max(0, t.outerWidth - q2(a, e, "left", "right")), f = Math.max(0, t.outerHeight - q2(a, e, "top", "bottom")), h = c !== e.w, g = f !== e.h;
    same: h,
    other: h
function Ice(e) {
function Dce(e, t) {
function hS(e, t, n, r) {
  let s, a, c, f, h, g;
  for (s = 0, a = e.length, h = 0; s < a; ++s) {
    c = e[s], f = c.box, f.update(c.width || t.w, c.height || t.h, Dce(c.horizontal, t));
    const { same: v, other: w } = Mce(t, n, c, r);
    h |= v && o.length, g = g || w, f.fullSize || o.push(c);
  return h && hS(o, t, n, r) || g;
function eT(e, t, n, r, o) {
function K2(e, t, n, r) {
    const f = c.box, h = r[c.stack] || {
    }, g = c.stackWeight / h.weight || 1;
      const v = t.w * g, w = h.size || f.height;
      ZT(h.start) && (a = h.start), f.fullSize ? eT(f, o.left, a, n.outerWidth - o.right - o.left, w) : eT(f, t.left + h.placed, a, v, w), h.start = a, h.placed += v, a = f.bottom;
      const v = t.h * g, w = h.size || f.width;
      ZT(h.start) && (s = h.start), f.fullSize ? eT(f, s, o.top, w, n.outerHeight - o.bottom - o.top) : eT(f, s, t.top + h.placed, w, v), h.start = s, h.placed += v, s = f.right;
var Uf = {
    const o = Su(e.options.layout.padding), s = Math.max(t - o.width, 0), a = Math.max(n - o.height, 0), c = Pce(e.boxes), f = c.vertical, h = c.horizontal;
    Mr(e.boxes, (E) => {
    const g = f.reduce((E, O) => O.box.options && O.box.options.display === !1 ? E : E + 1, 0) || 1, v = Object.freeze({
    c5(w, Su(r));
    }, o), T = kce(f.concat(h), v);
    hS(c.fullSize, C, v, T), hS(f, C, v, T), hS(h, C, v, T) && hS(f, C, v, T), Ice(C), K2(c.leftAndTop, C, v, T), C.x += C.w, C.y += C.h, K2(c.rightAndBottom, C, v, T), e.chartArea = {
    }, Mr(c.chartArea, (E) => {
class d5 {
class Ace extends d5 {
const wT = "$chartjs", Nce = {
}, Y2 = (e) => e === null || e === "";
function $ce(e, t) {
  if (e[wT] = {
  }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", Y2(o)) {
    const s = N2(e, "width");
  if (Y2(r))
      const s = N2(e, "height");
const f5 = Yue ? {
function Lce(e, t, n) {
  e && e.addEventListener(t, n, f5);
function jce(e, t, n) {
  e && e.canvas && e.canvas.removeEventListener(t, n, f5);
function Fce(e, t) {
  const n = Nce[e.type] || e.type, { x: r, y: o } = Bh(e, t);
function o_(e, t) {
function zce(e, t, n) {
      a = a || o_(c.addedNodes, r), a = a && !o_(c.removedNodes, r);
function Bce(e, t, n) {
      a = a || o_(c.removedNodes, r), a = a && !o_(c.addedNodes, r);
const eC = /* @__PURE__ */ new Map();
let X2 = 0;
function p5() {
  e !== X2 && (X2 = e, eC.forEach((t, n) => {
function Hce(e, t) {
  eC.size || window.addEventListener("resize", p5), eC.set(e, t);
function Vce(e) {
  eC.delete(e), eC.size || window.removeEventListener("resize", p5);
function Uce(e, t, n) {
  const r = e.canvas, o = r && DD(r);
  const s = UU((c, f) => {
    const h = o.clientWidth;
    n(c, f), h < o.clientWidth && n();
    const f = c[0], h = f.contentRect.width, g = f.contentRect.height;
    h === 0 && g === 0 || s(h, g);
  return a.observe(o), Hce(e, s), a;
function DP(e, t, n) {
  n && n.disconnect(), t === "resize" && Vce(e);
function Wce(e, t, n) {
  const r = e.canvas, o = UU((s) => {
    e.ctx !== null && n(Fce(s, e));
  return Lce(r, t, o), o;
class Gce extends d5 {
    return r && r.canvas === t ? ($ce(t, n), r) : null;
    if (!n[wT])
    const r = n[wT].initial;
      ho(a) ? n.removeAttribute(s) : n.setAttribute(s, a);
    }), n.width = n.width, delete n[wT], !0;
      attach: zce,
      detach: Bce,
      resize: Uce
    }[n] || Wce;
      attach: DP,
      detach: DP,
      resize: DP
    }[n] || jce)(t, n, o), r[n] = void 0;
    return Kue(t, n, r, o);
    const n = t && DD(t);
function qce(e) {
  return !ID() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? Ace : Gce;
var uT;
let Sy = (uT = class {
    Nn(this, "x");
    Nn(this, "y");
    Nn(this, "active", !1);
    Nn(this, "options");
    Nn(this, "$animations");
    return t_(this.x) && t_(this.y);
}, Nn(uT, "defaults", {}), Nn(uT, "defaultRoutes"), uT);
function Kce(e, t) {
  const n = e.options.ticks, r = Yce(e), o = Math.min(n.maxTicksLimit || r, r), s = n.major.enabled ? Qce(t) : [], a = s.length, c = s[0], f = s[a - 1], h = [];
    return Jce(t, h, s, a / o), h;
  const g = Xce(s, t, o);
    let v, w;
    for (tT(t, h, g, ho(C) ? 0 : c - C, c), v = 0, w = a - 1; v < w; v++)
      tT(t, h, g, s[v], s[v + 1]);
    return tT(t, h, g, f, ho(C) ? t.length : f + C), h;
  return tT(t, h, g), h;
function Yce(e) {
function Xce(e, t, n) {
  const r = Zce(e), o = t.length / n;
  const s = Gle(r);
function Qce(e) {
function Jce(e, t, n, r) {
function tT(e, t, n, r, o) {
  const s = Zn(r, 0), a = Math.min(Zn(o, e.length), e.length);
  let c = 0, f, h, g;
  for (h = Math.max(s, 0); h < a; h++)
    h === g && (t.push(e[h]), c++, g = Math.round(s + c * n));
function Zce(e) {
const ede = (e) => e === "left" ? "right" : e === "right" ? "left" : e, Q2 = (e, t, n) => t === "top" || t === "left" ? e[t] + n : e[t] - n, J2 = (e, t) => Math.min(t || e, e);
function Z2(e, t) {
function tde(e, t, n) {
  let f = e.getPixelForTick(o), h;
  if (!(n && (r === 1 ? h = Math.max(f - s, a - f) : t === 0 ? h = (e.getPixelForTick(1) - f) / 2 : h = (f - e.getPixelForTick(o - 1)) / 2, f += o < t ? h : -h, f < s - c || f > a + c)))
function nde(e, t) {
  Mr(e, (n) => {
function Jw(e) {
function ez(e, t) {
  const n = aa(e.font, t), r = Su(e.padding);
  return (Oi(e.text) ? e.text.length : 1) * n.lineHeight + r.height;
function rde(e, t) {
  return wm(e, {
function ode(e, t, n) {
  return wm(e, {
function ide(e, t, n) {
  let r = WU(e);
  return (n && t !== "right" || !n && t === "right") && (r = ede(r)), r;
function sde(e, t, n, r) {
  const { top: o, left: s, bottom: a, right: c, chart: f } = e, { chartArea: h, scales: g } = f;
  let v = 0, w, C, T;
    if (C = Ra(r, s, c), sr(n)) {
      const P = Object.keys(n)[0], I = n[P];
      T = g[P].getPixelForValue(I) + E - t;
    } else n === "center" ? T = (h.bottom + h.top) / 2 + E - t : T = Q2(e, n, t);
    if (sr(n)) {
      const P = Object.keys(n)[0], I = n[P];
      C = g[P].getPixelForValue(I) - O + t;
    } else n === "center" ? C = (h.left + h.right) / 2 - O + t : C = Q2(e, n, t);
    T = Ra(r, a, o), v = n === "left" ? -mu : mu;
    rotation: v
class Cy extends Sy {
    return t = sc(t, Number.POSITIVE_INFINITY), n = sc(n, Number.NEGATIVE_INFINITY), r = sc(r, Number.POSITIVE_INFINITY), o = sc(o, Number.NEGATIVE_INFINITY), {
      min: sc(t, r),
      max: sc(n, o),
      minDefined: ys(t),
      maxDefined: ys(n)
    for (let f = 0, h = c.length; f < h; ++f)
      min: sc(n, sc(r, n)),
      max: sc(r, sc(n, r))
    to(this.options.beforeUpdate, [
    }, r), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + r.left + r.right : this.height + r.top + r.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = _ue(this, s, o), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    this._convertTicksToLabels(f ? Z2(this.ticks, c) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), a.display && (a.autoSkip || a.source === "auto") && (this.ticks = Kce(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), f && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
    to(this.options.afterUpdate, [
    to(this.options.beforeSetDimensions, [
    to(this.options.afterSetDimensions, [
    this.chart.notifyPlugins(t, this.getContext()), to(this.options[t], [
    to(this.options.beforeTickToLabelConversion, [
      s = t[r], s.label = to(n.callback, [
    to(this.options.afterTickToLabelConversion, [
    to(this.options.beforeCalculateLabelRotation, [
    const t = this.options, n = t.ticks, r = J2(this.ticks.length, t.ticks.maxTicksLimit), o = n.minRotation || 0, s = n.maxRotation;
    let a = o, c, f, h;
    const g = this._getLabelSizes(), v = g.widest.width, w = g.highest.height, C = mc(this.chart.width - v, 0, this.maxWidth);
    c = t.offset ? this.maxWidth / r : C / (r - 1), v + 6 > c && (c = C / (r - (t.offset ? 0.5 : 1)), f = this.maxHeight - Jw(t.grid) - n.padding - ez(t.title, this.chart.options.font), h = Math.sqrt(v * v + w * w), a = Xle(Math.min(Math.asin(mc((g.highest.height + 6) / c, -1, 1)), Math.asin(mc(f / h, -1, 1)) - Math.asin(mc(w / h, -1, 1)))), a = Math.max(o, Math.min(s, a))), this.labelRotation = a;
    to(this.options.afterCalculateLabelRotation, [
    to(this.options.beforeFit, [
      const f = ez(o, n.options.font);
      if (c ? (t.width = this.maxWidth, t.height = Jw(s) + f) : (t.height = this.maxHeight, t.width = Jw(s) + f), r.display && this.ticks.length) {
        const { first: h, last: g, widest: v, highest: w } = this._getLabelSizes(), C = r.padding * 2, T = Jh(this.labelRotation), E = Math.cos(T), O = Math.sin(T);
          const P = r.mirror ? 0 : O * v.width + E * w.height;
          t.height = Math.min(this.maxHeight, t.height + P + C);
          const P = r.mirror ? 0 : E * v.width + O * w.height;
          t.width = Math.min(this.maxWidth, t.width + P + C);
        this._calculatePadding(h, g, O, E);
    const { ticks: { align: s, padding: a }, position: c } = this.options, f = this.labelRotation !== 0, h = c !== "top" && this.axis === "x";
      const g = this.getPixelForTick(0) - this.left, v = this.right - this.getPixelForTick(this.ticks.length - 1);
      f ? h ? (w = o * t.width, C = r * n.height) : (w = r * t.height, C = o * n.width) : s === "start" ? C = n.width : s === "end" ? w = t.width : s !== "inner" && (w = t.width / 2, C = n.width / 2), this.paddingLeft = Math.max((w - g + a) * this.width / (this.width - g), 0), this.paddingRight = Math.max((C - v + a) * this.width / (this.width - v), 0);
      let g = n.height / 2, v = t.height / 2;
      s === "start" ? (g = 0, v = t.height) : s === "end" && (g = n.height, v = 0), this.paddingTop = g + a, this.paddingBottom = v + a;
    to(this.options.afterFit, [
      ho(t[n].label) && (t.splice(n, 1), r--, n--);
      n < r.length && (r = Z2(r, n)), this._labelSizes = t = this._computeLabelSizes(r, r.length, this.options.ticks.maxTicksLimit);
    const { ctx: o, _longestTextCache: s } = this, a = [], c = [], f = Math.floor(n / J2(n, r));
    let h = 0, g = 0, v, w, C, T, E, O, P, I, M, A, k;
    for (v = 0; v < n; v += f) {
      if (T = t[v].label, E = this._resolveTickFontOptions(v), o.font = O = E.string, P = s[O] = s[O] || {
      }, I = E.lineHeight, M = A = 0, !ho(T) && !Oi(T))
        M = P2(o, P.data, P.gc, M, T), A = I;
      else if (Oi(T))
          k = T[w], !ho(k) && !Oi(k) && (M = P2(o, P.data, P.gc, M, k), A += I);
      a.push(M), c.push(A), h = Math.max(M, h), g = Math.max(A, g);
    nde(s, n);
    const j = a.indexOf(h), B = c.indexOf(g), H = (F) => ({
      width: a[F] || 0,
      height: c[F] || 0
      first: H(0),
      last: H(n - 1),
      widest: H(j),
      highest: H(B),
    return Zle(this._alignToPixels ? Ah(this.chart, n, 0) : n);
      return r.$context || (r.$context = ode(this.getContext(), t, r));
    return this.$context || (this.$context = rde(this.chart.getContext(), this));
    const t = this.options.ticks, n = Jh(this.labelRotation), r = Math.abs(Math.cos(n)), o = Math.abs(Math.sin(n)), s = this._getLabelSizes(), a = t.autoSkipPadding || 0, c = s ? s.widest.width + a : 0, f = s ? s.highest.height + a : 0;
    const n = this.axis, r = this.chart, o = this.options, { grid: s, position: a, border: c } = o, f = s.offset, h = this.isHorizontal(), v = this.ticks.length + (f ? 1 : 0), w = Jw(s), C = [], T = c.setContext(this.getContext()), E = T.display ? T.width : 0, O = E / 2, P = function(Y) {
      return Ah(r, Y, E);
    let I, M, A, k, j, B, H, F, D, q, U, K;
      I = P(this.bottom), B = this.bottom - w, F = I - O, q = P(t.top) + O, K = t.bottom;
      I = P(this.top), q = t.top, K = P(t.bottom) - O, B = I + O, F = this.top + w;
      I = P(this.right), j = this.right - w, H = I - O, D = P(t.left) + O, U = t.right;
      I = P(this.left), D = t.left, U = P(t.right) - O, j = I + O, H = this.left + w;
        I = P((t.top + t.bottom) / 2 + 0.5);
      else if (sr(a)) {
        const Y = Object.keys(a)[0], X = a[Y];
        I = P(this.chart.scales[Y].getPixelForValue(X));
      q = t.top, K = t.bottom, B = I + O, F = B + w;
        I = P((t.left + t.right) / 2);
      else if (sr(a)) {
        const Y = Object.keys(a)[0], X = a[Y];
        I = P(this.chart.scales[Y].getPixelForValue(X));
      }
      j = I - O, H = j - w, D = t.left, U = t.right;
    }
    const ee = Zn(o.ticks.maxTicksLimit, v), G = Math.max(1, Math.ceil(v / ee));
    for (M = 0; M < v; M += G) {
      const Y = this.getContext(M), X = s.setContext(Y), te = c.setContext(Y), re = X.lineWidth, Q = X.color, V = te.dash || [], ie = te.dashOffset, de = X.tickWidth, ue = X.tickColor, he = X.tickBorderDash || [], ge = X.tickBorderDashOffset;
      A = tde(this, M, f), A !== void 0 && (k = Ah(r, A, re), h ? j = H = D = U = k : B = F = q = K = k, C.push({
        tx1: j,
        ty1: B,
        tx2: H,
        ty2: F,
        x1: D,
        x2: U,
        y2: K,
        borderDash: V,
    return this._ticksLength = v, this._borderValue = I, C;
    const n = this.axis, r = this.options, { position: o, ticks: s } = r, a = this.isHorizontal(), c = this.ticks, { align: f, crossAlign: h, padding: g, mirror: v } = s, w = Jw(r.grid), C = w + g, T = v ? -g : C, E = -Jh(this.labelRotation), O = [];
    let P, I, M, A, k, j, B, H, F, D, q, U, K = "middle";
      j = this.bottom - T, B = this._getXAxisLabelAlignment();
      j = this.top + T, B = this._getXAxisLabelAlignment();
      B = G.textAlign, k = G.x;
      B = G.textAlign, k = G.x;
        j = (t.top + t.bottom) / 2 + C;
      else if (sr(o)) {
        const G = Object.keys(o)[0], Y = o[G];
        j = this.chart.scales[G].getPixelForValue(Y) + C;
      B = this._getXAxisLabelAlignment();
        k = (t.left + t.right) / 2 - C;
      else if (sr(o)) {
        const G = Object.keys(o)[0], Y = o[G];
        k = this.chart.scales[G].getPixelForValue(Y);
      B = this._getYAxisLabelAlignment(w).textAlign;
    n === "y" && (f === "start" ? K = "top" : f === "end" && (K = "bottom"));
    for (P = 0, I = c.length; P < I; ++P) {
      M = c[P], A = M.label;
      const G = s.setContext(this.getContext(P));
      H = this.getPixelForTick(P) + s.labelOffset, F = this._resolveTickFontOptions(P), D = F.lineHeight, q = Oi(A) ? A.length : 1;
      const Y = q / 2, X = G.color, te = G.textStrokeColor, re = G.textStrokeWidth;
      let Q = B;
      a ? (k = H, B === "inner" && (P === I - 1 ? Q = this.options.reverse ? "left" : "right" : P === 0 ? Q = this.options.reverse ? "right" : "left" : Q = "center"), o === "top" ? h === "near" || E !== 0 ? U = -q * D + D / 2 : h === "center" ? U = -ee.highest.height / 2 - Y * D + D : U = -ee.highest.height + D / 2 : h === "near" || E !== 0 ? U = D / 2 : h === "center" ? U = ee.highest.height / 2 - Y * D : U = ee.highest.height - q * D, v && (U *= -1), E !== 0 && !G.showLabelBackdrop && (k += D / 2 * Math.sin(E))) : (j = H, U = (1 - q) * D / 2);
      let V;
        const ie = Su(G.backdropPadding), de = ee.heights[P], ue = ee.widths[P];
        let he = U - ie.top, ge = 0 - ie.left;
        switch (K) {
        switch (B) {
            P === I - 1 ? ge -= ue : P > 0 && (ge -= ue / 2);
        V = {
        label: A,
        font: F,
        textOffset: U,
          textBaseline: K,
            k,
            j
          backdrop: V
    if (-Jh(this.labelRotation))
    let h, g;
    return n === "left" ? o ? (g = this.right + s, r === "near" ? h = "left" : r === "center" ? (h = "center", g += f / 2) : (h = "right", g += f)) : (g = this.right - c, r === "near" ? h = "right" : r === "center" ? (h = "center", g -= f / 2) : (h = "left", g = this.left)) : n === "right" ? o ? (g = this.left + s, r === "near" ? h = "right" : r === "center" ? (h = "center", g -= f / 2) : (h = "left", g -= f)) : (g = this.left + c, r === "near" ? h = "left" : r === "center" ? (h = "center", g += f / 2) : (h = "right", g = this.right)) : h = "right", {
      textAlign: h,
    const c = (f, h, g) => {
      !g.width || !g.color || (r.save(), r.lineWidth = g.width, r.strokeStyle = g.color, r.setLineDash(g.borderDash || []), r.lineDashOffset = g.borderDashOffset, r.beginPath(), r.moveTo(f.x, f.y), r.lineTo(h.x, h.y), r.stroke(), r.restore());
    let h, g, v, w;
    this.isHorizontal() ? (h = Ah(t, this.left, a) - a / 2, g = Ah(t, this.right, c) + c / 2, v = w = f) : (v = Ah(t, this.top, a) - a / 2, w = Ah(t, this.bottom, c) + c / 2, h = g = f), n.save(), n.lineWidth = s.width, n.strokeStyle = s.color, n.beginPath(), n.moveTo(h, v), n.lineTo(g, w), n.stroke(), n.restore();
    o && i1(r, o);
      const c = a.options, f = a.font, h = a.label, g = a.textOffset;
      n_(r, h, 0, g, f, c);
    o && s1(r);
    const s = aa(r.font), a = Su(r.padding), c = r.align;
    n === "bottom" || n === "center" || sr(n) ? (f += a.bottom, Oi(r.text) && (f += s.lineHeight * (r.text.length - 1))) : f += a.top;
    const { titleX: h, titleY: g, maxWidth: v, rotation: w } = sde(this, f, n, c);
    n_(t, r.text, 0, 0, s, {
      maxWidth: v,
      textAlign: ide(c, n, o),
        h,
    const t = this.options, n = t.ticks && t.ticks.z || 0, r = Zn(t.grid && t.grid.z, -1), o = Zn(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== Cy.prototype.draw ? [
    return aa(n.font);
class nT {
    ude(n) && (r = this.register(n));
    return s in o || (o[s] = t, ade(t, a, r), this.override && Fo.override(t.id, t.overrides)), a;
    r in n && delete n[r], o && r in Fo[o] && (delete Fo[o][r], this.override && delete fm[r]);
function ade(e, t, n) {
  const r = JS(/* @__PURE__ */ Object.create(null), [
    n ? Fo.get(n) : {},
    Fo.get(t),
  Fo.set(t, r), e.defaultRoutes && lde(t, e.defaultRoutes), e.descriptors && Fo.describe(t, e.descriptors);
function lde(e, t) {
    Fo.route(s, o, f, c);
function ude(e) {
class cde {
    this.controllers = new nT(bT, "datasets", !0), this.elements = new nT(Sy, "elements"), this.plugins = new nT(Object, "plugins"), this.scales = new nT(Cy, "scales"), this._typedRegistries = [
      r || s.isForType(o) || s === this.plugins && o.id ? this._exec(t, s, o) : Mr(o, (a) => {
    const o = _D(t);
    to(r["before" + o], [], r), n[t](r), to(r["after" + o], [], r);
var cc = /* @__PURE__ */ new cde();
class dde {
      if (to(c, f, a) === !1 && o.cancelable)
    ho(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
    const r = t && t.config, o = Zn(r.options && r.options.plugins, {}), s = fde(r);
    return o === !1 && !n ? [] : hde(t, s, o, n);
function fde(e) {
  const t = {}, n = [], r = Object.keys(cc.plugins.items);
    n.push(cc.getPlugin(r[s]));
function pde(e, t) {
function hde(e, { plugins: t, localIds: n }, r, o) {
    const f = c.id, h = pde(r[f], o);
    h !== null && s.push({
      options: mde(e.config, {
      }, h, a)
function mde(e, { plugin: t, local: n }, r, o) {
function XM(e, t) {
  const n = Fo.datasets[e] || {};
function gde(e, t) {
function vde(e, t) {
function tz(e) {
function yde(e) {
function QM(e, ...t) {
  if (tz(e))
    const r = n.axis || yde(n.position) || e.length > 1 && tz(e[0].toLowerCase());
function nz(e, t, n) {
function bde(e, t) {
      return nz(e, "x", n[0]) || nz(e, "y", n[0]);
function wde(e, t) {
  const n = fm[e.type] || {
  }, r = t.scales || {}, o = XM(e.type, t), s = /* @__PURE__ */ Object.create(null);
    if (!sr(c))
    const f = QM(a, c, bde(a, e), Fo.scales[c.type]), h = vde(f, o), g = n.scales || {};
    s[a] = OS(/* @__PURE__ */ Object.create(null), [
      g[h]
    const c = a.type || e.type, f = a.indexAxis || XM(c, t), g = (fm[c] || {}).scales || {};
    Object.keys(g).forEach((v) => {
      const w = gde(v, f), C = a[w + "AxisID"] || w;
      s[C] = s[C] || /* @__PURE__ */ Object.create(null), OS(s[C], [
        g[v]
    OS(c, [
      Fo.scales[c.type],
      Fo.scale
function h5(e) {
  t.plugins = Zn(t.plugins, {}), t.scales = wde(e, t);
function m5(e) {
function Sde(e) {
  return e = e || {}, e.data = m5(e.data), h5(e), e;
const rz = /* @__PURE__ */ new Map(), g5 = /* @__PURE__ */ new Set();
function rT(e, t) {
  let n = rz.get(e);
  return n || (n = t(), rz.set(e, n), g5.add(n)), n;
const Zw = (e, t, n) => {
  const r = JT(t, n);
class Cde {
    this._config = Sde(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
    this._config.data = m5(t);
    this.clearCache(), h5(t);
    return rT(t, () => [
    return rT(`${t}.transition.${n}`, () => [
    return rT(`${t}-${n}`, () => [
    return rT(`${r}-plugin-${n}`, () => [
      t && (f.add(t), g.forEach((v) => Zw(f, t, v))), g.forEach((v) => Zw(f, o, v)), g.forEach((v) => Zw(f, fm[s] || {}, v)), g.forEach((v) => Zw(f, Fo, v)), g.forEach((v) => Zw(f, qM, v));
    const h = Array.from(f);
    return h.length === 0 && h.push(/* @__PURE__ */ Object.create(null)), g5.has(n) && a.set(n, h), h;
      fm[n] || {},
      Fo.datasets[n] || {},
      Fo,
      qM
    }, { resolver: a, subPrefixes: c } = oz(this._resolverCache, t, o);
    if (Ede(a, n)) {
      s.$shared = !1, r = np(r) ? r() : r;
      const h = this.createResolver(t, r, c);
      f = oy(a, r, h);
    for (const h of n)
      s[h] = f[h];
    const { resolver: s } = oz(this._resolverCache, t, r);
    return sr(n) ? oy(s, n, void 0, o) : s;
function oz(e, t, n) {
    resolver: kD(t, n),
const xde = (e) => sr(e) && Object.getOwnPropertyNames(e).some((t) => np(e[t]));
function Ede(e, t) {
  const { isScriptable: n, isIndexable: r } = XU(e);
    if (s && (np(c) || xde(c)) || a && Oi(c))
var Tde = "4.5.1";
const _de = [
function iz(e, t) {
  return e === "top" || e === "bottom" || _de.indexOf(e) === -1 && t === "x";
function sz(e, t) {
function az(e) {
  t.notifyPlugins("afterRender"), to(n && n.onComplete, [
function Ode(e) {
  to(n && n.onProgress, [
function v5(e) {
  return ID() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
const ST = {}, lz = (e) => {
  const t = v5(e);
  return Object.values(ST).filter((n) => n.canvas === t).pop();
function Rde(e, t, n) {
function kde(e, t, n, r) {
class Ed {
    cc.add(...t), uz();
    cc.remove(...t), uz();
    const r = this.config = new Cde(n), o = v5(t), s = lz(o);
    this.platform = new (r.platform || qce(o))(), this.platform.updateConfig(r);
    const c = this.platform.acquireContext(o, a.aspectRatio), f = c && c.canvas, h = f && f.height, g = f && f.width;
    if (this.id = Lle(), this.ctx = c, this.canvas = f, this.width = g, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new dde(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = oue((v) => this.update(v), a.resizeDelay || 0), this._dataChanges = [], ST[this.id] = this, !c || !f) {
    bd.listen(this, "complete", az), bd.listen(this, "progress", Ode), this._initialize(), this.attached && this.update();
    return ho(t) ? n && s ? s : o ? r / o : null : t;
    return cc;
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : A2(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
    return M2(this.canvas, this.ctx), this;
    return bd.stop(this), this;
    bd.running(this) ? this._resizeBeforeDraw = {
    this.width = a.width, this.height = a.height, this._aspectRatio = this.aspectRatio, A2(this, c, !0) && (this.notifyPlugins("resize", {
    }), to(r.onResize, [
    Mr(n, (r, o) => {
      const c = n[a], f = QM(a, c), h = f === "r", g = f === "x";
        dposition: h ? "chartArea" : g ? "bottom" : "left",
        dtype: h ? "radialLinear" : g ? "category" : "linear"
    }))), Mr(s, (a) => {
      const c = a.options, f = c.id, h = QM(f, c), g = Zn(c.type, a.dtype);
      (c.position === void 0 || iz(c.position, h) !== iz(a.dposition)) && (c.position = a.dposition), o[f] = !0;
      let v = null;
        v = r[f];
        const w = cc.getScale(g);
        v = new w({
        }), r[v.id] = v;
      v.init(c, t);
    }), Mr(o, (a, c) => {
    }), Mr(r, (a) => {
      Uf.configure(this, a, a.options), Uf.addBox(this, a);
    this._sortedMetasets = t.slice(0).sort(sz("order", "index"));
      if (a.type && a.type !== c && (this._destroyDatasetMeta(r), a = this.getDatasetMeta(r)), a.type = c, a.indexAxis = s.indexAxis || XM(c, this.options), a.order = s.order || 0, a.index = r, a.label = "" + s.label, a.visible = this.isDatasetVisible(r), a.controller)
        const f = cc.getController(c), { datasetElementType: h, dataElementType: g } = Fo.datasets[c];
          dataElementType: cc.getElement(g),
          datasetElementType: h && cc.getElement(h)
    Mr(this.data.datasets, (t, n) => {
    for (let h = 0, g = this.data.datasets.length; h < g; h++) {
      const { controller: v } = this.getDatasetMeta(h), w = !o && s.indexOf(v) === -1;
      v.buildOrUpdateElements(w), a = Math.max(+v.getMaxOverflow(), a);
    a = this._minPadding = r.layout.autoPadding ? a : 0, this._updateLayout(a), o || Mr(s, (h) => {
      h.reset();
    }), this._layers.sort(sz("z", "_idx"));
    Mr(this.scales, (t) => {
      Uf.removeBox(this, t);
    (!S2(n, r) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
      Rde(t, o, a);
      if (!S2(o, r(s)))
    Uf.update(this, this.width, this.height, t);
    this._layers = [], Mr(this.boxes, (o) => {
        this._updateDataset(n, np(t) ? t({
    }) !== !1 && (bd.has(this) ? this.attached && !bd.running(this) && bd.start(this) : (this.draw(), az({
    }, o = s5(this, t);
    this.notifyPlugins("beforeDatasetDraw", r) !== !1 && (o && i1(n, o), t.controller.draw(), o && s1(n), r.cancelable = !1, this.notifyPlugins("afterDatasetDraw", r));
    return ZS(t, this.chartArea, this._minPadding);
    const s = _ce.modes[n];
    return this.$context || (this.$context = wm(null, {
    ZT(n) ? (s.data[n].hidden = !r, this.update()) : (this.setDatasetVisibility(t, r), a.update(s, {
    for (this.stop(), bd.remove(this), t = 0, n = this.data.datasets.length; t < n; ++t)
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), M2(t, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete ST[this.id], this.notifyPlugins("afterDestroy");
    Mr(this.options.events, (s) => r(s, o));
    const t = this._responsiveListeners, n = this.platform, r = (f, h) => {
      n.addEventListener(this, f, h), t[f] = h;
    }, o = (f, h) => {
      t[f] && (n.removeEventListener(this, f, h), delete t[f]);
    }, s = (f, h) => {
      this.canvas && this.resize(f, h);
    Mr(this._listeners, (t, n) => {
    }), this._listeners = {}, Mr(this._responsiveListeners, (t, n) => {
      const h = a && this.getDatasetMeta(a.datasetIndex).controller;
      h && h[o + "HoverStyle"](a.element, a.datasetIndex, a.index);
    !XT(r, n) && (this._active = r, this._lastEvent = null, this._updateHoverStyles(r, n));
    const o = this.options.hover, s = (f, h) => f.filter((g) => !h.some((v) => g.datasetIndex === v.datasetIndex && g.index === v.index)), a = s(n, t), c = r ? t : s(t, n);
    const { _active: o = [], options: s } = this, a = n, c = this._getActiveElements(t, o, r, a), f = Vle(t), h = kde(t, this._lastEvent, r, f);
    r && (this._lastEvent = null, to(s.onHover, [
    ], this), f && to(s.onClick, [
    const g = !XT(c, o);
    return (g || n) && (this._active = c, this._updateHoverStyles(c, o, n)), this._lastEvent = h, g;
Nn(Ed, "defaults", Fo), Nn(Ed, "instances", ST), Nn(Ed, "overrides", fm), Nn(Ed, "registry", cc), Nn(Ed, "version", Tde), Nn(Ed, "getChart", lz);
function uz() {
  return Mr(Ed.instances, (e) => e._plugins.invalidate());
function y5(e, t, n = t) {
  e.lineCap = Zn(n.borderCapStyle, t.borderCapStyle), e.setLineDash(Zn(n.borderDash, t.borderDash)), e.lineDashOffset = Zn(n.borderDashOffset, t.borderDashOffset), e.lineJoin = Zn(n.borderJoinStyle, t.borderJoinStyle), e.lineWidth = Zn(n.borderWidth, t.borderWidth), e.strokeStyle = Zn(n.borderColor, t.borderColor);
function Pde(e, t, n) {
function Mde(e) {
  return e.stepped ? gue : e.tension || e.cubicInterpolationMode === "monotone" ? vue : Pde;
function b5(e, t, n = {}) {
  const r = e.length, { start: o = 0, end: s = r - 1 } = n, { start: a, end: c } = t, f = Math.max(o, a), h = Math.min(s, c), g = o < a && s < a || o > c && s > c;
    ilen: h < f && !g ? r + h - f : h - f
function Ide(e, t, n, r) {
  const { points: o, options: s } = t, { count: a, start: c, loop: f, ilen: h } = b5(o, n, r), g = Mde(s);
  let { move: v = !0, reverse: w } = r || {}, C, T, E;
  for (C = 0; C <= h; ++C)
    T = o[(c + (w ? h - C : C)) % a], !T.skip && (v ? (e.moveTo(T.x, T.y), v = !1) : g(e, E, T, w, s.stepped), E = T);
  return f && (T = o[(c + (w ? h : 0)) % a], g(e, E, T, w, s.stepped)), !!f;
}
function Dde(e, t, n, r) {
  const o = t.points, { count: s, start: a, ilen: c } = b5(o, n, r), { move: f = !0, reverse: h } = r || {};
  let g = 0, v = 0, w, C, T, E, O, P;
  const I = (A) => (a + (h ? c - A : A)) % s, M = () => {
    E !== O && (e.lineTo(g, O), e.lineTo(g, E), e.lineTo(g, P));
    const A = C.x, k = C.y, j = A | 0;
    j === T ? (k < E ? E = k : k > O && (O = k), g = (v * g + A) / ++v) : (M(), e.lineTo(A, k), T = j, v = 0, E = O = k), P = k;
function JM(e) {
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !n ? Dde : Ide;
function Ade(e) {
  return e.stepped ? Xue : e.tension || e.cubicInterpolationMode === "monotone" ? Que : Hh;
function Nde(e, t, n, r) {
  o || (o = t._path = new Path2D(), t.path(o, n, r) && o.closePath()), y5(e, t.options), e.stroke(o);
function $de(e, t, n, r) {
  const { segments: o, options: s } = t, a = JM(t);
    y5(e, s, c.style), e.beginPath(), a(e, t, c, {
const Lde = typeof Path2D == "function";
function jde(e, t, n, r) {
  Lde && !t.options.segment ? Nde(e, t, n, r) : $de(e, t, n, r);
class Wf extends Sy {
      Hue(this._points, r, t, o, n), this._pointsUpdated = !0;
    return this._segments || (this._segments = rce(this, this.options.segment));
    const r = this.options, o = t[n], s = this.points, a = i5(this, {
    const c = [], f = Ade(r);
    let h, g;
    for (h = 0, g = a.length; h < g; ++h) {
      const { start: v, end: w } = a[h], C = s[v], T = s[w];
    return JM(this)(t, this, n, r);
    const o = this.segments, s = JM(this);
    (this.points || []).length && s.borderWidth && (t.save(), jde(t, this, r, o), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
Nn(Wf, "id", "line"), Nn(Wf, "defaults", {
}), Nn(Wf, "defaultRoutes", {
}), Nn(Wf, "descriptors", {
function cz(e, t, n, r) {
class CT extends Sy {
    Nn(this, "parsed");
    Nn(this, "skip");
    Nn(this, "stop");
    return cz(this, n, "x", r);
    return cz(this, n, "y", r);
    this.skip || o.radius < 0.1 || !ZS(this, r, this.size(o) / 2) || (n.strokeStyle = o.borderColor, n.lineWidth = o.borderWidth, n.fillStyle = o.backgroundColor, KM(n, o, this.x, this.y));
Nn(CT, "id", "point"), /**
Nn(CT, "defaults", {
Nn(CT, "defaultRoutes", {
function Fde(e, t, n) {
    let { start: f, end: h } = c;
    h = u1(f, h, o);
    const g = ZM(n, o[f], o[h], c.loop);
        end: o[h]
    const v = i5(t, g);
    for (const w of v) {
      const C = ZM(n, s[w.start], s[w.end], w.loop), T = o5(c, o, C);
            [n]: dz(g, C, "start", Math.max)
            [n]: dz(g, C, "end", Math.min)
function ZM(e, t, n, r) {
  return e === "angle" && (o = dc(o), s = dc(s)), {
function zde(e, t) {
    c = u1(a, c, o);
    const f = o[a], h = o[c];
      x: h.x,
      y: h.y
function u1(e, t, n) {
function dz(e, t, n, r) {
function w5(e, t) {
  return Oi(e) ? (r = !0, n = e) : n = zde(e, t), n.length ? new Wf({
function fz(e) {
function Bde(e, t, n) {
    if (!ys(o))
function Hde(e, t, n) {
  const r = Gde(e);
  if (sr(r))
  return ys(o) && Math.floor(o) === o ? Vde(r[0], t, o, n) : [
function Vde(e, t, n, r) {
function Ude(e, t) {
  return e === "start" ? n = t.bottom : e === "end" ? n = t.top : sr(e) ? n = t.getPixelForValue(e.value) : t.getBasePixel && (n = t.getBasePixel()), n;
function Wde(e, t, n) {
  return e === "start" ? r = n : e === "end" ? r = t.options.reverse ? t.min : t.max : sr(e) ? r = e.value : r = t.getBaseValue(), r;
function Gde(e) {
  let r = Zn(n && n.target, n);
function qde(e) {
  const { scale: t, index: n, line: r } = e, o = [], s = r.segments, a = r.points, c = Kde(t, n);
  c.push(w5({
    const h = s[f];
    for (let g = h.start; g <= h.end; g++)
      Yde(o, a[g], c);
  return new Wf({
function Kde(e, t) {
function Yde(e, t, n) {
    const s = n[o], { first: a, last: c, point: f } = Xde(s, t, "x");
function Xde(e, t, n) {
  for (let h = 0; h < s.length; h++) {
    const g = s[h], v = a[g.start][n], w = a[g.end][n];
    if (Pv(o, v, w)) {
      c = o === v, f = o === w;
class S5 {
      end: vu
function Qde(e) {
  if (ys(n))
    return Jde(t, n);
    return qde(e);
  const o = Zde(e);
  return o instanceof S5 ? o : w5(o, r);
function Jde(e, t) {
function Zde(e) {
  return (e.scale || {}).getPointPositionForValue ? tfe(e) : efe(e);
function efe(e) {
  const { scale: t = {}, fill: n } = e, r = Ude(n, t);
  if (ys(r)) {
function tfe(e) {
  const { scale: t, fill: n } = e, r = t.options, o = t.getLabels().length, s = r.reverse ? t.max : t.min, a = Wde(n, t, s), c = [];
    return new S5({
function AP(e, t, n) {
  const r = Qde(t), { chart: o, index: s, line: a, scale: c, axis: f } = t, h = a.options, g = h.fill, v = h.backgroundColor, { above: w = v, below: C = v } = g || {}, T = o.getDatasetMeta(s), E = s5(o, T);
  r && a.points.length && (i1(e, n), nfe(e, {
  }), s1(e));
function nfe(e, t) {
  const { line: n, target: r, above: o, below: s, area: a, scale: c, clip: f } = t, h = n._loop ? "angle" : t.axis;
  s !== o && (h === "x" ? (pz(e, r, a.top), NP(e, {
    property: h,
  }), e.restore(), e.save(), pz(e, r, a.bottom)) : h === "y" && (hz(e, r, a.left), NP(e, {
    property: h,
  }), e.restore(), e.save(), hz(e, r, a.right), g = o)), NP(e, {
    property: h,
function pz(e, t, n) {
    const { start: f, end: h } = c, g = o[f], v = o[u1(f, h, o)];
    }), a ? e.closePath() : e.lineTo(v.x, n);
function hz(e, t, n) {
    const { start: f, end: h } = c, g = o[f], v = o[u1(f, h, o)];
    }), a ? e.closePath() : e.lineTo(n, v.y);
function NP(e, t) {
  const { line: n, target: r, property: o, color: s, scale: a, clip: c } = t, f = Fde(n, r, o);
  for (const { source: h, target: g, start: v, end: w } of f) {
    const { style: { backgroundColor: C = s } = {} } = h, T = r !== !0;
    e.save(), e.fillStyle = C, rfe(e, a, c, T && ZM(o, v, w)), e.beginPath();
    const E = !!n.pathSegment(e, h);
      E ? e.closePath() : mz(e, r, w, o);
      const P = !!r.pathSegment(e, g, {
      O = E && P, O || mz(e, r, v, o);
function rfe(e, t, n, r) {
    let f, h, g, v;
    s === "x" ? (f = a, h = o.top, g = c, v = o.bottom) : (f = o.left, h = a, g = o.right, v = c), e.beginPath(), n && (f = Math.max(f, n.left), g = Math.min(g, n.right), h = Math.max(h, n.top), v = Math.min(v, n.bottom)), e.rect(f, h, g - f, v - h), e.clip();
function mz(e, t, n, r) {
var ofe = {
      s = e.getDatasetMeta(a), c = s.dataset, f = null, c && c.options && c instanceof Wf && (f = {
        fill: Hde(c, a, r),
      f = o[a], !(!f || f.fill === !1) && (f.fill = Bde(o, a, n.propagate));
      c && (c.line.updateControlPoints(s, c.axis), r && c.fill && AP(e.ctx, c, s));
      fz(s) && AP(e.ctx, s, e.chartArea);
    !fz(r) || n.drawTime !== "beforeDatasetDraw" || AP(e.ctx, r, e.chartArea);
const gz = (e, t) => {
}, ife = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class vz extends Sy {
    let n = to(t.generateLabels, [
    const r = t.labels, o = aa(r.font), s = o.size, a = this._computeTitleHeight(), { boxWidth: c, itemHeight: f } = gz(r, s);
    let h, g;
    n.font = o.string, this.isHorizontal() ? (h = this.maxWidth, g = this._fitRows(a, s, c, f) + 10) : (g = this.maxHeight, h = this._fitCols(a, o, c, f) + 10), this.width = Math.min(h, t.maxWidth || this.maxWidth), this.height = Math.min(g, t.maxHeight || this.maxHeight);
    const { ctx: s, maxWidth: a, options: { labels: { padding: c } } } = this, f = this.legendHitBoxes = [], h = this.lineWidths = [
    let v = t;
      (E === 0 || h[h.length - 1] + O + 2 * c > a) && (v += g, h[h.length - (E > 0 ? 0 : 1)] = 0, C += g, w++), f[E] = {
      }, h[h.length - 1] += O + c;
    }), v;
    const { ctx: s, maxHeight: a, options: { labels: { padding: c } } } = this, f = this.legendHitBoxes = [], h = this.columnSizes = [], g = a - t;
    let v = c, w = 0, C = 0, T = 0, E = 0;
    return this.legendItems.forEach((O, P) => {
      const { itemWidth: I, itemHeight: M } = sfe(r, n, s, O, o);
      P > 0 && C + M + 2 * c > g && (v += w + c, h.push({
      }), T += w + c, E++, w = C = 0), f[P] = {
    }), v += w, h.push({
    }), v;
    const t = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: r, labels: { padding: o }, rtl: s } } = this, a = zv(s, this.left, this.width);
      let c = 0, f = Ra(r, this.left + o, this.right - this.lineWidths[c]);
      for (const h of n)
        c !== h.row && (c = h.row, f = Ra(r, this.left + o, this.right - this.lineWidths[c])), h.top += this.top + t + o, h.left = a.leftForLtr(a.x(f), h.width), f += h.width + o;
      let c = 0, f = Ra(r, this.top + t + o, this.bottom - this.columnSizes[c].height);
      for (const h of n)
        h.col !== c && (c = h.col, f = Ra(r, this.top + t + o, this.bottom - this.columnSizes[c].height)), h.top = f, h.left += this.left + o, h.left = a.leftForLtr(a.x(h.left), h.width), f += h.height + o;
      i1(t, this), this._draw(), s1(t);
    const { options: t, columnSizes: n, lineWidths: r, ctx: o } = this, { align: s, labels: a } = t, c = Fo.color, f = zv(t.rtl, this.left, this.width), h = aa(a.font), { padding: g } = a, v = h.size, w = v / 2;
    this.drawTitle(), o.textAlign = f.textAlign("left"), o.textBaseline = "middle", o.lineWidth = 0.5, o.font = h.string;
    const { boxWidth: T, boxHeight: E, itemHeight: O } = gz(a, v), P = function(j, B, H) {
      const F = Zn(H.lineWidth, 1);
      if (o.fillStyle = Zn(H.fillStyle, c), o.lineCap = Zn(H.lineCap, "butt"), o.lineDashOffset = Zn(H.lineDashOffset, 0), o.lineJoin = Zn(H.lineJoin, "miter"), o.lineWidth = F, o.strokeStyle = Zn(H.strokeStyle, c), o.setLineDash(Zn(H.lineDash, [])), a.usePointStyle) {
        const D = {
          pointStyle: H.pointStyle,
          rotation: H.rotation,
          borderWidth: F
        }, q = f.xPlus(j, T / 2), U = B + w;
        KU(o, D, q, U, a.pointStyleWidth && T);
        const D = B + Math.max((v - E) / 2, 0), q = f.leftForLtr(j, T), U = MS(H.borderRadius);
        o.beginPath(), Object.values(U).some((K) => K !== 0) ? YM(o, {
          y: D,
          radius: U
        }) : o.rect(q, D, T, E), o.fill(), F !== 0 && o.stroke();
    }, I = function(j, B, H) {
      n_(o, H.text, j, B + O / 2, h, {
        strikethrough: H.hidden,
        textAlign: f.textAlign(H.textAlign)
    }, M = this.isHorizontal(), A = this._computeTitleHeight();
      x: Ra(s, this.left + g, this.right - r[0]),
      y: this.top + g + A,
      y: Ra(s, this.top + A + g, this.bottom - n[0].height),
    }, t5(this.ctx, t.textDirection);
    const k = O + g;
    this.legendItems.forEach((j, B) => {
      o.strokeStyle = j.fontColor, o.fillStyle = j.fontColor;
      const H = o.measureText(j.text).width, F = f.textAlign(j.textAlign || (j.textAlign = a.textAlign)), D = T + w + H;
      let q = C.x, U = C.y;
      f.setWidth(this.width), M ? B > 0 && q + D + g > this.right && (U = C.y += k, C.line++, q = C.x = Ra(s, this.left + g, this.right - r[C.line])) : B > 0 && U + k > this.bottom && (q = C.x = q + n[C.line].width + g, C.line++, U = C.y = Ra(s, this.top + A + g, this.bottom - n[C.line].height));
      const K = f.x(q);
      if (P(K, U, j), q = iue(F, q + T + w, M ? q + D : this.right, t.rtl), I(f.x(q), U, j), M)
        C.x += D + g;
      else if (typeof j.text != "string") {
        const ee = h.lineHeight;
        C.y += C5(j, ee) + g;
        C.y += k;
    }), n5(this.ctx, t.textDirection);
    const t = this.options, n = t.title, r = aa(n.font), o = Su(n.padding);
    const s = zv(t.rtl, this.left, this.width), a = this.ctx, c = n.position, f = r.size / 2, h = o.top + f;
    let g, v = this.left, w = this.width;
      w = Math.max(...this.lineWidths), g = this.top + h, v = Ra(t.align, v, this.right - w);
      g = h + Ra(t.align, this.top, this.bottom - T - t.labels.padding - this._computeTitleHeight());
    const C = Ra(c, v, v + w);
    a.textAlign = s.textAlign(WU(c)), a.textBaseline = "middle", a.strokeStyle = n.color, a.fillStyle = n.color, a.font = r.string, n_(a, n.text, C, g, r);
    const t = this.options.title, n = aa(t.font), r = Su(t.padding);
    if (Pv(t, this.left, this.right) && Pv(n, this.top, this.bottom)) {
        if (o = s[r], Pv(t, o.left, o.left + o.width) && Pv(n, o.top, o.top + o.height))
    if (!ufe(t.type, n))
      const o = this._hoveredItem, s = ife(o, r);
      o && !s && to(n.onLeave, [
      ], this), this._hoveredItem = r, r && !s && to(n.onHover, [
    } else r && to(n.onClick, [
function sfe(e, t, n, r, o) {
  const s = afe(r, e, t, n), a = lfe(o, r, t.lineHeight);
function afe(e, t, n, r) {
function lfe(e, t, n) {
  return typeof t.text != "string" && (r = C5(t, n)), r;
function C5(e, t) {
function ufe(e, t) {
var cfe = {
  _element: vz,
    const r = e.legend = new vz({
    Uf.configure(e, r, n), Uf.addBox(e, r);
    Uf.removeBox(e, e.legend), delete e.legend;
    Uf.configure(e, r, n), r.options = n;
          const h = f.controller.getStyle(n ? 0 : void 0), g = Su(h.borderWidth);
            fillStyle: h.backgroundColor,
            lineCap: h.borderCapStyle,
            lineDash: h.borderDash,
            lineDashOffset: h.borderDashOffset,
            lineJoin: h.borderJoinStyle,
            strokeStyle: h.borderColor,
            pointStyle: r || h.pointStyle,
            rotation: h.rotation,
            textAlign: o || h.textAlign,
            borderRadius: a && (c || h.borderRadius),
const mS = {
        const h = f.getCenterPoint(), g = WM(t, h);
function ac(e, t) {
  return t && (Oi(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
function wd(e) {
function dfe(e, t) {
function yz(e, t) {
  const n = e.chart.ctx, { body: r, footer: o, title: s } = e, { boxWidth: a, boxHeight: c } = t, f = aa(t.bodyFont), h = aa(t.titleFont), g = aa(t.footerFont), v = s.length, w = o.length, C = r.length, T = Su(t.padding);
  let E = T.height, O = 0, P = r.reduce((A, k) => A + k.before.length + k.lines.length + k.after.length, 0);
  if (P += e.beforeBody.length + e.afterBody.length, v && (E += v * h.lineHeight + (v - 1) * t.titleSpacing + t.titleMarginBottom), P) {
    const A = t.displayColors ? Math.max(c, f.lineHeight) : f.lineHeight;
    E += C * A + (P - C) * f.lineHeight + (P - 1) * t.bodySpacing;
  const M = function(A) {
    O = Math.max(O, n.measureText(A).width + I);
  return n.save(), n.font = h.string, Mr(e.title, M), n.font = f.string, Mr(e.beforeBody.concat(e.afterBody), M), I = t.displayColors ? a + 2 + t.boxPadding : 0, Mr(r, (A) => {
    Mr(A.before, M), Mr(A.lines, M), Mr(A.after, M);
  }), I = 0, n.font = g.string, Mr(e.footer, M), n.restore(), O += T.width, {
function ffe(e, t) {
function pfe(e, t, n, r) {
function hfe(e, t, n, r) {
  let h = "center";
  return r === "center" ? h = o <= (c + f) / 2 ? "left" : "right" : o <= s / 2 ? h = "left" : o >= a - s / 2 && (h = "right"), pfe(h, e, t, n) && (h = "center"), h;
function bz(e, t, n) {
  const r = n.yAlign || t.yAlign || ffe(e, n);
    xAlign: n.xAlign || t.xAlign || hfe(e, t, n, r),
function mfe(e, t) {
function gfe(e, t, n) {
function wz(e, t, n, r) {
  const { caretSize: o, caretPadding: s, cornerRadius: a } = e, { xAlign: c, yAlign: f } = n, h = o + s, { topLeft: g, topRight: v, bottomLeft: w, bottomRight: C } = MS(a);
  let T = mfe(t, c);
  const E = gfe(t, f, h);
  return f === "center" ? c === "left" ? T += h : c === "right" && (T -= h) : c === "left" ? T -= Math.max(g, w) + o : c === "right" && (T += Math.max(v, C) + o), {
    x: mc(T, 0, r.width - t.width),
    y: mc(E, 0, r.height - t.height)
function oT(e, t, n) {
  const r = Su(n.padding);
function Sz(e) {
  return ac([], wd(e));
function vfe(e, t, n) {
  return wm(e, {
function Cz(e, t) {
const x5 = {
  beforeTitle: yd,
  afterTitle: yd,
  beforeBody: yd,
  beforeLabel: yd,
    return ho(n) || (t += n), t;
  afterLabel: yd,
  afterBody: yd,
  beforeFooter: yd,
  footer: yd,
  afterFooter: yd
function ra(e, t, n, r) {
  return typeof o > "u" ? x5[t].call(n, r) : o;
class eI extends Sy {
    const n = this.chart, r = this.options.setContext(this.getContext()), o = r.enabled && n.options.animation && r.animations, s = new a5(this.chart, o);
    return this.$context || (this.$context = vfe(this.chart.getContext(), this, this._tooltipItems));
    const { callbacks: r } = n, o = ra(r, "beforeTitle", this, t), s = ra(r, "title", this, t), a = ra(r, "afterTitle", this, t);
    return c = ac(c, wd(o)), c = ac(c, wd(s)), c = ac(c, wd(a)), c;
    return Sz(ra(n.callbacks, "beforeBody", this, t));
    return Mr(t, (s) => {
      }, c = Cz(r, s);
      ac(a.before, wd(ra(c, "beforeLabel", this, s))), ac(a.lines, ra(c, "label", this, s)), ac(a.after, wd(ra(c, "afterLabel", this, s))), o.push(a);
    return Sz(ra(n.callbacks, "afterBody", this, t));
    const { callbacks: r } = n, o = ra(r, "beforeFooter", this, t), s = ra(r, "footer", this, t), a = ra(r, "afterFooter", this, t);
    return c = ac(c, wd(o)), c = ac(c, wd(s)), c = ac(c, wd(a)), c;
    let c = [], f, h;
    for (f = 0, h = n.length; f < h; ++f)
      c.push(dfe(this.chart, n[f]));
    return t.filter && (c = c.filter((g, v, w) => t.filter(g, v, w, r))), t.itemSort && (c = c.sort((g, v) => t.itemSort(g, v, r))), Mr(c, (g) => {
      const v = Cz(t.callbacks, g);
      o.push(ra(v, "labelColor", this, g)), s.push(ra(v, "labelPointStyle", this, g)), a.push(ra(v, "labelTextColor", this, g));
      const c = mS[r.position].call(this, o, this._eventPosition);
      const f = this._size = yz(this, r), h = Object.assign({}, c, f), g = bz(this.chart, r, h), v = wz(r, h, g, this.chart);
        x: v.x,
        y: v.y,
    const { xAlign: o, yAlign: s } = this, { caretSize: a, cornerRadius: c } = r, { topLeft: f, topRight: h, bottomLeft: g, bottomRight: v } = MS(c), { x: w, y: C } = t, { width: T, height: E } = n;
    let O, P, I, M, A, k;
    return s === "center" ? (A = C + E / 2, o === "left" ? (O = w, P = O - a, M = A + a, k = A - a) : (O = w + T, P = O + a, M = A - a, k = A + a), I = O) : (o === "left" ? P = w + Math.max(f, g) + a : o === "right" ? P = w + T - Math.max(h, v) - a : P = this.caretX, s === "top" ? (M = C, A = M - a, O = P - a, I = P + a) : (M = C + E, A = M + a, O = P + a, I = P - a), k = M), {
      x2: P,
      y2: A,
      y3: k
      const h = zv(r.rtl, this.x, this.width);
      for (t.x = oT(this, r.titleAlign, r), n.textAlign = h.textAlign(r.titleAlign), n.textBaseline = "middle", a = aa(r.titleFont), c = r.titleSpacing, n.fillStyle = r.titleColor, n.font = a.string, f = 0; f < s; ++f)
        n.fillText(o[f], h.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + c, f + 1 === s && (t.y += r.titleMarginBottom - c);
    const a = this.labelColors[r], c = this.labelPointStyles[r], { boxHeight: f, boxWidth: h } = s, g = aa(s.bodyFont), v = oT(this, "left", s), w = o.x(v), C = f < g.lineHeight ? (g.lineHeight - f) / 2 : 0, T = n.y + C;
        radius: Math.min(h, f) / 2,
      }, O = o.leftForLtr(w, h) + h / 2, P = T + f / 2;
      t.strokeStyle = s.multiKeyBackground, t.fillStyle = s.multiKeyBackground, KM(t, E, O, P), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, KM(t, E, O, P);
      t.lineWidth = sr(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;
      const E = o.leftForLtr(w, h), O = o.leftForLtr(o.xPlus(w, 1), h - 2), P = MS(a.borderRadius);
      Object.values(P).some((I) => I !== 0) ? (t.beginPath(), t.fillStyle = s.multiKeyBackground, YM(t, {
        w: h,
        radius: P
      }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), YM(t, {
        w: h - 2,
        radius: P
      }), t.fill()) : (t.fillStyle = s.multiKeyBackground, t.fillRect(E, T, h, f), t.strokeRect(E, T, h, f), t.fillStyle = a.backgroundColor, t.fillRect(O, T + 1, h - 2, f - 2));
    const { body: o } = this, { bodySpacing: s, bodyAlign: a, displayColors: c, boxHeight: f, boxWidth: h, boxPadding: g } = r, v = aa(r.bodyFont);
    let w = v.lineHeight, C = 0;
    const T = zv(r.rtl, this.x, this.width), E = function(H) {
      n.fillText(H, T.x(t.x + C), t.y + w / 2), t.y += w + s;
    let P, I, M, A, k, j, B;
    for (n.textAlign = a, n.textBaseline = "middle", n.font = v.string, t.x = oT(this, O, r), n.fillStyle = r.bodyColor, Mr(this.beforeBody, E), C = c && O !== "right" ? a === "center" ? h / 2 + g : h + 2 + g : 0, A = 0, j = o.length; A < j; ++A) {
      for (P = o[A], I = this.labelTextColors[A], n.fillStyle = I, Mr(P.before, E), M = P.lines, c && M.length && (this._drawColorBox(n, t, A, T, r), w = Math.max(v.lineHeight, f)), k = 0, B = M.length; k < B; ++k)
        E(M[k]), w = v.lineHeight;
      Mr(P.after, E);
    C = 0, w = v.lineHeight, Mr(this.afterBody, E), t.y -= s;
      const f = zv(r.rtl, this.x, this.width);
      for (t.x = oT(this, r.footerAlign, r), t.y += r.footerMarginTop, n.textAlign = f.textAlign(r.footerAlign), n.textBaseline = "middle", a = aa(r.footerFont), n.fillStyle = r.footerColor, n.font = a.string, c = 0; c < s; ++c)
    const { xAlign: s, yAlign: a } = this, { x: c, y: f } = t, { width: h, height: g } = r, { topLeft: v, topRight: w, bottomLeft: C, bottomRight: T } = MS(o.cornerRadius);
    n.fillStyle = o.backgroundColor, n.strokeStyle = o.borderColor, n.lineWidth = o.borderWidth, n.beginPath(), n.moveTo(c + v, f), a === "top" && this.drawCaret(t, n, r, o), n.lineTo(c + h - w, f), n.quadraticCurveTo(c + h, f, c + h, f + w), a === "center" && s === "right" && this.drawCaret(t, n, r, o), n.lineTo(c + h, f + g - T), n.quadraticCurveTo(c + h, f + g, c + h - T, f + g), a === "bottom" && this.drawCaret(t, n, r, o), n.lineTo(c + C, f + g), n.quadraticCurveTo(c, f + g, c, f + g - C), a === "center" && s === "left" && this.drawCaret(t, n, r, o), n.lineTo(c, f + v), n.quadraticCurveTo(c, f, c + v, f), n.closePath(), n.fill(), o.borderWidth > 0 && n.stroke();
      const a = mS[t.position].call(this, this._active, this._eventPosition);
      const c = this._size = yz(this, t), f = Object.assign({}, a, this._size), h = bz(n, t, f), g = wz(t, f, h, n);
      (o._to !== g.x || s._to !== g.y) && (this.xAlign = h.xAlign, this.yAlign = h.yAlign, this.width = c.width, this.height = c.height, this.caretX = a.x, this.caretY = a.y, this._resolveAnimations().update(this, g));
    const a = Su(n.padding), c = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    n.enabled && c && (t.save(), t.globalAlpha = r, this.drawBackground(s, t, o, n), t5(t, n.textDirection), s.y += a.top, this.drawTitle(s, t, n), this.drawBody(s, t, n), this.drawFooter(s, t, n), n5(t, n.textDirection), t.restore());
      const h = this.chart.getDatasetMeta(c);
      if (!h)
        element: h.data[f],
    }), s = !XT(r, o), a = this._positionChanged(o, n);
    const o = this.options, s = this._active || [], a = this._getActiveElements(t, s, n, r), c = this._positionChanged(a, t), f = n || !XT(a, s) || c;
    const { caretX: r, caretY: o, options: s } = this, a = mS[s.position].call(this, t, n);
Nn(eI, "positioners", mS);
var yfe = {
  _element: eI,
  positioners: mS,
    n && (e.tooltip = new eI({
    callbacks: x5
const bfe = (e, t, n, r) => (typeof t == "string" ? (n = e.push(t) - 1, r.unshift({
function wfe(e, t, n, r) {
    return bfe(e, t, n, r);
const Sfe = (e, t) => e === null ? null : mc(Math.round(e), 0, t);
function xz(e) {
class tI extends Cy {
    if (ho(t))
    return n = isFinite(n) && r[n] === t ? n : wfe(r, t, Zn(n, t), this._addedLabels), Sfe(n, r.length - 1);
    return xz.call(this, t);
Nn(tI, "id", "category"), Nn(tI, "defaults", {
    callback: xz
function Cfe(e, t) {
  const n = [], { bounds: o, step: s, min: a, max: c, precision: f, count: h, maxTicks: g, maxDigits: v, includeBounds: w } = e, C = s || 1, T = g - 1, { min: E, max: O } = t, P = !ho(a), I = !ho(c), M = !ho(h), A = (O - E) / (v + 1);
  let k = x2((O - E) / T / C) * C, j, B, H, F;
  if (k < 1e-14 && !P && !I)
  F = Math.ceil(O / k) - Math.floor(E / k), F > T && (k = x2(F * k / T / C) * C), ho(f) || (j = Math.pow(10, f), k = Math.ceil(k * j) / j), o === "ticks" ? (B = Math.floor(E / k) * k, H = Math.ceil(O / k) * k) : (B = E, H = O), P && I && s && Kle((c - a) / s, k / 1e3) ? (F = Math.round(Math.min((c - a) / k, g)), k = (c - a) / F, B = a, H = c) : M ? (B = P ? a : B, H = I ? c : H, F = h - 1, k = (H - B) / F) : (F = (H - B) / k, RS(F, Math.round(F), k / 1e3) ? F = Math.round(F) : F = Math.ceil(F));
  const D = Math.max(E2(k), E2(B));
  j = Math.pow(10, ho(f) ? D : f), B = Math.round(B * j) / j, H = Math.round(H * j) / j;
  for (P && (w && B !== a ? (n.push({
  }), B < a && q++, RS(Math.round((B + q * k) * j) / j, a, Ez(a, A, e)) && q++) : B < a && q++); q < F; ++q) {
    const U = Math.round((B + q * k) * j) / j;
    if (I && U > c)
      value: U
  return I && w && H !== c ? n.length && RS(n[n.length - 1].value, c, Ez(c, A, e)) ? n[n.length - 1].value = c : n.push({
  }) : (!I || H === c) && n.push({
    value: H
function Ez(e, t, { horizontal: n, minRotation: r }) {
  const o = Jh(r), s = (n ? Math.sin(o) : Math.cos(o)) || 1e-3, a = 0.75 * t * ("" + e).length;
class xfe extends Cy {
    return ho(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
      const f = ry(o), h = ry(s);
      f < 0 && h < 0 ? c(0) : f > 0 && h > 0 && a(0);
    }, s = this._range || this, a = Cfe(o, s);
    return t.bounds === "ticks" && Yle(a, this, "value"), t.reverse ? (a.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), a;
    return GU(t, this.chart.options.locale, this.options.ticks.format);
class nI extends xfe {
    this.min = ys(t) ? t : 0, this.max = ys(n) ? n : 1, this.handleTickRangeOptions();
    const t = this.isHorizontal(), n = t ? this.width : this.height, r = Jh(this.options.ticks.minRotation), o = (t ? Math.sin(r) : Math.cos(r)) || 1e-3, s = this._resolveTickFontOptions(0);
Nn(nI, "id", "linear"), Nn(nI, "defaults", {
    callback: qU.formatters.numeric
const c1 = {
}, sa = /* @__PURE__ */ Object.keys(c1);
function Tz(e, t) {
function _z(e, t) {
  if (ho(t))
  return typeof r == "function" && (a = r(a)), ys(a) || (a = typeof r == "string" ? n.parse(a, r) : n.parse(a)), a === null ? null : (o && (a = o === "week" && (t_(s) || s === !0) ? n.startOf(a, "isoWeek", s) : n.startOf(a, o)), +a);
function Oz(e, t, n, r) {
  const o = sa.length;
  for (let s = sa.indexOf(e); s < o - 1; ++s) {
    const a = c1[sa[s]], c = a.steps ? a.steps : Number.MAX_SAFE_INTEGER;
      return sa[s];
  return sa[o - 1];
function Efe(e, t, n, r, o) {
  for (let s = sa.length - 1; s >= sa.indexOf(n); s--) {
    const a = sa[s];
    if (c1[a].common && e._adapter.diff(o, r, a) >= t - 1)
  return sa[n ? sa.indexOf(n) : 0];
function Tfe(e) {
  for (let t = sa.indexOf(e) + 1, n = sa.length; t < n; ++t)
    if (c1[sa[t]].common)
      return sa[t];
function Rz(e, t, n) {
    const { lo: r, hi: o } = OD(n, t), s = n[r] >= t ? n[r] : n[o];
function _fe(e, t, n, r) {
function kz(e, t, n) {
  return s === 0 || !n ? r : _fe(e, r, o, n);
class i_ extends Cy {
    const r = t.time || (t.time = {}), o = this._adapter = new Sce._date(t.adapters.date);
    o.init(n), OS(r.displayFormats, o.formats()), this._parseOpts = {
    return t === void 0 ? null : _z(this, t);
    function f(h) {
      !a && !isNaN(h.min) && (o = Math.min(o, h.min)), !c && !isNaN(h.max) && (s = Math.max(s, h.max));
    (!a || !c) && (f(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && f(this.getMinMax(!1))), o = ys(o) && !isNaN(o) ? o : +n.startOf(Date.now(), r), s = ys(s) && !isNaN(s) ? s : +n.endOf(Date.now(), r) + 1, this.min = Math.min(o, s - 1), this.max = Math.max(o + 1, s);
    const s = this.min, a = this.max, c = tue(o, s, a);
    return this._unit = n.unit || (r.autoSkip ? Oz(n.minUnit, this.min, this.max, this._getLabelCapacity(s)) : Efe(this, c.length, n.minUnit, this.min, this.max)), this._majorUnit = !r.major.enabled || this._unit === "year" ? void 0 : Tfe(this._unit), this.initOffsets(o), t.reverse && c.reverse(), kz(this, c, this._majorUnit);
    n = mc(n, 0, a), r = mc(r, 0, a), this._offsets = {
    const t = this._adapter, n = this.min, r = this.max, o = this.options, s = o.time, a = s.unit || Oz(s.minUnit, n, r, this._getLabelCapacity(n)), c = Zn(o.ticks.stepSize, 1), f = a === "week" ? s.isoWeekday : !1, h = t_(f) || f === !0, g = {};
    let v = n, w, C;
    if (h && (v = +t.startOf(v, "isoWeek", f)), v = +t.startOf(v, h ? "day" : a), t.diff(r, n, a) > 1e5 * c)
    for (w = v, C = 0; w < r; w = +t.add(w, c, a), C++)
      Rz(g, w, T);
    return (w === r || o.bounds === "ticks" || C === 1) && Rz(g, w, T), Object.keys(g).sort(Tz).map((E) => +E);
      return to(a, [
    const c = s.time.displayFormats, f = this._unit, h = this._majorUnit, g = f && c[f], v = h && c[h], w = r[n], C = h && v && w && w.major;
    return this._adapter.format(t, o || (C ? v : g));
    const n = this.options.ticks, r = this.ctx.measureText(t).width, o = Jh(this.isHorizontal() ? n.maxRotation : n.minRotation), s = Math.cos(o), a = Math.sin(o), c = this._resolveTickFontOptions(0).size;
    const n = this.options.time, r = n.displayFormats, o = r[n.unit] || r.millisecond, s = this._tickFormatFunction(t, 0, kz(this, [
      t.push(_z(this, o[n]));
    return rue(t.sort(Tz));
Nn(i_, "id", "time"), Nn(i_, "defaults", {
function iT(e, t, n) {
  n ? (t >= e[r].pos && t <= e[o].pos && ({ lo: r, hi: o } = GM(e, "pos", t)), { pos: s, time: c } = e[r], { pos: a, time: f } = e[o]) : (t >= e[r].time && t <= e[o].time && ({ lo: r, hi: o } = GM(e, "time", t)), { time: s, pos: c } = e[r], { time: a, pos: f } = e[o]);
  const h = a - s;
  return h ? c + (f - c) * (t - s) / h : c;
class Pz extends i_ {
    this._minPos = iT(n, this.min), this._tableRange = iT(n, this.max) - this._minPos, super.initOffsets(t);
    let a, c, f, h, g;
      h = t[a], h >= n && h <= r && o.push(h);
      g = o[a + 1], f = o[a - 1], h = o[a], Math.round((g + f) / 2) !== h && s.push({
        time: h,
    return (iT(this._table, t) - this._minPos) / this._tableRange;
    return iT(this._table, r * this._tableRange + this._minPos, !0);
Nn(Pz, "id", "timeseries"), Nn(Pz, "defaults", i_.defaults);
Ed.register(tI, nI, CT, Wf, yfe, ofe, cfe);
function E5({ data: e }) {
  const t = x.useRef(null), n = x.useRef(null), r = za(), o = rn(r.palette.background.paper, 0.64), s = rn(r.palette.primary.main, 0.16);
    const a = r.palette.primary.main, c = rn(a, 0.2);
      return n.current && n.current.destroy(), n.current = new Ed(t.current, {
          labels: e.map((f) => f.date),
              data: e.map((f) => f.amount),
              borderColor: a,
              backgroundColor: c,
                callback: (f) => `$${f}`
        var f;
        (f = n.current) == null || f.destroy();
  }, [e, r]), /* @__PURE__ */ $.jsx(
    uD,
    {
      elevation: 0,
      sx: {
        borderRadius: 3,
        border: "1px solid",
        borderColor: s,
        backgroundColor: o,
        backdropFilter: "blur(6px)"
      },
      children: /* @__PURE__ */ $.jsxs(cD, { sx: { height: 360 }, children: [
        /* @__PURE__ */ $.jsx(un, { variant: "h6", fontWeight: 600, mb: 2, children: "Monthly revenue" }),
        /* @__PURE__ */ $.jsx("canvas", { ref: t })
      ] })
    }
  );
const ND = /* @__PURE__ */ x.createContext(void 0);
process.env.NODE_ENV !== "production" && (ND.displayName = "GridApiContext");
function kn() {
  const e = x.useContext(ND);
const $D = /* @__PURE__ */ x.createContext(void 0);
process.env.NODE_ENV !== "production" && ($D.displayName = "GridRootPropsContext");
const $t = () => {
  const e = x.useContext($D);
}, Ofe = parseInt(x.version, 10), Qn = (e) => {
  if (Ofe >= 19) {
function T5(e, ...t) {
function Rfe(e, t) {
  const n = MT(e, t);
function kfe(e, t) {
const Mz = [];
function lm(e) {
  return Mz[0] = e, py(Mz);
function Gh(e) {
function _5(e) {
  if (/* @__PURE__ */ x.isValidElement(e) || wu.isValidElementType(e) || !Gh(e))
    t[n] = _5(e[n]);
function s_(e, t, n = {
  return Gh(e) && Gh(t) && Object.keys(t).forEach((o) => {
    /* @__PURE__ */ x.isValidElement(t[o]) || wu.isValidElementType(t[o]) ? r[o] = t[o] : Gh(t[o]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, o) && Gh(e[o]) ? r[o] = s_(e[o], t[o], n) : n.clone ? r[o] = Gh(t[o]) ? _5(t[o]) : t[o] : r[o] = t[o];
const Pfe = (e) => {
function Mfe(e) {
  } = e, s = Pfe(t), a = Object.keys(s);
  function h(w, C) {
    return a.indexOf(w) + 1 < a.length ? h(w, a[a.indexOf(w) + 1]) : c(w);
  function v(w) {
    return C === 0 ? c(a[1]) : C === a.length - 1 ? f(a[C]) : h(w, a[a.indexOf(w) + 1]).replace("@media", "@media not all and");
    between: h,
    not: v,
function Iz(e, t) {
function Ife(e, t) {
function Dfe(e, t) {
For example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.` : T5(18, `(${t})`));
function Afe(e) {
const Nfe = {
}, fp = process.env.NODE_ENV !== "production" ? u.oneOfType([u.number, u.string, u.object, u.array]) : {};
function IS(e, t) {
  return t ? s_(e, t, {
const d1 = {
}, Dz = {
  up: (e) => `@media (min-width:${d1[e]}px)`
}, $fe = {
      let n = typeof t == "number" ? t : d1[t] || t;
function Pd(e, t, n) {
    const s = r.breakpoints || Dz;
    const s = r.breakpoints || Dz;
      if (Ife(s.keys, c)) {
        const f = Dfe(r.containerQueries ? r : $fe, c);
      } else if (Object.keys(s.values || d1).includes(c)) {
function Lfe(e = {}) {
function Az(e, t) {
function LD(e) {
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : T5(7));
function f1(e, t, n = !0) {
function a_(e, t, n, r = n) {
  return typeof e == "function" ? o = e(n) : Array.isArray(e) ? o = e[n] || r : o = f1(e, n) || r, t && (o = t(o, r, e)), o;
function Bo(e) {
    const c = a[t], f = a.theme, h = f1(f, r) || {};
    return Pd(a, c, (v) => {
      let w = a_(h, o, v);
      return v === w && typeof v == "string" && (w = a_(h, o, `${t}${v === "default" ? "" : LD(v)}`, v)), n === !1 ? w : {
    [t]: fp
function jfe(e) {
const Ffe = {
}, zfe = {
}, Nz = {
}, Bfe = jfe((e) => {
    if (Nz[e])
      e = Nz[e];
  const [t, n] = e.split(""), r = Ffe[t], o = zfe[n] || "";
}), p1 = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], h1 = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], Hfe = [...p1, ...h1];
function _C(e, t, n, r) {
  const o = f1(e, t, !0) ?? n;
function O5(e) {
  return _C(e, "spacing", 8, "spacing");
function OC(e, t) {
function Vfe(e, t) {
  return (n) => e.reduce((r, o) => (r[o] = OC(t, n), r), {});
function Ufe(e, t, n, r) {
  const o = Bfe(n), s = Vfe(o, r), a = e[n];
  return Pd(e, a, s);
function R5(e, t) {
  const n = O5(e.theme);
  return Object.keys(e).map((r) => Ufe(e, t, r, n)).reduce(IS, {});
function Ro(e) {
  return R5(e, p1);
Ro.propTypes = process.env.NODE_ENV !== "production" ? p1.reduce((e, t) => (e[t] = fp, e), {}) : {};
Ro.filterProps = p1;
function ko(e) {
  return R5(e, h1);
ko.propTypes = process.env.NODE_ENV !== "production" ? h1.reduce((e, t) => (e[t] = fp, e), {}) : {};
ko.filterProps = h1;
process.env.NODE_ENV !== "production" && Hfe.reduce((e, t) => (e[t] = fp, e), {});
function Wfe(e = 8, t = O5({
function m1(...e) {
  }), r), {}), n = (r) => Object.keys(r).reduce((o, s) => t[s] ? IS(o, t[s](r)) : o, {});
function vl(e) {
function Il(e, t) {
  return Bo({
const Gfe = Il("border", vl), qfe = Il("borderTop", vl), Kfe = Il("borderRight", vl), Yfe = Il("borderBottom", vl), Xfe = Il("borderLeft", vl), Qfe = Il("borderColor"), Jfe = Il("borderTopColor"), Zfe = Il("borderRightColor"), epe = Il("borderBottomColor"), tpe = Il("borderLeftColor"), npe = Il("outline", vl), rpe = Il("outlineColor"), g1 = (e) => {
    const t = _C(e.theme, "shape.borderRadius", 4, "borderRadius"), n = (r) => ({
      borderRadius: OC(t, r)
    return Pd(e, e.borderRadius, n);
g1.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: fp
g1.filterProps = ["borderRadius"];
m1(Gfe, qfe, Kfe, Yfe, Xfe, Qfe, Jfe, Zfe, epe, tpe, g1, npe, rpe);
const v1 = (e) => {
    const t = _C(e.theme, "spacing", 8, "gap"), n = (r) => ({
      gap: OC(t, r)
    return Pd(e, e.gap, n);
v1.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: fp
v1.filterProps = ["gap"];
const y1 = (e) => {
    const t = _C(e.theme, "spacing", 8, "columnGap"), n = (r) => ({
      columnGap: OC(t, r)
    return Pd(e, e.columnGap, n);
y1.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: fp
y1.filterProps = ["columnGap"];
const b1 = (e) => {
    const t = _C(e.theme, "spacing", 8, "rowGap"), n = (r) => ({
      rowGap: OC(t, r)
    return Pd(e, e.rowGap, n);
b1.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: fp
b1.filterProps = ["rowGap"];
const ope = Bo({
}), ipe = Bo({
}), spe = Bo({
}), ape = Bo({
}), lpe = Bo({
}), upe = Bo({
}), cpe = Bo({
}), dpe = Bo({
}), fpe = Bo({
m1(v1, y1, b1, ope, ipe, spe, ape, lpe, upe, cpe, dpe, fpe);
function Bv(e, t) {
const ppe = Bo({
  transform: Bv
}), hpe = Bo({
  transform: Bv
}), mpe = Bo({
  transform: Bv
m1(ppe, hpe, mpe);
function Da(e) {
const gpe = Bo({
  transform: Da
}), jD = (e) => {
      const r = ((a = (s = (o = e.theme) == null ? void 0 : o.breakpoints) == null ? void 0 : s.values) == null ? void 0 : a[n]) || d1[n];
        maxWidth: Da(n)
    return Pd(e, e.maxWidth, t);
jD.filterProps = ["maxWidth"];
const vpe = Bo({
  transform: Da
}), ype = Bo({
  transform: Da
}), bpe = Bo({
  transform: Da
}), wpe = Bo({
  transform: Da
Bo({
  transform: Da
Bo({
  transform: Da
const Spe = Bo({
m1(gpe, jD, vpe, ype, bpe, wpe, Spe);
const k5 = {
    transform: vl
    transform: vl
    transform: vl
    transform: vl
    transform: vl
    transform: vl
    style: g1
    transform: Bv
    transform: Bv
    transform: Bv
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: ko
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: Ro
    style: v1
    style: b1
    style: y1
    transform: Da
    style: jD
    transform: Da
    transform: Da
    transform: Da
    transform: Da
function Cpe(...e) {
function xpe(e, t) {
function Epe() {
      themeKey: h,
      style: v
    if (h === "typography" && r === "inherit")
    const w = f1(o, h) || {};
    return v ? v(a) : Pd(a, r, (T) => {
      let E = a_(w, g, T);
      return T === E && typeof T == "string" && (E = a_(w, g, `${n}${T === "default" ? "" : LD(T)}`, T)), f === !1 ? E : {
    const a = o.unstable_sxConfig ?? k5;
      let h = f;
        h = f(o);
      if (!h)
      const g = Lfe(o.breakpoints), v = Object.keys(g);
      return Object.keys(h).forEach((C) => {
        const T = xpe(h[C], o);
              w = IS(w, e(C, T, o, a));
              const E = Pd({
              Cpe(E, T) ? w[C] = t({
              }) : w = IS(w, E);
            w = IS(w, e(C, T, o, a));
        "@layer sx": Iz(o, Az(v, w))
      } : Iz(o, Az(v, w));
const l_ = Epe();
l_.filterProps = ["sx"];
function Tpe(e, t) {
function _pe(e = {}, ...t) {
  } = e, c = Mfe(n), f = Wfe(o);
  let h = s_({
      ...Nfe,
  return h = Afe(h), h.applyStyles = Tpe, h = t.reduce((g, v) => s_(g, v), h), h.unstable_sxConfig = {
    ...k5,
  }, h.unstable_sx = function(v) {
    return l_({
      sx: v,
  }, h;
function P5(e, t = "") {
function $z(e, t, n) {
  const r = P5(t);
function Ope(e) {
      return P5(e, "Component");
        case wu.ForwardRef:
          return $z(e, e.render, "ForwardRef");
        case wu.Memo:
          return $z(e, e.type, "memo");
function Rpe(e) {
    style: lm(n),
    typeof o.style != "function" && (o.style = lm(o.style));
const kpe = _pe();
function $P(e) {
function Zh(e, t) {
function Ppe(e) {
function Mpe(e, t, n) {
  e.theme = Npe(e.theme) ? n : e.theme[t] || e.theme;
function xT(e, t, n) {
    return r.flatMap((o) => xT(e, o, n));
      o = n ? Zh(r.style, n) : r.style;
      o = n ? Zh(lm(a), n) : a;
    return M5(e, r.variants, [o], n);
  return r != null && r.isProcessed ? n ? Zh(lm(r.style), n) : r.style : n ? Zh(lm(r), n) : r;
function M5(e, t, n = [], r = void 0) {
    }), n.push(r ? Zh(lm(c.style(o)), r) : c.style(o))) : n.push(r ? Zh(lm(c.style), r) : c.style);
function Ipe(e = {}) {
    defaultTheme: n = kpe,
    rootShouldForwardProp: r = $P,
    slotShouldForwardProp: o = $P
    Mpe(c, t, n);
    kfe(c, (j) => j.filter((B) => B !== l_));
      name: h,
      skipVariantsResolver: v,
      overridesResolver: C = Ppe(I5(g)),
    } = f, E = h && h.startsWith("Mui") || g ? "components" : "custom", O = v !== void 0 ? v : (
    ), P = w || !1;
    let I = $P;
    g === "Root" || g === "root" ? I = r : g ? I = o : $pe(c) && (I = void 0);
    const M = Rfe(c, {
      label: Ape(h, g),
    }), A = (j) => {
      if (j.__emotion_real === j)
        return j;
      if (typeof j == "function")
        return function(H) {
          return xT(H, j, H.theme.modularCssLayers ? E : void 0);
      if (Gh(j)) {
        const B = Rpe(j);
        return function(F) {
          return B.variants ? xT(F, B, F.theme.modularCssLayers ? E : void 0) : F.theme.modularCssLayers ? Zh(B.style, E) : B.style;
      return j;
    }, k = (...j) => {
      const B = [], H = j.map(A), F = [];
      if (B.push(s), h && C && F.push(function(K) {
        const G = (te = (X = K.theme.components) == null ? void 0 : X[h]) == null ? void 0 : te.styleOverrides;
        const Y = {};
          Y[re] = xT(K, G[re], K.theme.modularCssLayers ? "theme" : void 0);
        return C(K, Y);
      }), h && !O && F.push(function(K) {
        var Y, X;
        const ee = K.theme, G = (X = (Y = ee == null ? void 0 : ee.components) == null ? void 0 : Y[h]) == null ? void 0 : X.variants;
        return G ? M5(K, G, [], K.theme.modularCssLayers ? "theme" : void 0) : null;
      }), P || F.push(l_), Array.isArray(H[0])) {
        const U = H.shift(), K = new Array(B.length).fill(""), ee = new Array(F.length).fill("");
        G = [...K, ...U, ...ee], G.raw = [...K, ...U.raw, ...ee], B.unshift(G);
      const D = [...B, ...H, ...F], q = M(...D);
      return c.muiName && (q.muiName = c.muiName), process.env.NODE_ENV !== "production" && (q.displayName = Dpe(h, g, c)), q;
    return M.withConfig && (k.withConfig = M.withConfig), k;
function Dpe(e, t, n) {
  return e ? `${e}${LD(t || "")}` : `Styled(${Ope(n)})`;
function Ape(e, t) {
  return process.env.NODE_ENV !== "production" && e && (n = `${e}-${I5(t || "Root")}`), n;
function Npe(e) {
function $pe(e) {
function I5(e) {
const jr = Ipe();
function D5(e, t, n = !1) {
              const h = f;
              r[s][h] = D5(a[h], c[h], n);
function Lpe(e) {
  return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : D5(t.components[n].defaultProps, r);
const jpe = /* @__PURE__ */ x.createContext();
const _c = () => x.useContext(jpe) ?? !1;
var Fpe = (e, t, n) => {
}, zpe = (e, t, n) => {
    let h;
      ({ stack: h } = g);
        stack: h
}, Bpe = {
}, u_ = /* @__PURE__ */ Symbol("NOT_FOUND");
function Hpe(e, t = `expected a function, instead received ${typeof e}`) {
function Vpe(e, t = `expected an object, instead received ${typeof e}`) {
function Upe(e, t = "expected all items to be functions, instead received the following types: ") {
var Lz = (e) => Array.isArray(e) ? e : [e];
function Wpe(e) {
  return Upe(
function jz(e, t) {
var Gpe = (e, t) => {
    ...Bpe,
      run: Fpe
      run: zpe
function qpe(e) {
      return t && e(t.key, n) ? t.value : u_;
function Kpe(e, t) {
    const f = n.findIndex((h) => t(c, h.key));
      const h = n[f];
      return f > 0 && (n.splice(f, 1), n.unshift(h)), h.value;
    return u_;
    r(c) === u_ && (n.unshift({ key: c, value: f }), n.length > e && n.pop());
var Ype = (e, t) => e === t;
function Xpe(e) {
function A5(e, t) {
    equalityCheck: r = Ype,
  } = n, a = Xpe(r);
  const f = o <= 1 ? qpe(a) : Kpe(o, a);
  function h() {
    if (g === u_) {
  return h.clearCache = () => {
    f.clear(), h.resetResultsCount();
  }, h.resultsCount = () => c, h.resetResultsCount = () => {
  }, h;
var Qpe = class {
}, Jpe = typeof WeakRef < "u" ? WeakRef : Qpe, Zpe = 0, Fz = 1;
function sT() {
    s: Zpe,
function N5(e, t = {}) {
  let n = sT();
    var v;
        O === void 0 ? (c = sT(), E.set(T, c)) : c = O;
        O === void 0 ? (c = sT(), E.set(T, c)) : c = O;
    const h = c;
    if (c.s === Fz)
      const w = ((v = o == null ? void 0 : o.deref) == null ? void 0 : v.call(o)) ?? o;
      w != null && r(w, g) && (g = w, s !== 0 && s--), o = typeof g == "object" && g !== null || typeof g == "function" ? new Jpe(g) : g;
    return h.s = Fz, h.v = g, g;
    n = sT(), a.resetResultsCount();
function $5(e, ...t) {
    let s = 0, a = 0, c, f = {}, h = o.pop();
    typeof h == "object" && (f = h, h = o.pop()), Hpe(
      h,
      `createSelector expects an output function after the inputs, but received: [${typeof h}]`
      memoize: v,
      argsMemoize: C = N5,
    } = g, O = Lz(w), P = Lz(T), I = Wpe(o), M = v(function() {
      return s++, h.apply(
    let A = !0;
    const k = C(function() {
      const B = jz(
      if (c = M.apply(null, B), process.env.NODE_ENV !== "production") {
        const { identityFunctionCheck: H, inputStabilityCheck: F } = Gpe(A, E);
        if (H.shouldRun && H.run(
          h,
          B,
        ), F.shouldRun) {
          const D = jz(
          F.run(
            { inputSelectorResults: B, inputSelectorResultsCopy: D },
            { memoize: v, memoizeOptions: O },
        A && (A = !1);
    }, ...P);
    return Object.assign(k, {
      resultFunc: h,
      memoize: v,
var L5 = /* @__PURE__ */ $5(N5), ehe = Object.assign(
  (e, t = L5) => {
    Vpe(
  { withTypes: () => ehe }
const zz = /* @__PURE__ */ new Set();
function Cl(e, t = "warning") {
  zz.has(n) || (zz.add(n), t === "error" ? console.error(n) : console.warn(n));
const the = Object.is;
function j5(e, t) {
    if (n += 1, !the(e[o], t[o]) || !(o in t))
var rI = { exports: {} }, LP = {};
var Bz;
function nhe() {
  if (Bz) return LP;
  Bz = 1;
  function t(v, w) {
    return v === w && (v !== 0 || 1 / v === 1 / w) || v !== v && w !== w;
  function c(v, w) {
      [v, C, w]
        return f(E) && O({ inst: E }), v(function() {
      [v]
  function f(v) {
    var w = v.getSnapshot;
    v = v.value;
      return !n(v, C);
  function h(v, w) {
  var g = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? h : c;
  return LP.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : g, LP;
var jP = {};
var Hz;
function rhe() {
  return Hz || (Hz = 1, process.env.NODE_ENV !== "production" && function() {
      if (!v) {
        ), v = !0);
      var P = O[0].inst, I = O[1];
          P.value = E, P.getSnapshot = T, n(P) && I({ inst: P });
          return n(P) && I({ inst: P }), C(function() {
            n(P) && I({ inst: P });
      ), h(E), E;
    var o = x, s = typeof Object.is == "function" ? Object.is : e, a = o.useState, c = o.useEffect, f = o.useLayoutEffect, h = o.useDebugValue, g = !1, v = !1, w = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : t;
    jP.useSyncExternalStore = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : w, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), jP;
process.env.NODE_ENV === "production" ? rI.exports = nhe() : rI.exports = rhe();
var FD = rI.exports;
function F5(e) {
function Vz(e, t) {
  return F5(t) ? t(e) : t(e.current.state);
function FP(e, t, n, r) {
  return F5(t) ? t(e, n) : t(e.current.state, r);
const z5 = Object.is, zD = j5, ohe = (e, t) => e === t ? !0 : e.length === t.length && e.every((n, r) => n === t[r]), ihe = (e, t) => {
  return t instanceof Array ? n = ohe : t instanceof Object && (n = zD), n(e, t);
}, B5 = () => ({
}), c_ = [], H5 = () => null, Ze = (e, t, n = z5) => {
  process.env.NODE_ENV !== "production" && (e.current.state || Cl(["MUI X: `useGridSelector` has been called before the initialization of the state.", "This hook can only be used inside the context of the grid."]));
  const r = Ml(B5), o = r.current.selector !== null, [s, a] = x.useState(
    o ? null : Vz(e, t)
      const h = Vz(e, r.current.selector);
      r.current.equals(r.current.state, h) || (r.current.state = h, a(h));
    c_
  }, c_);
  return FD.useSyncExternalStore(f, c, H5), s;
}, tC = (e, t, n = void 0, r = z5) => {
  process.env.NODE_ENV !== "production" && (e.current.state || Cl(["MUI X: `useGridSelector` has been called before the initialization of the state.", "This hook can only be used inside the context of the grid."]));
  const o = Ml(B5), s = o.current.selector !== null, [a, c] = x.useState(
    s ? null : FP(e, t, n, e.current.instanceId)
  if (o.current.args = n, s && !ihe(f, n)) {
    const v = FP(e, o.current.selector, o.current.args, e.current.instanceId);
    o.current.equals(o.current.state, v) || (o.current.state = v, c(v));
  const h = x.useCallback(
      const v = FP(e, o.current.selector, o.current.args, e.current.instanceId);
      o.current.equals(o.current.state, v) || (o.current.state = v, c(v));
    c_
  }, c_);
  return FD.useSyncExternalStore(g, h, H5), a;
}, she = $5({
  memoize: A5,
}), Uz = /* @__PURE__ */ new WeakMap();
function du(e) {
const fu = {
    c = (f, h) => {
      const g = du(f), v = h ?? (g ? f.current.instanceId : fu), w = g ? f.current.state : f, C = e(w, v), T = t(w, v), E = n(w, v), O = r(w, v), P = o(w, v);
      return s(C, T, E, O, P);
    c = (f, h) => {
      const g = du(f), v = h ?? (g ? f.current.instanceId : fu), w = g ? f.current.state : f, C = e(w, v), T = t(w, v), E = n(w, v), O = r(w, v);
    c = (f, h) => {
      const g = du(f), v = h ?? (g ? f.current.instanceId : fu), w = g ? f.current.state : f, C = e(w, v), T = t(w, v), E = n(w, v);
    c = (f, h) => {
      const g = du(f), v = h ?? (g ? f.current.instanceId : fu), w = g ? f.current.state : f, C = e(w, v), T = t(w, v);
    c = (f, h) => {
      const g = du(f), v = h ?? (g ? f.current.instanceId : fu), w = g ? f.current.state : f, C = e(w, v);
}, RC = (e, t, n, r, o, s, ...a) => {
    c = (f, h, g) => {
      const v = du(f), w = g ?? (v ? f.current.instanceId : fu), C = v ? f.current.state : f, T = e(C, h, w), E = t(C, h, w), O = n(C, h, w), P = r(C, h, w), I = o(C, h, w);
      return s(T, E, O, P, I, h);
    c = (f, h, g) => {
      const v = du(f), w = g ?? (v ? f.current.instanceId : fu), C = v ? f.current.state : f, T = e(C, h, w), E = t(C, h, w), O = n(C, h, w), P = r(C, h, w);
      return o(T, E, O, P, h);
    c = (f, h, g) => {
      const v = du(f), w = g ?? (v ? f.current.instanceId : fu), C = v ? f.current.state : f, T = e(C, h, w), E = t(C, h, w), O = n(C, h, w);
      return r(T, E, O, h);
    c = (f, h, g) => {
      const v = du(f), w = g ?? (v ? f.current.instanceId : fu), C = v ? f.current.state : f, T = e(C, h, w), E = t(C, h, w);
      return n(T, E, h);
    c = (f, h, g) => {
      const v = du(f), w = g ?? (v ? f.current.instanceId : fu), C = v ? f.current.state : f, T = e(C, h, w);
      return t(T, h);
}, ar = (...e) => {
    const o = du(n), s = o ? n.current.instanceId : r ?? fu, a = o ? n.current.state : n;
    process.env.NODE_ENV !== "production" && s.id === "default" && Cl(["MUI X: A selector was called without passing the instance ID, which may impact the performance of the grid.", "To fix, call it with `apiRef`, for example `mySelector(apiRef)`, or pass the instance ID explicitly, for example `mySelector(state, apiRef.current.instanceId)`."]);
    const c = Uz.get(s), f = c ?? /* @__PURE__ */ new Map(), h = f == null ? void 0 : f.get(e);
    if (f && h)
      return h(a, s);
    const g = she(...e);
    return c || Uz.set(s, f), f.set(e, g), g(a, s);
}, vi = (e) => e.dimensions, w1 = en(vi, (e) => e.columnsTotalWidth), BD = (e) => e.dimensions.rowHeight, ahe = (e) => e.dimensions.contentSize.height, lhe = (e) => e.dimensions.hasScrollX, uhe = (e) => e.dimensions.hasScrollY, V5 = (e) => e.dimensions.columnsTotalWidth < e.dimensions.viewportOuterSize.width, che = (e) => e.dimensions.headerHeight, dhe = (e) => e.dimensions.groupHeaderHeight, U5 = (e) => e.dimensions.hasScrollY ? e.dimensions.scrollbarSize : 0, fhe = (e) => {
function Id(e) {
  return /* @__PURE__ */ x.memo(e, j5);
const phe = {
function Bn(e) {
  return ln("MuiDataGrid", e);
const se = fn("MuiDataGrid", ["actionsCell", "aggregationColumnHeader", "aggregationColumnHeader--alignLeft", "aggregationColumnHeader--alignCenter", "aggregationColumnHeader--alignRight", "aggregationColumnHeaderLabel", "autoHeight", "autosizing", "booleanCell", "cell--editable", "cell--editing", "cell--flex", "cell--textCenter", "cell--textLeft", "cell--textRight", "cell--rangeTop", "cell--rangeBottom", "cell--rangeLeft", "cell--rangeRight", "cell--pinnedLeft", "cell--pinnedRight", "cell--selectionMode", "cell", "cellCheckbox", "cellEmpty", "cellSkeleton", "cellOffsetLeft", "checkboxInput", "columnHeader", "columnHeader--alignCenter", "columnHeader--alignLeft", "columnHeader--alignRight", "columnHeader--dragging", "columnHeader--moving", "columnHeader--numeric", "columnHeader--sortable", "columnHeader--sorted", "columnHeader--filtered", "columnHeader--pinnedLeft", "columnHeader--pinnedRight", "columnHeader--last", "columnHeader--lastUnpinned", "columnHeader--siblingFocused", "columnHeaderCheckbox", "columnHeaderDraggableContainer", "columnHeaderTitle", "columnHeaderTitleContainer", "columnHeaderTitleContainerContent", "columnHeader--filledGroup", "columnHeader--emptyGroup", "columnHeaders", "columnSeparator--resizable", "columnSeparator--resizing", "columnSeparator--sideLeft", "columnSeparator--sideRight", "columnSeparator", "columnsManagement", "columnsManagementRow", "columnsManagementHeader", "columnsManagementSearchInput", "columnsManagementFooter", "container--top", "container--bottom", "detailPanel", "detailPanels", "detailPanelToggleCell", "detailPanelToggleCell--expanded", "footerCell", "panel", "panelHeader", "panelWrapper", "panelContent", "panelFooter", "paper", "editBooleanCell", "editInputCell", "filler", "filler--borderBottom", "filler--pinnedLeft", "filler--pinnedRight", "filterForm", "filterFormDeleteIcon", "filterFormLogicOperatorInput", "filterFormColumnInput", "filterFormOperatorInput", "filterFormValueInput", "filterIcon", "footerContainer", "headerFilterRow", "iconButtonContainer", "iconSeparator", "main", "main--hasPinnedRight", "main--hasSkeletonLoadingOverlay", "menu", "menuIcon", "menuIconButton", "menuOpen", "menuList", "overlay", "overlayWrapper", "overlayWrapperInner", "root", "root--densityStandard", "root--densityComfortable", "root--densityCompact", "root--disableUserSelection", "root--noToolbar", "row", "row--editable", "row--editing", "row--firstVisible", "row--lastVisible", "row--dragging", "row--dynamicHeight", "row--detailPanelExpanded", "row--borderBottom", "rowReorderCellPlaceholder", "rowCount", "rowReorderCellContainer", "rowReorderCell", "rowReorderCell--draggable", "rowSkeleton", "scrollArea--left", "scrollArea--right", "scrollArea--up", "scrollArea--down", "scrollArea", "scrollbar", "scrollbar--vertical", "scrollbar--horizontal", "scrollbarFiller", "scrollbarFiller--header", "scrollbarFiller--borderTop", "scrollbarFiller--borderBottom", "scrollbarFiller--pinnedRight", "selectedRowCount", "sortButton", "sortIcon", "toolbarContainer", "toolbarFilterList", "virtualScroller", "virtualScroller--hasScrollX", "virtualScrollerContent", "virtualScrollerContent--overflowed", "virtualScrollerRenderZone", "pinnedColumns", "withVerticalBorder", "withBorderColor", "cell--withRightBorder", "cell--withLeftBorder", "columnHeader--withRightBorder", "columnHeader--withLeftBorder", "treeDataGroupingCell", "treeDataGroupingCellToggle", "treeDataGroupingCellLoadingContainer", "groupingCriteriaCell", "groupingCriteriaCellToggle", "groupingCriteriaCellLoadingContainer", "pinnedRows", "pinnedRows--top", "pinnedRows--bottom", "pinnedRowsRenderZone"]), Wz = 1e3;
class hhe {
  constructor(t = Wz) {
    this.timeouts = /* @__PURE__ */ new Map(), this.cleanupTimeout = Wz, this.cleanupTimeout = t;
class mhe {
var $a = /* @__PURE__ */ function(e) {
}($a || {});
class ghe {
function vhe(e) {
    e.registry === null && (e.registry = typeof FinalizationRegistry < "u" ? new mhe() : new hhe());
    const [c] = x.useState(new ghe()), f = x.useRef(null), h = x.useRef(null);
    h.current = s;
    if (!f.current && h.current) {
      const v = (w, C, T) => {
        C.defaultMuiPrevented || (E = h.current) == null || E.call(h, w, C, T);
      f.current = r.current.subscribeEvent(o, v, a), t += 1, g.current = {
    } else !h.current && f.current && (f.current(), f.current = null, g.current && (e.registry.unregister(g.current), g.current = null));
      if (!f.current && h.current) {
        const v = (w, C, T) => {
          C.defaultMuiPrevented || (E = h.current) == null || E.call(h, w, C, T);
        f.current = r.current.subscribeEvent(o, v, a);
        var v;
        (v = f.current) == null || v.call(f), f.current = null;
const yhe = {
}, Ot = vhe(yhe), bhe = {
function hr(e, t, n) {
  Ot(e, t, n, bhe);
const whe = 0.7, She = 1.3, Che = {
  compact: whe,
  comfortable: She,
}, Mv = (e) => e.density, xy = en(Mv, (e) => Che[e]), xhe = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "isValidating", "debounceMs", "isProcessingProps", "onValueChange"], Ehe = (e) => {
  }, Bn, t);
}, The = Ue(vm, {
})), W5 = Qn((e, t) => {
  const n = $t(), {
    isProcessingProps: h,
  } = e, v = qt(e, xhe), w = kn(), C = x.useRef(null), [T, E] = x.useState(o), O = Ehe(n), P = x.useCallback(async (M) => {
    const A = M.target.value;
    g && await g(M, A);
    const k = w.current.getColumn(s);
    let j = A;
    k.valueParser && (j = k.valueParser(A, w.current.getRow(r), k, w)), E(j), w.current.setEditCellValue({
      value: j,
  }, [I, o]), Lr(() => {
  }, [c]), /* @__PURE__ */ $.jsx(The, J({
    onChange: P,
    endAdornment: h ? /* @__PURE__ */ $.jsx(n.slots.loadIcon, {
  }, v, {
process.env.NODE_ENV !== "production" && (W5.propTypes = {
const _he = (e) => /* @__PURE__ */ $.jsx(W5, J({}, e)), Dl = (e) => e.rows, kC = en(Dl, (e) => e.totalRowCount), Ohe = en(Dl, (e) => e.loading), Rhe = en(Dl, (e) => e.totalTopLevelRowCount), yl = en(Dl, (e) => e.dataRowIdToModelLookup), Gz = en(Dl, (e) => e.dataRowIdToIdLookup), Xo = en(Dl, (e) => e.tree), khe = en(Dl, (e) => e.groupsToFetch), Phe = en(Dl, (e) => e.groupingName), qz = en(Dl, (e) => e.treeDepths), Sm = ar(Dl, (e) => {
}), gS = en(Dl, (e) => e.dataRowIds), Mhe = en(Dl, (e) => e == null ? void 0 : e.additionalRowGroups), Ey = ar(Mhe, (e) => {
}), G5 = en(Ey, (e) => {
}), q5 = (e, t) => t && e.length > 1 ? (process.env.NODE_ENV !== "production" && Cl(["MUI X: The `sortModel` can only contain a single item when the `disableMultipleColumnsSorting` prop is set to `true`.", "If you are using the community version of the Data Grid, this prop is always `true`."], "error"), [e[0]]) : e, Kz = (e, t) => (n) => J({}, n, {
    sortModel: q5(e, t)
}), Ihe = (e) => e === "desc", Dhe = (e, t) => {
  return n.getSortComparator ? r = n.getSortComparator(e.sort) : r = Ihe(e.sort) ? (...s) => -1 * n.sortComparator(...s) : n.sortComparator, r ? {
      rowNode: Xo(t)[s],
}, Ahe = (e, t, n) => e.reduce((r, o, s) => {
}, 0), Nhe = (e, t) => {
  const n = e.map((r) => Dhe(r, t)).filter((r) => !!r);
  })).sort((o, s) => Ahe(n, o, s)).map((o) => o.node.id);
}, Yz = (e, t) => {
}, HD = (e, t) => e == null && t != null ? -1 : t == null && e != null ? 1 : e == null && t == null ? 0 : null, $he = new Intl.Collator(), Lhe = (e, t) => {
  const n = HD(e, t);
  return n !== null ? n : typeof e == "string" ? $he.compare(e.toString(), t.toString()) : e - t;
}, K5 = (e, t) => {
  const n = HD(e, t);
}, Y5 = (e, t) => {
  const n = HD(e, t);
}, jhe = ["item", "applyValue", "type", "apiRef", "focusElementRef", "tabIndex", "disabled", "isFilterActive", "clearButton", "InputProps", "variant"];
function Ma(e) {
  var A;
    InputProps: h,
  } = e, v = qt(e, jhe), w = Aa(), [C, T] = x.useState(zP(t.value)), [E, O] = x.useState(!1), P = mr(), I = $t(), M = x.useCallback((k) => {
    const j = zP(k.target.value);
    T(j), O(!0), w.start(I.filterDebounceMs, () => {
      const B = J({}, t, {
        value: r === "number" && !Number.isNaN(Number(j)) ? Number(j) : j,
        fromInput: P
      n(B), O(!1);
  }, [w, I.filterDebounceMs, t, r, P, n]);
    (t.fromInput !== P || t.value == null) && T(zP(t.value));
  }, [P, t]), /* @__PURE__ */ $.jsx(I.slots.baseTextField, J({
    id: P,
    }, h, {
      }, h == null ? void 0 : h.inputProps)
  }, v, (A = I.slotProps) == null ? void 0 : A.baseTextField));
function zP(e) {
process.env.NODE_ENV !== "production" && (Ma.propTypes = {
function X5(e) {
function Fhe(e) {
function VD(e) {
function zhe() {
function d_(e) {
const La = (e, t, n) => Math.max(t, Math.min(n, e));
function Xz(e, t) {
function Yf(e, t) {
        if (!Yf(e[s], t[s]))
        if (!Yf(a[1], t.get(a[0])))
      if (!Yf(e[s], t[s]))
function Bhe(e) {
function Hhe(e) {
  const t = Bhe(e);
function Q5(e) {
const qh = (e, t) => (n) => {
}, Vhe = ["item", "applyValue", "type", "apiRef", "focusElementRef", "color", "error", "helperText", "size", "variant"], Uhe = ["key"];
function UD(e) {
    size: h,
  } = e, v = qt(e, Vhe), w = {
    size: h,
  }, [C, T] = x.useState(t.value || []), E = mr(), O = $t();
  const P = x.useCallback((I, M) => {
      value: [...M.map((A) => r === "number" ? Number(A) : A)]
  return /* @__PURE__ */ $.jsx(lD, J({
        inputValue: A
      return A == null || A === "" ? [] : [A];
    onChange: P,
    renderTags: (I, M) => I.map((A, k) => {
      const j = M({
        index: k
        key: B
      } = j, H = qt(j, Uhe);
        label: A
      }, H), B);
  }, v));
process.env.NODE_ENV !== "production" && (UD.propTypes = {
var xc = /* @__PURE__ */ function(e) {
}(xc || {}), fr = /* @__PURE__ */ function(e) {
}(fr || {}), Gr = /* @__PURE__ */ function(e) {
}(Gr || {}), Is = /* @__PURE__ */ function(e) {
}(Is || {}), Sd = /* @__PURE__ */ function(e) {
}(Sd || {}), lu = /* @__PURE__ */ function(e) {
}(lu || {}), $f = /* @__PURE__ */ function(e) {
}($f || {}), lc = /* @__PURE__ */ function(e) {
}(lc || {});
function J5(e) {
const Z5 = {
}, nC = () => ({
  logicOperator: Is.And,
  quickFilterLogicOperator: Is.And
function eW(e) {
let Lf = /* @__PURE__ */ function(e) {
const f_ = {
}, tW = (e) => e.isRtl, bc = (e) => e.columns, Rd = en(bc, (e) => e.orderedFields), Dd = en(bc, (e) => e.lookup), xl = ar(Rd, Dd, (e, t) => e.map((n) => t[n])), bl = en(bc, (e) => e.columnVisibilityModel), mo = ar(xl, bl, (e, t) => e.filter((n) => t[n.field] !== !1)), Ty = ar(mo, (e) => e.map((t) => t.field)), nW = (e) => e.pinnedColumns;
ar(nW, Rd, tW, (e, t, n) => rW(e, t, n));
const _y = ar(bc, nW, Ty, tW, (e, t, n, r) => {
  const o = rW(t, n, r);
function rW(e, t, n) {
    return f_;
  const r = (h, g) => Array.isArray(h) ? h.filter((v) => g.includes(v)) : [], o = r(e.left, t), s = t.filter(
    (h) => !o.includes(h)
const pp = ar(mo, (e) => {
}), oW = ar(xl, (e) => e.filter((t) => t.filterable)), Whe = ar(xl, (e) => e.reduce((t, n) => (n.filterable && (t[n.field] = n), t), {})), Ghe = ar(xl, (e) => e.some((t) => t.colSpan !== void 0));
let eS;
function qhe() {
  if (eS !== void 0)
    return eS;
    eS = new Function("return true")();
    eS = !1;
  return eS;
const oI = (e, t) => {
    const r = Dd(t)[n.field];
}, WD = (e, t, n) => {
  r && t ? (process.env.NODE_ENV !== "production" && Cl(["MUI X: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.", "If you are using the community version of the Data Grid, this prop is always `true`."], "error"), o = [e.items[0]]) : o = e.items;
  return process.env.NODE_ENV !== "production" && s && Cl("MUI X: The `id` field is required on `filterModel.items` when you use multiple filters.", "error"), process.env.NODE_ENV !== "production" && a && Cl("MUI X: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.", "error"), a || s ? J({}, e, {
    items: o.map((c) => oI(c, n))
}, Qz = (e, t, n) => (r) => J({}, r, {
  filterModel: WD(e, t, n)
}), rC = (e) => typeof e == "string" ? e.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : e, iW = (e, t) => {
    const v = n.valueParser;
    r = Array.isArray(e.value) ? (g = e.value) == null ? void 0 : g.map((w) => v(w, void 0, n, t)) : v(e.value, void 0, n, t);
  o && (r = rC(r));
  const c = a.find((v) => v.value === s.operator);
  const f = eW(t), h = c.getApplyFilterFn(s, n);
  return typeof h != "function" ? null : {
    fn: (v) => {
      let w = t.current.getRowValue(v, n);
      return o && (w = rC(w)), h(w, v, n, f);
let Jz = 1;
const Khe = (e, t, n) => {
  } = e, o = r.map((c) => iW(c, t)).filter((c) => !!c);
  if (n || !qhe())
      const h = {};
        const v = o[g];
        (!f || f(v.item.field)) && (h[v.item.id] = v.fn(c));
      return h;
return result$$;`.replaceAll("$$", String(Jz)));
  return Jz += 1, (c, f) => s(o, c, f);
}, sW = (e) => e.quickFilterExcludeHiddenColumns ?? !0, Yhe = (e, t) => {
  const r = sW(e) ? Ty(t) : Rd(t), o = [], {
  } = t.current.rootProps, a = eW(t);
    const h = t.current.getColumn(f), g = h == null ? void 0 : h.getApplyQuickFilterFn;
      column: h,
      appliers: n.map((v) => {
        const w = s ? rC(v) : v;
          fn: g(w, h, a)
  }), function(h, g) {
    const v = {};
          field: P
        if (g && !g(P))
        let M = t.current.getRowValue(h, E);
        if (s && (M = rC(M)), I.fn(M, h, E, a)) {
          v[C] = !0;
      v[C] = !1;
    return v;
}, Xhe = (e, t, n) => {
  const r = Khe(e, t, n), o = Yhe(e, t);
}, Zz = (e) => e != null, Qhe = (e, t, n) => (e.cleanedFilterItems || (e.cleanedFilterItems = n.filter((r) => iW(r, t) !== null)), e.cleanedFilterItems), Jhe = (e, t, n, r, o) => {
  const s = Qhe(o, r, n.items), a = e.filter(Zz), c = t.filter(Zz);
    const f = (g) => a.some((v) => v[g.id]);
    if ((n.logicOperator ?? nC().logicOperator) === Is.And) {
    const f = (g) => c.some((v) => v[g]);
    if ((n.quickFilterLogicOperator ?? nC().quickFilterLogicOperator) === Is.And) {
}, Zhe = (e) => {
  const t = new RegExp(d_(e), "i");
    return s.current.ignoreDiacritics && (a = rC(a)), a != null ? t.test(a.toString()) : !1;
}, eB = (e, t) => (n) => {
  const r = e ? n.value : n.value.trim(), o = new RegExp(d_(r), "i");
}, tB = (e, t) => (n) => {
}, nB = (e) => () => (t) => {
}, eme = (e = !1) => [{
  getApplyFilterFn: eB(e, !1),
  InputComponent: Ma
  getApplyFilterFn: eB(e, !0),
  InputComponent: Ma
  getApplyFilterFn: tB(e, !1),
  InputComponent: Ma
  getApplyFilterFn: tB(e, !0),
  InputComponent: Ma
    const n = e ? t.value : t.value.trim(), r = new RegExp(`^${d_(n)}.*$`, "i");
  InputComponent: Ma
    const n = e ? t.value : t.value.trim(), r = new RegExp(`.*${d_(n)}$`, "i");
  InputComponent: Ma
  getApplyFilterFn: nB(!1),
  getApplyFilterFn: nB(!0),
  InputComponent: UD
}], yu = {
  sortComparator: Lhe,
  filterOperators: eme(),
  renderEditCell: _he,
  getApplyQuickFilterFn: Zhe
}, tme = ["open", "target", "onClose", "children", "position", "className", "onExited"], nme = (e) => {
  }, Bn, t);
}, rme = Ue(cp, {
})), ome = {
function S1(e) {
  } = e, f = qt(e, tme), h = kn(), g = $t(), v = nme(g), w = x.useRef(null);
  Lr(() => {
    var O, P;
    t ? w.current = document.activeElement instanceof HTMLElement ? document.activeElement : null : ((P = (O = w.current) == null ? void 0 : O.focus) == null || P.call(O), w.current = null);
    h.current.publishEvent(O, {
  }, [h, t, n]);
  const C = (O) => (P) => {
    O && O(), c && c(P);
  return /* @__PURE__ */ $.jsx(rme, J({
    className: et(v.root, a),
      placement: P
    }) => /* @__PURE__ */ $.jsx(GS, {
      children: /* @__PURE__ */ $.jsx(Jv, J({}, O, {
          transformOrigin: ome[P]
        children: /* @__PURE__ */ $.jsx(la, {
process.env.NODE_ENV !== "production" && (S1.propTypes = {
  target: Tl
const ime = ["api", "colDef", "id", "hasFocus", "isEditable", "field", "value", "formattedValue", "row", "rowNode", "cellMode", "tabIndex", "position", "focusElementRef"], sme = (e) => typeof e.getActions == "function";
function aW(e) {
  var Y;
  } = e, c = qt(e, ime), [f, h] = x.useState(-1), [g, v] = x.useState(!1), w = kn(), C = x.useRef(null), T = x.useRef(null), E = x.useRef(!1), O = x.useRef({}), P = _c(), I = mr(), M = mr(), A = $t();
  if (!sme(t))
  const k = t.getActions(w.current.getRowParams(n)), j = k.filter((X) => !X.props.showInMenu), B = k.filter((X) => X.props.showInMenu), H = j.length + (B.length ? 1 : 0);
    r || (h(-1), E.current = !1);
        const X = k.findIndex((te) => !te.props.disabled);
        h(X);
  }), [k]), x.useEffect(() => {
    f >= H && h(H - 1);
  }, [f, H]);
  const F = () => {
    v(!0), h(H - 1), E.current = !0;
  }, D = () => {
    v(!1);
    X.stopPropagation(), X.preventDefault(), g ? D() : F();
  }, U = (X) => (te) => {
  }, K = (X, te) => (re) => {
    h(X), E.current = !0, te && te(re);
    if (H <= 1)
    const te = (Q, V) => {
      if (Q < 0 || Q > k.length)
      const de = (V === "left" ? -1 : 1) * (P ? -1 : 1);
      return (ue = k[Q + de]) != null && ue.props.disabled ? te(Q + de, V) : Q + de;
    X.key === "ArrowRight" ? re = te(f, "right") : X.key === "ArrowLeft" && (re = te(f, "left")), !(re < 0 || re >= H) && re !== f && (X.preventDefault(), X.stopPropagation(), h(re));
    X.key === "Tab" && X.preventDefault(), ["Tab", "Escape"].includes(X.key) && D();
    children: [j.map((X, te) => /* @__PURE__ */ x.cloneElement(X, {
      touchRippleRef: U(te),
      onClick: K(te, X.props.onClick),
    })), B.length > 0 && M && /* @__PURE__ */ $.jsx(A.slots.baseIconButton, J({
      touchRippleRef: U(M),
      tabIndex: f === j.length ? o : -1
    }, (Y = A.slotProps) == null ? void 0 : Y.baseIconButton, {
      children: /* @__PURE__ */ $.jsx(A.slots.moreActionsIcon, {
    })), B.length > 0 && /* @__PURE__ */ $.jsx(S1, {
      onClose: D,
      children: /* @__PURE__ */ $.jsx(SC, {
        children: B.map((X, te) => /* @__PURE__ */ x.cloneElement(X, {
          closeMenu: D
process.env.NODE_ENV !== "production" && (aW.propTypes = {
const ame = (e) => /* @__PURE__ */ $.jsx(aW, J({}, e)), C1 = "actions", lme = J({}, yu, {
  renderCell: ame,
}), Ki = "auto-generated-group-node-root", sy = Symbol("mui.id_autogenerated"), ume = () => ({
  id: Ki,
function cme(e, t, n = "A row was provided without id in the rows prop:") {
const x1 = (e, t, n) => {
  return cme(r, e, n), r;
}, ET = ({
    const f = e[c], h = x1(f, t);
    s[h] = f, a[h] = h, o.rows.push(h);
}, lW = ({
  const n = e[Ki];
}, uW = ({
    dataRowIds: h,
    groupsToFetch: v = []
    dataRowIds: h,
    totalTopLevelRowCount: lW({
    groupsToFetch: v
}, ay = (e) => e.type === "skeletonRow" || e.type === "footer" || e.type === "group" && e.isAutoGenerated || e.type === "pinnedRow" && e.isAutoGenerated, GD = (e, t, n) => {
    (!n || !ay(e[a])) && o.push(a);
    const c = GD(e, a, n);
}, rB = ({
    const v = x1(g, t, "A row was provided without id when calling updateRows():");
    o.has(v) ? o.set(v, J({}, o.get(v), g)) : o.set(v, g);
  o.forEach((g, v) => {
    const w = s.idToActionLookup[v];
      if (w === "remove" || !a[v])
      w != null && (f[w][v] = !0), s.actions.remove.push(v), delete a[v], delete c[v];
    const C = a[v];
      w === "remove" ? (f.remove[v] = !0, s.actions.modify.push(v)) : w == null && s.actions.modify.push(v), a[v] = J({}, C, g);
    w === "remove" ? (f.remove[v] = !0, s.actions.insert.push(v)) : w == null && s.actions.insert.push(v), a[v] = g, c[v] = v;
  const h = Object.keys(f);
  for (let g = 0; g < h.length; g += 1) {
    const v = h[g], w = f[v];
    Object.keys(w).length > 0 && (s.actions[v] = s.actions[v].filter((C) => !w[C]));
}, cW = "var(--DataGrid-overlayHeight, calc(var(--height) * 2))";
function oB(e, t, n) {
    const s = x1(o, n, "A row was provided without id when calling updateRows():"), a = e.current.getRowNode(s);
let iB = !1;
const dW = (e, t, n) => typeof e == "number" && e > 0 ? e : (process.env.NODE_ENV !== "production" && !iB && typeof e < "u" && e !== null && (console.warn(n), iB = !0), t), dme = ["MUI X: The `rowHeight` prop should be a number greater than 0.", "The default value will be used instead."].join(`
`), fme = ["MUI X: The `getRowHeight` prop should return a number greater than 0 or 'auto'.", "The default value will be used instead."].join(`
`), pme = "__tree_data_group__", fW = "__row_group_by_columns_group__", E1 = "__detail_panel_toggle__";
let $n = /* @__PURE__ */ function(e) {
const hme = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "hasFocus", "tabIndex", "hideDescendantCount"], mme = (e) => {
  }, Bn, t);
function pW(e) {
  } = e, r = qt(e, hme), o = kn(), s = $t(), a = {
  }, c = mme(a), h = (
    Ze(o, Sm) > 0 && n.type === "group" && s.treeData === !1
  return h && t === void 0 ? null : /* @__PURE__ */ $.jsx(g, J({
process.env.NODE_ENV !== "production" && (pW.propTypes = {
const gme = /* @__PURE__ */ x.memo(pW), vme = (e) => e.field !== fW && ay(e.rowNode) ? "" : /* @__PURE__ */ $.jsx(gme, J({}, e)), yme = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "hasFocus", "isValidating", "isProcessingProps", "error", "onValueChange"], bme = (e) => {
  }, Bn, t);
function hW(e) {
  var P;
  } = e, c = qt(e, yme), f = kn(), h = x.useRef(null), g = mr(), [v, w] = x.useState(n), C = $t(), T = {
  }, E = bme(T), O = x.useCallback(async (I) => {
  }, [n]), Lr(() => {
    s && h.current.focus();
      inputRef: h,
      checked: !!v,
    }, (P = C.slotProps) == null ? void 0 : P.baseCheckbox))
process.env.NODE_ENV !== "production" && (hW.propTypes = {
const wme = (e) => /* @__PURE__ */ $.jsx(hW, J({}, e)), Sme = ["item", "applyValue", "apiRef", "focusElementRef", "isFilterActive", "clearButton", "tabIndex", "label", "variant", "InputLabelProps"], TT = (e) => {
}, Cme = Ue("div")({
function mW(e) {
  var A, k, j;
  } = e, h = qt(e, Sme), [g, v] = x.useState(TT(t.value)), w = $t(), C = mr(), T = mr(), E = ((A = w.slotProps) == null ? void 0 : A.baseSelect) || {}, O = E.native ?? !1, P = ((k = w.slotProps) == null ? void 0 : k.baseSelectOption) || {}, I = x.useCallback((B) => {
    const H = TT(B.target.value);
    v(H), n(J({}, t, {
      value: H
    v(TT(t.value));
  return /* @__PURE__ */ $.jsxs(Cme, {
      children: [/* @__PURE__ */ $.jsx(w.slots.baseInputLabel, J({}, (j = w.slotProps) == null ? void 0 : j.baseInputLabel, {
      }, h, E, {
        children: [/* @__PURE__ */ $.jsx(w.slots.baseSelectOption, J({}, P, {
        })), /* @__PURE__ */ $.jsx(w.slots.baseSelectOption, J({}, P, {
        })), /* @__PURE__ */ $.jsx(w.slots.baseSelectOption, J({}, P, {
process.env.NODE_ENV !== "production" && (mW.propTypes = {
  focusElementRef: pa,
const xme = () => [{
    const t = TT(e.value);
  InputComponent: mW
}], Eme = (e, t, n, r) => e ? r.current.getLocaleText("booleanCellTrueLabel") : r.current.getLocaleText("booleanCellFalseLabel"), Tme = (e) => {
}, gW = J({}, yu, {
  renderCell: vme,
  renderEditCell: wme,
  sortComparator: K5,
  valueFormatter: Eme,
  filterOperators: xme(),
  pastedValueParser: (e) => Tme(e)
}), vW = (e) => e.sorting, Oy = en(vW, (e) => e.sortedRows), qD = ar(Oy, yl, Xo, (e, t, n) => e.reduce((r, o) => {
    a && ay(a) && r.push({
        [sy]: o
}, [])), uu = en(vW, (e) => e.sortModel), _me = ar(uu, (e) => e.reduce((n, r, o) => (n[r.field] = {
ar(Oy, (e) => e.reduce((t, n, r) => (t[n] = r, t), /* @__PURE__ */ Object.create(null)));
const T1 = (e) => e.filter, Ti = en(T1, (e) => e.filterModel), Ome = en(Ti, (e) => e.quickFilterValues), Rme = (e) => e.visibleRowsLookup, Ry = en(T1, (e) => e.filteredRowsLookup);
en(T1, (e) => e.filteredChildrenCountLookup);
en(T1, (e) => e.filteredDescendantCountLookup);
const hp = ar(Rme, qD, Sm, Ti, Ome, (e, t, n, r, o) => n < 2 && !r.items.length && !(o != null && o.length) ? t : t.filter((s) => e[s.id] !== !1)), Hv = ar(hp, (e) => e.map((t) => t.id)), yW = ar(Ry, qD, (e, t) => t.filter((n) => e[n.id] !== !1)), bW = ar(yW, (e) => e.map((t) => t.id));
ar(Hv, Xo, (e, t) => {
const wW = ar(hp, Xo, Sm, (e, t, n) => n < 2 ? e : e.filter((r) => {
})), KD = en(hp, (e) => e.length), YD = en(wW, (e) => e.length), kme = en(yW, (e) => e.length);
en(kme, YD, (e, t) => e - t);
const SW = ar(Ti, Dd, (e, t) => {
}), Pme = ar(SW, (e) => e.reduce((n, r) => (n[r.field] ? n[r.field].push(r) : n[r.field] = [r], n), {})), ka = (e) => e.rowSelection, Mme = en(ka, (e) => e.length), Ime = ar(ka, yl, (e, t) => new Map(e.map((n) => [n, t[n]]))), Xf = ar(ka, (e) => e.reduce((t, n) => (t[n] = n, t), {}));
function CW(e, t) {
  const n = Xo(e), r = Oy(e), o = Ry(e), s = n[t];
  const a = [], c = r.findIndex((h) => h === t) + 1;
  for (let h = c; h < r.length && ((f = n[r[h]]) == null ? void 0 : f.depth) > s.depth; h += 1) {
    const g = r[h];
function Dme(e, t) {
  return en(Xo, Oy, Ry, Xf, (n, r, o, s) => {
    const h = r.findIndex((v) => v === e) + 1;
    for (let v = h; v < r.length && ((g = n[r[v]]) == null ? void 0 : g.depth) > a.depth; v += 1) {
      const w = r[v];
function XD(e) {
  return e.signature === $a.DataGrid ? e.checkboxSelection && e.disableMultipleRowSelection !== !0 : !e.disableMultipleRowSelection;
const Ame = (e, t) => {
  for (; r != null && r !== Ki; ) {
}, Nme = (e, t, n) => {
}, tS = (e, t, n, r, o, s, a = new Set(ka(e.current.state))) => {
  const c = Ry(e), f = /* @__PURE__ */ new Set([]);
      const h = t[n];
      (h == null ? void 0 : h.type) === "group" && CW(e, n).forEach((v) => {
        s(v), f.add(v);
      const h = (v) => {
        if (!a.has(v) && !f.has(v))
        const w = t[v];
        return w ? w.type !== "group" ? !0 : w.children.every(h) : !1;
      }, g = (v) => {
        const w = Nme(t, c, v);
        if (w.length === 0 || w.every(h)) {
          const C = t[v], T = C == null ? void 0 : C.parent;
          T != null && T !== Ki && e.current.isRowSelectable(T) && (s(T), f.add(T), g(T));
}, sB = (e, t, n, r, o, s) => {
  const a = Xf(e);
  if (!(!o && !r) && (o && Ame(t, n).forEach((f) => {
    (c == null ? void 0 : c.type) === "group" && CW(e, n).forEach((h) => {
      s(h);
}, $me = ["field", "id", "formattedValue", "row", "rowNode", "colDef", "isEditable", "cellMode", "hasFocus", "tabIndex", "api"], Lme = (e) => {
  }, Bn, t);
}, xW = Qn(function(t, n) {
  var H, F;
  } = t, f = qt(t, $me), h = kn(), g = $t(), v = {
  }, w = Lme(v), C = x.useRef(null), T = x.useRef(null), E = Ir(C, n), O = (D) => {
      value: D.target.checked,
    h.current.publishEvent("rowSelectionCheckboxChange", q, D);
      const D = h.current.getCellElement(o, r);
      D && (D.tabIndex = -1);
  }, [h, c, o, r]), x.useEffect(() => {
    var D;
      const q = (D = C.current) == null ? void 0 : D.querySelector("input");
  const P = x.useCallback((D) => {
    D.key === " " && D.stopPropagation();
  }, []), I = h.current.isRowSelectable(o), M = Dme(o, ((H = g.rowSelectionPropagation) == null ? void 0 : H.parents) ?? !1), {
    isIndeterminate: A,
    isChecked: k
  } = Ze(h, M, zD);
  const j = g.indeterminateCheckboxAction === "select" ? k && !A : k, B = h.current.getLocaleText(j ? "checkboxSelectionUnselectRow" : "checkboxSelectionSelectRow");
    checked: j,
      "aria-label": B,
    onKeyDown: P,
    indeterminate: A,
  }, (F = g.slotProps) == null ? void 0 : F.baseCheckbox, f, {
process.env.NODE_ENV !== "production" && (xW.propTypes = {
const jme = xW, _1 = (e) => e.focus, Ms = en(_1, (e) => e.cell), Fme = en(_1, (e) => e.columnHeader);
en(_1, (e) => e.columnHeaderFilter);
const p_ = en(_1, (e) => e.columnGroupHeader), O1 = (e) => e.tabIndex, QD = en(O1, (e) => e.cell), EW = en(O1, (e) => e.columnHeader);
en(O1, (e) => e.columnHeaderFilter);
const zme = en(O1, (e) => e.columnGroupHeader);
function On(e, t, n) {
  Lr(() => {
function yi(e, t) {
const TW = (e, t, n, r, o) => {
  const s = yi(e, "useNativeEventListener");
  hr(e, "rootMount", () => {
}, PC = (e) => {
}, Bme = () => {
}, Hme = (e, t) => {
  Lr(() => n.current || !e ? Bme : (n.current = !0, t()), [n.current || e]);
}, Vme = 100, Ume = (e) => e ? 0 : 100, _W = (e, t, n) => t > 0 && e > 0 ? Math.ceil(e / t) : e === -1 ? n + 2 : 0, OW = (e) => ({
}), Wme = (e, t = 0) => t === 0 ? e : Math.max(Math.min(e, t - 1), 0), RW = (e, t) => {
  if (t === $a.DataGrid && e > Vme)
}, Gme = -1, MC = (e) => e.pagination, kW = en(MC, (e) => e.enabled && e.paginationMode === "client"), gs = en(MC, (e) => e.paginationModel), Iv = en(MC, (e) => e.rowCount), vS = en(MC, (e) => e.meta), qme = en(gs, (e) => e.page), PW = en(gs, (e) => e.pageSize), MW = en(gs, Iv, (e, t) => _W(t, e.pageSize, e.page)), JD = ar(kW, gs, Xo, Sm, hp, wW, (e, t, n, r, o, s) => {
  const a = s.length, c = Math.min(t.pageSize * t.page, a - 1), f = t.pageSize === Gme ? a - 1 : Math.min(c + t.pageSize - 1, a - 1);
  const h = s[c], g = f - c + 1, v = o.findIndex((E) => E.id === h.id);
  let w = v, C = 0;
    firstRowIndex: v,
}), Kme = ar(hp, JD, (e, t) => t ? e.slice(t.firstRowIndex, t.lastRowIndex + 1) : []), IW = ar(Hv, JD, (e, t) => t ? e.slice(t.firstRowIndex, t.lastRowIndex + 1) : []), IC = ar(kW, JD, Kme, hp, (e, t, n, r) => e ? {
}), Yme = ["field", "colDef"], Xme = (e) => {
  }, Bn, t);
}, DW = Qn(function(t, n) {
  var H;
  const r = qt(t, Yme), [, o] = x.useState(!1), s = kn(), a = $t(), c = {
  }, f = Xme(c), h = Ze(s, EW), g = Ze(s, ka), v = Ze(s, Hv), w = Ze(s, IW), C = x.useMemo(() => typeof a.isRowSelectable != "function" ? g : g.filter((F) => a.keepNonExistentRowsSelected ? !0 : s.current.getRow(F) ? a.isRowSelectable(s.current.getRowParams(F)) : !1), [s, a.isRowSelectable, g, a.keepNonExistentRowsSelected]), T = x.useMemo(() => (!a.pagination || !a.checkboxSelectionVisibleOnly || a.paginationMode === "server" ? v : w).reduce((D, q) => (D[q] = !0, D), {}), [a.pagination, a.paginationMode, a.checkboxSelectionVisibleOnly, w, v]), E = x.useMemo(() => C.filter((F) => T[F]).length, [C, T]), O = E > 0 && E < Object.keys(T).length, P = E > 0, I = (F) => {
    const D = {
      value: F.target.checked
    s.current.publishEvent("headerSelectionCheckboxChange", D);
  }, M = h !== null && h.field === t.field ? 0 : -1;
    const F = s.current.getColumnHeaderElement(t.field);
    M === 0 && F && (F.tabIndex = -1);
  const A = x.useCallback((F) => {
    F.key === " " && s.current.publishEvent("headerSelectionCheckboxChange", {
      value: !P
  }, [s, P]), k = x.useCallback(() => {
    o((F) => !F);
  x.useEffect(() => s.current.subscribeEvent("rowSelectionChange", k), [s, k]);
  const j = a.indeterminateCheckboxAction === "select" ? P && !O : P, B = s.current.getLocaleText(j ? "checkboxSelectionUnselectAllRows" : "checkboxSelectionSelectAllRows");
    checked: j,
      "aria-label": B,
    onKeyDown: A,
    disabled: !XD(a)
  }, (H = a.slotProps) == null ? void 0 : H.baseCheckbox, r, {
process.env.NODE_ENV !== "production" && (DW.propTypes = {
const DC = (e, t) => sy in t ? t[sy] : e.props.getRowId ? e.props.getRowId(t) : t.id, hl = "__check__", ky = J({}, gW, {
  field: hl,
    const o = Xf(r), s = DC(r.current.state, t);
  renderHeader: (e) => /* @__PURE__ */ $.jsx(DW, J({}, e)),
  renderCell: (e) => /* @__PURE__ */ $.jsx(jme, J({}, e))
}), Qme = ["item", "applyValue", "type", "apiRef", "focusElementRef", "InputProps", "isFilterActive", "clearButton", "tabIndex", "disabled"];
function aB(e, t) {
function Vh(e) {
    disabled: h
  } = e, g = qt(e, Qme), v = Aa(), [w, C] = x.useState(() => aB(t.value, r)), [T, E] = x.useState(!1), O = mr(), P = $t(), I = x.useCallback((A) => {
    v.clear();
    const k = A.target.value;
    C(k), E(!0), v.start(P.filterDebounceMs, () => {
      const j = new Date(k);
        value: Number.isNaN(j.getTime()) ? void 0 : j
  }, [n, t, P.filterDebounceMs, v]);
    const A = aB(t.value, r);
    C(A);
  }, [t.value, r]), /* @__PURE__ */ $.jsx(P.slots.baseTextField, J({
      endAdornment: T ? /* @__PURE__ */ $.jsx(P.slots.loadIcon, {
      disabled: h
  }, g, (M = P.slotProps) == null ? void 0 : M.baseTextField));
process.env.NODE_ENV !== "production" && (Vh.propTypes = {
function wv(e, t, n, r) {
const AW = (e) => [{
  getApplyFilterFn: (t) => wv(t, (n, r) => n === r, e),
  InputComponent: Vh,
  getApplyFilterFn: (t) => wv(t, (n, r) => n !== r, e),
  InputComponent: Vh,
  getApplyFilterFn: (t) => wv(t, (n, r) => n > r, e),
  InputComponent: Vh,
  getApplyFilterFn: (t) => wv(t, (n, r) => n >= r, e),
  InputComponent: Vh,
  getApplyFilterFn: (t) => wv(t, (n, r) => n < r, e, !e),
  InputComponent: Vh,
  getApplyFilterFn: (t) => wv(t, (n, r) => n <= r, e),
  InputComponent: Vh,
}], Jme = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "hasFocus", "inputProps", "isValidating", "isProcessingProps", "onValueChange"], Zme = Ue(vm)({
}), ege = (e) => {
  }, Bn, t);
function NW(e) {
  } = e, f = qt(e, Jme), h = o.type === "dateTime", g = kn(), v = x.useRef(null), w = x.useMemo(() => {
    let A;
    n == null ? A = null : n instanceof Date ? A = n : A = new Date((n ?? "").toString());
    let k;
    return A == null || Number.isNaN(A.getTime()) ? k = "" : k = new Date(A.getTime() - A.getTimezoneOffset() * 60 * 1e3).toISOString().substr(0, h ? 16 : 10), {
      parsed: A,
      formatted: k
  }, [n, h]), [C, T] = x.useState(w), O = {
    classes: $t().classes
  }, P = ege(O), I = x.useCallback((A) => {
    if (A === "")
    const [k, j] = A.split("T"), [B, H, F] = k.split("-"), D = /* @__PURE__ */ new Date();
    if (D.setFullYear(Number(B), Number(H) - 1, Number(F)), D.setHours(0, 0, 0, 0), j) {
      const [q, U] = j.split(":");
      D.setHours(Number(q), Number(U), 0, 0);
    }
    return D;
  }, []), M = x.useCallback(async (A) => {
    const k = A.target.value, j = I(k);
    c && await c(A, j), T({
      parsed: j,
      formatted: k
      value: j
    }, A);
    T((A) => {
      var k, j;
      return w.parsed !== A.parsed && ((k = w.parsed) == null ? void 0 : k.getTime()) !== ((j = A.parsed) == null ? void 0 : j.getTime()) ? w : A;
  }, [w]), Lr(() => {
    s && v.current.focus();
  }, [s]), /* @__PURE__ */ $.jsx(Zme, J({
    inputRef: v,
    className: P.root,
    type: h ? "datetime-local" : "date",
      max: h ? "9999-12-31T23:59" : "9999-12-31"
process.env.NODE_ENV !== "production" && (NW.propTypes = {
const $W = (e) => /* @__PURE__ */ $.jsx(NW, J({}, e));
function LW({
const tge = (e, t, n, r) => {
  const o = DC(r.current.state, t);
  return LW({
}, nge = (e, t, n, r) => {
  const o = DC(r.current.state, t);
  return LW({
}, rge = J({}, yu, {
  sortComparator: Y5,
  valueFormatter: tge,
  filterOperators: AW(),
  renderEditCell: $W,
}), oge = J({}, yu, {
  sortComparator: Y5,
  valueFormatter: nge,
  filterOperators: AW(!0),
  renderEditCell: $W,
}), jf = (e) => e == null ? null : Number(e), ige = (e) => e == null || Number.isNaN(e) || e === "" ? null : (t) => jf(t) === jf(e), sge = () => [{
  getApplyFilterFn: (e) => e.value == null || Number.isNaN(e.value) ? null : (t) => jf(t) === e.value,
  InputComponent: Ma,
  getApplyFilterFn: (e) => e.value == null || Number.isNaN(e.value) ? null : (t) => jf(t) !== e.value,
  InputComponent: Ma,
  getApplyFilterFn: (e) => e.value == null || Number.isNaN(e.value) ? null : (t) => t == null ? !1 : jf(t) > e.value,
  InputComponent: Ma,
  getApplyFilterFn: (e) => e.value == null || Number.isNaN(e.value) ? null : (t) => t == null ? !1 : jf(t) >= e.value,
  InputComponent: Ma,
  getApplyFilterFn: (e) => e.value == null || Number.isNaN(e.value) ? null : (t) => t == null ? !1 : jf(t) < e.value,
  InputComponent: Ma,
  getApplyFilterFn: (e) => e.value == null || Number.isNaN(e.value) ? null : (t) => t == null ? !1 : jf(t) <= e.value,
  InputComponent: Ma,
  InputComponent: UD,
}], age = J({}, yu, {
  sortComparator: K5,
  valueFormatter: (e) => X5(e) ? e.toLocaleString() : e || "",
  filterOperators: sge(),
  getApplyQuickFilterFn: ige
function ly(e) {
function pm(e, t) {
function h_(e, t, n) {
const lge = ["id", "value", "formattedValue", "api", "field", "row", "rowNode", "colDef", "cellMode", "isEditable", "tabIndex", "className", "hasFocus", "isValidating", "isProcessingProps", "error", "onValueChange", "initialOpen"], uge = ["MenuProps"];
function cge(e) {
function jW(e) {
  var U, K;
  const t = $t(), {
    onValueChange: h,
    initialOpen: g = t.editMode === xc.Cell
  } = e, v = qt(e, lge), w = kn(), C = x.useRef(null), T = x.useRef(null), [E, O] = x.useState(g), I = (((U = t.slotProps) == null ? void 0 : U.baseSelect) || {}).native ?? !1, M = ((K = t.slotProps) == null ? void 0 : K.baseSelect) || {}, {
    MenuProps: A
  } = M, k = qt(M, uge);
  if (Lr(() => {
  }, [c]), !ly(a))
  const j = pm(a, {
  if (!j)
  const B = a.getOptionValue, H = a.getOptionLabel, F = async (ee) => {
    if (!ly(a) || !j)
    const G = ee.target, Y = h_(G.value, j, B);
    h && await h(ee, Y), await w.current.setEditCellValue({
      value: Y
  }, D = (ee, G) => {
    if (t.editMode === xc.Row) {
      const Y = w.current.getCellParams(n, o);
      w.current.publishEvent("cellEditStop", J({}, Y, {
        reason: ee.key === "Escape" ? lu.escapeKeyDown : lu.cellFocusOut
    cge(ee) && ee.key === "Enter" || O(!0);
  return !j || !a ? null : /* @__PURE__ */ $.jsx(t.slots.baseSelect, J({
    onChange: F,
      onClose: D
    }, A),
  }, v, k, {
    children: j.map((ee) => {
      var Y;
      const G = B(ee);
      return /* @__PURE__ */ x.createElement(t.slots.baseSelectOption, J({}, ((Y = t.slotProps) == null ? void 0 : Y.baseSelectOption) || {}, {
      }), H(ee));
process.env.NODE_ENV !== "production" && (jW.propTypes = {
const dge = (e) => /* @__PURE__ */ $.jsx(jW, J({}, e)), fge = ["item", "applyValue", "type", "apiRef", "focusElementRef", "placeholder", "tabIndex", "label", "variant", "isFilterActive", "clearButton", "InputLabelProps"], pge = ({
}) => ["", ...pm(e) || []].map((c) => {
  let h = n(c);
  return h === "" && (h = ""), /* @__PURE__ */ x.createElement(t, J({}, s, {
  }), h);
}), hge = Ue("div")({
function iI(e) {
  var B, H, F, D, q;
    variant: h = "standard",
  } = e, v = qt(e, fge), w = t.value ?? "", C = mr(), T = mr(), E = $t(), O = ((H = (B = E.slotProps) == null ? void 0 : B.baseSelect) == null ? void 0 : H.native) ?? !1;
  let P = null;
    const U = o.current.getColumn(t.field);
    ly(U) && (P = U);
  const I = P == null ? void 0 : P.getOptionValue, M = P == null ? void 0 : P.getOptionLabel, A = x.useMemo(() => pm(P), [P]), k = x.useCallback((U) => {
    let K = U.target.value;
    K = h_(K, A, I), n(J({}, t, {
      value: K
  }, [A, I, n, t]);
  if (!ly(P))
  const j = f ?? o.current.getLocaleText("filterPanelInputLabel");
  return /* @__PURE__ */ $.jsxs(hge, {
      children: [/* @__PURE__ */ $.jsx(E.slots.baseInputLabel, J({}, (F = E.slotProps) == null ? void 0 : F.baseInputLabel, {
        variant: h,
        children: j
        label: j,
        onChange: k,
        variant: h,
        notched: h === "outlined" ? !0 : void 0
      }, v, (D = E.slotProps) == null ? void 0 : D.baseSelect, {
        children: pge({
          column: P,
process.env.NODE_ENV !== "production" && (iI.propTypes = {
const mge = ["item", "applyValue", "type", "apiRef", "focusElementRef", "color", "error", "helperText", "size", "variant"], gge = ["key"], vge = hV();
function FW(e) {
    variant: h = "standard"
  } = e, g = qt(e, mge), v = {
    variant: h
  }, w = mr(), C = $t();
    const k = r.current.getColumn(t.field);
    ly(k) && (T = k);
  const E = T == null ? void 0 : T.getOptionValue, O = T == null ? void 0 : T.getOptionLabel, P = x.useCallback((k, j) => E(k) === E(j), [E]), I = x.useMemo(() => pm(T) || [], [T]), M = x.useMemo(() => Array.isArray(t.value) ? t.value.reduce((k, j) => {
    const B = I.find((H) => E(H) === j);
    return B != null && k.push(B), k;
  }, []) : [], [E, t.value, I]), A = x.useCallback((k, j) => {
      value: j.map(E)
  return /* @__PURE__ */ $.jsx(lD, J({
    isOptionEqualToValue: P,
    filterOptions: vge,
    onChange: A,
    renderTags: (k, j) => k.map((B, H) => {
      const F = j({
        index: H
        key: D
      } = F, q = qt(F, gge);
        label: O(B)
      }, q), D);
    renderInput: (k) => {
      var j;
      return /* @__PURE__ */ $.jsx(C.slots.baseTextField, J({}, k, {
        InputLabelProps: J({}, k.InputLabelProps, {
      }, v, (j = C.slotProps) == null ? void 0 : j.baseTextField));
process.env.NODE_ENV !== "production" && (FW.propTypes = {
const Sv = (e) => e == null || !VD(e) ? e : e.value, yge = () => [{
  getApplyFilterFn: (e) => e.value == null || e.value === "" ? null : (t) => Sv(t) === Sv(e.value),
  InputComponent: iI
  getApplyFilterFn: (e) => e.value == null || e.value === "" ? null : (t) => Sv(t) !== Sv(e.value),
  InputComponent: iI
    const t = e.value.map(Sv);
    return (n) => t.includes(Sv(n));
  InputComponent: FW
}], bge = (e) => typeof e[0] == "object", wge = (e) => VD(e) ? e.value : e, Sge = (e) => VD(e) ? e.label : String(e), Cge = J({}, yu, {
  getOptionLabel: Sge,
  getOptionValue: wge,
    const o = DC(r.current.state, t);
    if (!ly(n))
    const s = pm(n, {
    if (!bge(s))
  renderEditCell: dge,
  filterOperators: yge(),
    const r = n, o = pm(r) || [], s = r.getOptionValue;
}), xge = "string", Ege = () => ({
  string: yu,
  number: age,
  date: rge,
  dateTime: oge,
  boolean: gW,
  singleSelect: Cge,
  [C1]: lme,
  custom: yu
}), ZD = (e) => e.headerFiltering, Tge = en(
  ZD,
), _ge = en(ZD, (e) => e.editing), Oge = en(ZD, (e) => e.menuOpen), R1 = (e) => e.columnGrouping, zW = ar(R1, (e) => (e == null ? void 0 : e.unwrappedGroupingModel) ?? {}), BW = ar(R1, (e) => (e == null ? void 0 : e.lookup) ?? {}), Rge = ar(R1, (e) => (e == null ? void 0 : e.headerStructure) ?? []), AC = en(R1, (e) => (e == null ? void 0 : e.maxDepth) ?? 0), HW = ["maxWidth", "minWidth", "width", "flex"], BP = Ege();
function kge({
    let c = e, f = t, h = 0;
      const v = n[g];
      if (o.all[v.field] && o.all[v.field].frozen === !0)
      let C = c / f * v.flex;
      C < v.minWidth ? (h += v.minWidth - C, C = v.minWidth, a.min[v.field] = !0) : C > v.maxWidth && (h += v.maxWidth - C, C = v.maxWidth, a.max[v.field] = !0), o.all[v.field] = {
        flex: v.flex
    h < 0 ? Object.keys(a.max).forEach((g) => {
    }) : h > 0 ? Object.keys(a.min).forEach((g) => {
const sI = (e, t) => {
    let h = e.lookup[f], g = 0, v = !1;
    e.columnVisibilityModel[f] !== !1 && (h.flex && h.flex > 0 ? (r += h.flex, v = !0) : g = La(h.width || yu.width, h.minWidth || yu.minWidth, h.maxWidth || yu.maxWidth), o += g), h.computedWidth !== g && (h = J({}, h, {
    })), v && s.push(h), n[f] = h;
    const f = kge({
    Object.keys(f).forEach((h) => {
      n[h].computedWidth = f[h].computedWidth;
}, Pge = (e, t) => {
    const v = n[g];
    e.lookup[v] && (s[v] = !0, a.push(v));
    const v = o[g], w = J({}, f[v], {
    Object.entries(r[v]).forEach(([C, T]) => {
    }), f[v] = w;
function lB(e) {
  let t = BP[xge];
  return e && BP[e] && (t = BP[e]), t;
const Ov = ({
  columnVisibilityModel: r = bl(e),
  var g, v;
    const w = bc(e.current.state);
    T == null ? (T = J({}, lB(w.type), {
    }), a.orderedFields.push(C)) : o && a.orderedFields.push(C), T && T.type !== w.type && (T = J({}, lB(w.type), {
    HW.forEach((O) => {
    }), a.lookup[C] = Wv(T, J({}, w, {
  const f = e.current.unstable_applyPipeProcessors("hydrateColumns", a), h = Pge(f, n);
  return sI(h, ((v = (g = e.current).getRootDimensions) == null ? void 0 : v.call(g)) ?? void 0);
function Mge({
        const h = o[c].id, g = t.current.unstable_getCellColSpanInfo(h, s);
function k1(e, t) {
  const n = xy(e), r = AC(e), o = Tge(e), s = Math.floor(t.columnHeaderHeight * n), a = Math.floor((t.columnGroupHeaderHeight ?? t.columnHeaderHeight) * n), c = o ? Math.floor((t.headerFilterHeight ?? t.columnHeaderHeight) * n) : 0;
const Py = (e) => e.rowsMeta, m_ = 1, VW = 1.5, Ige = (e) => {
  return mt(r, Bn, n);
}, Dge = jr("div", {
})), Age = RC(vi, (e, t) => t === "left" ? e.leftPinnedWidth : t === "right" ? e.rightPinnedWidth + (e.hasScrollX ? e.scrollbarSize : 0) : 0);
function Nge(e) {
  const t = kn(), [n, r] = x.useState("none");
  return Ot(t, "columnHeaderDragStart", () => r("horizontal")), Ot(t, "columnHeaderDragEnd", () => r("none")), Ot(t, "rowDragStart", () => r("vertical")), Ot(t, "rowDragEnd", () => r("none")), n === "none" ? null : n === "horizontal" ? /* @__PURE__ */ $.jsx($ge, J({}, e)) : /* @__PURE__ */ $.jsx(Lge, J({}, e));
function $ge(e) {
  } = e, r = x.useRef(null), o = kn(), s = Aa(), a = Ze(o, xy), c = Ze(o, w1), f = tC(o, Age, t), h = () => {
    const E = vi(o.current.state);
  }, g = $t(), v = k1(o, g), w = Math.floor(g.columnHeaderHeight * a), C = J({
    top: v - w
  } : {}), T = Fn((E) => {
    O = (O - m_) * VW + m_, s.start(0, () => {
  return /* @__PURE__ */ $.jsx(UW, J({}, e, {
    getCanScrollMore: h,
function Lge(e) {
  } = e, r = x.useRef(null), o = kn(), s = Aa(), a = Ze(o, Py), c = () => {
    const w = vi(o.current.state);
  }, f = $t(), h = k1(o, f), g = {
    top: t === "up" ? h : void 0,
  }, v = Fn((w) => {
    C = (C - m_) * VW + m_, s.start(0, () => {
  return /* @__PURE__ */ $.jsx(UW, J({}, e, {
    handleDragOver: v
const UW = Qn(function(t, n) {
  } = t, c = kn(), [f, h] = x.useState(o), g = $t(), v = J({}, g, {
  }), w = Ige(v);
    h(o);
  }), f ? /* @__PURE__ */ $.jsx(Dge, {
    ownerState: v,
}), aT = Id(Nge);
var eA = {}, WW = { exports: {} }, GW = { exports: {} };
})(GW);
var jge = GW.exports;
  var t = jge.default;
    return (e.exports = n = function(f, h) {
      if (!h && f && f.__esModule) return f;
      var g, v, w = {
      if (g = h ? a : s) {
      for (var C in f) C !== "default" && {}.hasOwnProperty.call(f, C) && ((v = (g = Object.defineProperty) && Object.getOwnPropertyDescriptor(f, C)) && (v.get || v.set) ? g(w, C, v) : w[C] = f[C]);
})(WW);
var Fge = WW.exports, zge = Fge.default;
Object.defineProperty(eA, "__esModule", {
var qW = eA.default = void 0, Bge = zge(x);
qW = eA.default = parseInt(Bge.version, 10);
const tA = /* @__PURE__ */ x.createContext(void 0);
process.env.NODE_ENV !== "production" && (tA.displayName = "GridPrivateApiContext");
function Ba() {
  const e = x.useContext(tA);
const Qf = (e, t) => IC(e), nA = (e, t) => Ze(e, IC), Hge = typeof navigator < "u" ? navigator.userAgent.toLowerCase() : "empty", Vge = Hge.includes("firefox"), P1 = (e) => e.virtualization;
en(P1, (e) => e.enabled);
const KW = en(P1, (e) => e.enabledForColumns), Uge = en(P1, (e) => e.enabledForRows), NC = en(P1, (e) => e.renderContext), Wge = ar((e) => e.virtualization.renderContext.firstColumnIndex, (e) => e.virtualization.renderContext.lastColumnIndex, (e, t) => ({
})), aI = {
}, Gge = (e, t) => {
      renderContext: aI
function qge(e, t) {
  On(e, {
const rA = (e) => e.rowSpanning, YW = en(rA, (e) => e.hiddenCells), Kge = en(rA, (e) => e.spannedCells), Yge = en(rA, (e) => e.hiddenCellOriginMap), uy = (e) => e.listViewColumn, Xge = L5(Ms, NC, IC, mo, yl, (e, t, n, r, o) => {
  const a = n.rowToIndexMap.get(s), c = r.slice(t.firstColumnIndex, t.lastColumnIndex).findIndex((h) => h.field === e.field);
}), XW = ar(Xge, mo, IC, yl, Ms, (e, t, n, r, o) => {
function Dv(e, t) {
const g_ = typeof window < "u" && /jsdom|HappyDOM/.test(window.navigator.userAgent), HP = 50;
var jo = /* @__PURE__ */ function(e) {
}(jo || {});
const uB = {
}, Qge = Object.freeze(/* @__PURE__ */ new Map()), Jge = (e, t, n, r, o) => ({
  direction: jo.NONE,
  buffer: JW(e, jo.NONE, t, n, r, o)
}), Zge = () => {
  const e = Ba(), t = $t(), {
  } = t, r = Ze(e, () => n ? [uy(e.current.state)] : mo(e)), o = Ze(e, Uge) && !g_, s = Ze(e, KW) && !g_, a = Ze(e, Ey), c = _y(e), f = n ? f_ : c, h = a.bottom.length > 0, [g, v] = x.useState(Qge), w = _c(), C = Ze(e, Xf), T = nA(e), E = e.current.mainElementRef, O = e.current.virtualScrollerRef, P = e.current.virtualScrollbarVerticalRef, I = e.current.virtualScrollbarHorizontalRef, M = Ze(e, Ghe), A = x.useRef(!1), k = Ze(e, BD), j = Ze(e, ahe), B = Ze(e, w1), H = Ze(e, eve), F = Ze(e, U5), D = Ze(e, V5), q = x.useRef(null), U = x.useCallback((Ce) => {
      width: Dv(Ne.width, 1),
      height: Dv(Ne.height, 1)
    const tt = new ResizeObserver((Le) => {
      const rt = Le[0];
        width: Dv(rt.contentRect.width, 1),
        height: Dv(rt.contentRect.height, 1)
    if (tt.observe(Ce), qW >= 19)
  }, [e, E]), K = x.useRef(((ce = t.initialState) == null ? void 0 : ce.scroll) ?? uB), ee = x.useRef(!1), G = x.useRef(uB), Y = x.useRef(aI), X = Ze(e, NC), te = Ze(e, XW), re = Aa(), Q = x.useRef(void 0), V = Ml(() => Jge(w, t.rowBufferPx, t.columnBufferPx, k * 15, HP * 6)).current, ie = x.useCallback((Ce) => {
    if (pB(Ce, e.current.state.virtualization.renderContext))
    const Ne = Ce.firstRowIndex !== Y.current.firstRowIndex || Ce.lastRowIndex !== Y.current.lastRowIndex;
    })), vi(e.current.state).isReady && Ne && (Y.current = Ce, e.current.publishEvent("renderedRowsIntervalChange", Ce)), G.current = K.current;
  }, [e]), de = Fn(() => {
    const Ne = vi(e.current.state), Be = Math.ceil(Ne.minimumSize.height - Ne.viewportOuterSize.height), tt = Math.ceil(Ne.minimumSize.width - Ne.viewportInnerSize.width), Le = {
      top: La(Ce.scrollTop, 0, Be),
      left: w ? La(Ce.scrollLeft, -tt, 0) : La(Ce.scrollLeft, 0, tt)
    }, rt = Le.left - K.current.left, ot = Le.top - K.current.top, wt = rt !== 0 || ot !== 0;
    K.current = Le;
    const gt = wt ? rve(rt, ot) : jo.NONE, nt = Math.abs(K.current.top - G.current.top), Ft = Math.abs(K.current.left - G.current.left), ut = nt >= k || Ft >= HP, Et = V.direction !== gt;
        case jo.NONE:
        case jo.LEFT:
        case jo.RIGHT:
    V.direction = gt, V.buffer = JW(w, gt, t.rowBufferPx, t.columnBufferPx, k * 15, HP * 6);
    const At = cB(e, t, o, s), vt = dB(At, K.current, V);
    return pB(vt, X) || (E_.flushSync(() => {
    if (!vi(e.current.state).isReady && (o || s))
    const Ce = cB(e, t, o, s), Ne = dB(Ce, K.current, V);
  }, he = Fn(() => {
      top: K.current.top,
      left: K.current.left,
  }), ge = Fn((Ce) => {
  }), fe = Fn((Ce) => {
    const Ne = Xo(e);
    const tt = !h && Ce.position === void 0 || h && Ce.position === "bottom", Le = Ce.position !== void 0;
    const ot = Ce.rows ?? T.rows, wt = Be.firstRowIndex, gt = Math.min(Be.lastRowIndex, ot.length), nt = Ce.rows ? Xz(0, Ce.rows.length) : Xz(wt, gt);
    !Le && te && (te.rowIndex < wt && (nt.unshift(te.rowIndex), Ft = te.rowIndex), te.rowIndex > gt && (nt.push(te.rowIndex), Ft = te.rowIndex));
    const ut = [], Et = (At = t.slotProps) == null ? void 0 : At.row, Tt = pp(e);
      var Qo, Jo, Wt;
      const Ie = (((Qo = T == null ? void 0 : T.range) == null ? void 0 : Qo.firstRowIndex) || 0) + rt + vt;
        const gr = f.left.length, Zo = r.length - f.right.length;
          minFirstColumn: gr,
          maxLastColumn: Zo,
        if (Le)
          const gr = T.rows.length - 1;
          vt === gr && (bt = !0);
      const Lt = vt === Ft, Cn = (te == null ? void 0 : te.rowIndex) === Ie, pn = QW(Tt, St, f.left.length), Or = We && Ce.position === "top", lr = St.firstColumnIndex, Fr = St.lastColumnIndex;
        offsetLeft: pn,
        columnsTotalWidth: B,
        firstColumnIndex: lr,
        lastColumnIndex: Fr,
        focusedColumnIndex: Cn ? te.columnIndex : void 0,
        isNotVisible: Lt,
        showBottomBorder: Or,
        scrollbarWidth: F,
        gridHasFiller: D
      }, Et), Xe)), Lt)
      const Rr = g.get(Xe);
      Rr && ut.push(Rr), Ce.position === void 0 && We && ut.push((Wt = (Jo = e.current).getInfiniteLoadingTriggerElement) == null ? void 0 : Wt.call(Jo, {
    overflowX: !H || n ? "hidden" : void 0,
  }), [H, t.autoHeight, n]), we = x.useMemo(() => {
      width: H ? B : "auto",
      flexBasis: j,
    return Ce.flexBasis === 0 && (Ce.flexBasis = cW), Ce;
  }, [B, j, H]), _e = x.useCallback((Ce) => {
      columnsTotalWidth: B,
      contentHeight: j
  }, [e, B, j]);
  return Lr(() => {
    A.current && ((Ne = (Ce = e.current).updateRenderContext) == null || Ne.call(Ce));
  }, [e, s, o]), Lr(() => {
  }, [n, O]), Hme(X !== aI, () => {
      top: K.current.top,
      left: K.current.left,
    }), A.current = !0, (Ce = t.initialState) != null && Ce.scroll && O.current) {
      } = t.initialState.scroll, Le = {
      if (!Le.left && B && (Ne.scrollLeft = tt, ee.current = !0, Le.left = !0), !Le.top && j && (Ne.scrollTop = Be, ee.current = !0, Le.top = !0), !Le.top || !Le.left) {
          !Le.left && ot.columnsTotalWidth && (Ne.scrollLeft = tt, ee.current = !0, Le.left = !0), !Le.top && ot.contentHeight && (Ne.scrollTop = Be, ee.current = !0, Le.top = !0), Le.left && Le.top && rt();
  }), hr(e, "sortedRowsSet", ue), hr(e, "paginationModelChange", ue), hr(e, "columnsChange", ue), {
    setPanels: v,
      ref: U
      tabIndex: Vge ? -1 : void 0
      ref: P,
      scrollPosition: K
      scrollPosition: K
      scrollPosition: K
function eve(e) {
function cB(e, t, n, r) {
  const o = vi(e.current.state), s = Qf(e), a = t.unstable_listView ? [uy(e.current.state)] : mo(e), c = Yge(e), f = e.current.state.rows.dataRowIds.at(-1), h = a.at(-1);
    lastColumnWidth: (h == null ? void 0 : h.computedWidth) ?? 0,
    rowsMeta: Py(e.current.state),
    columnPositions: pp(e),
    pinnedColumns: _y(e),
function dB(e, t, n) {
    let f = Math.min(fB(e, o, {
    const h = e.hiddenCellsOriginMap[f];
    if (h) {
      const v = Math.min(...Object.values(h));
      f = Math.min(f, v);
    const g = e.autoHeight ? f + e.rows.length : fB(e, o + e.viewportInnerHeight);
    let f = 0, h = e.columnPositions.length, g = !1;
    const [v, w] = lI({
      for (let C = v; C < w && !g; C += 1) {
    (!g || e.virtualizeColumnsWithAutoRowHeight) && (f = rp(a, e.columnPositions, {
    }), h = rp(a + e.viewportInnerWidth, e.columnPositions)), r.firstColumnIndex = f, r.lastColumnIndex = h;
  return tve(e, r, n);
function fB(e, t, n) {
  const s = La(r - (((c = e.range) == null ? void 0 : c.firstRowIndex) || 0), 0, e.rowsMeta.positions.length);
  return o || e.rowsMeta.positions[s] >= t ? rp(t, e.rowsMeta.positions, n) : nve(t, e.rowsMeta.positions, s, n);
function tve(e, t, n) {
  const [r, o] = lI({
  }), [s, a] = lI({
  }), c = Mge({
function rp(e, t, n = void 0, r = 0, o = t.length) {
  return c ? rp(e, t, n, r, s) : rp(e, t, n, s + 1, o);
function nve(e, t, n, r = void 0) {
  return rp(e, t, r, Math.floor(n / 2), Math.min(n, t.length));
function lI({
  const f = a[e] - n, h = a[t] + r, g = rp(f, a, {
  }), v = rp(h, a);
  return [La(g, o, s), La(v, o, s)];
function pB(e, t) {
function QW(e, t, n) {
function rve(e, t) {
  return e === 0 && t === 0 ? jo.NONE : Math.abs(t) >= Math.abs(e) ? t > 0 ? jo.DOWN : jo.UP : e > 0 ? jo.RIGHT : jo.LEFT;
function JW(e, t, n, r, o, s) {
      case jo.LEFT:
        t = jo.RIGHT;
      case jo.RIGHT:
        t = jo.LEFT;
    case jo.NONE:
    case jo.LEFT:
    case jo.RIGHT:
    case jo.UP:
    case jo.DOWN:
const ove = () => {
  var v, w;
  const e = kn(), t = $t(), n = Ze(e, kC), r = Ze(e, KD), o = Ze(e, G5), s = n === 0 && o === 0, a = Ze(e, Ohe), c = !a && s, f = !a && n > 0 && r === 0;
  let h = null, g = null;
  return c && (h = "noRowsOverlay"), f && (h = "noResultsOverlay"), a && (h = "loadingOverlay", g = ((w = (v = t.slotProps) == null ? void 0 : v.loadingOverlay) == null ? void 0 : w[s ? "noRowsVariant" : "variant"]) || null), {
    overlayType: h,
}, ive = jr("div", {
)), sve = jr("div", {
})({}), ave = (e) => {
  }, Bn, t);
function ZW(e) {
  const t = kn(), n = $t(), r = Ze(t, vi);
  o === 0 && (o = cW);
  const s = ave(J({}, e, {
  return /* @__PURE__ */ $.jsx(ive, J({
    children: /* @__PURE__ */ $.jsx(sve, J({
process.env.NODE_ENV !== "production" && (ZW.propTypes = {
process.env.NODE_ENV !== "production" && (e4.propTypes = {
function e4(e) {
  } = e, n = $t();
  return /* @__PURE__ */ $.jsx(ZW, J({}, e, {
const _T = (e) => e.columnMenu;
function lve() {
  const e = Ba(), t = $t(), n = Ze(e, mo), r = Ze(e, Pme), o = Ze(e, _me), s = Ze(e, EW), a = Ze(e, () => QD(e) === null), c = Ze(e, zme), f = Ze(e, Fme), h = Ze(e, p_), g = Ze(e, AC), v = Ze(e, _T), w = Ze(e, bl), C = Ze(e, Rge), T = !(c === null && s === null && a), E = e.current.columnHeadersContainerRef;
    columnGroupHeaderFocus: h,
    columnMenuState: v,
const uve = Id(lve), oA = /* @__PURE__ */ x.createContext(void 0);
process.env.NODE_ENV !== "production" && (oA.displayName = "GridConfigurationContext");
const iA = () => {
  const e = x.useContext(oA);
}, cve = jr("div")({
}), dve = jr("div", {
}), fve = Qn((e, t) => {
  } = e, r = $t(), s = iA().hooks.useGridAriaAttributes();
  return /* @__PURE__ */ $.jsxs(dve, J({
    children: [/* @__PURE__ */ $.jsx(cve, {
}), pve = () => mt({
}, Bn, {}), hve = jr("div")({
function mve(e) {
  const t = pve();
  return /* @__PURE__ */ $.jsx(hve, J({}, e, {
const gve = () => mt({
}, Bn, {}), vve = jr("div")({
function yve(e) {
  const t = gve();
  return /* @__PURE__ */ $.jsx(vve, J({}, e, {
const bve = (e, t) => {
  }, Bn, n);
}, wve = jr("div", {
})({}), Sve = Qn(function(t, n) {
  const r = $t(), o = !r.autoHeight && ((c = t.style) == null ? void 0 : c.minHeight) === "auto", s = bve(r, o), a = {
  return /* @__PURE__ */ $.jsx(wve, J({}, t, {
}), Cve = jr("div")({
}), t4 = jr("div")({
}), xve = jr(t4)({
}), Eve = jr(t4)({
}), Tve = jr("div")({
function _ve({
  const t = kn(), {
  } = Ze(t, vi), h = o ? a : 0, g = n.height - r.height > 0;
  return h === 0 && !g ? null : /* @__PURE__ */ $.jsxs(Cve, {
      height: h,
    children: [c > 0 && /* @__PURE__ */ $.jsx(xve, {
    }), /* @__PURE__ */ $.jsx(Tve, {}), f > 0 && /* @__PURE__ */ $.jsx(Eve, {
const Ove = Id(_ve), Rve = ["className"], kve = (e) => {
  }, Bn, t);
}, Pve = jr("div", {
}), Mve = Qn(function(t, n) {
  } = t, o = qt(t, Rve), s = kn(), a = $t(), c = kve(a), f = Ze(s, () => {
    const h = NC(s);
    return Py(s.current.state).positions[h.firstRowIndex] ?? 0;
  return /* @__PURE__ */ $.jsx(Pve, J({
}), Ive = {
}, gi = (e) => e.editRows, n4 = RC(gi, (e, {
}) => n === xc.Row && !!e[t]), Dve = RC(gi, (e, {
}), oC = (e) => e.preferencePanel, Ave = RC(oC, (e, t) => !!(e.open && e.labelId === t));
var hm = /* @__PURE__ */ function(e) {
}(hm || {});
const Nve = (e, t) => {
  return mt(r, Bn, n);
}, r4 = jr("div")({
}), $ve = jr(r4)({
}), Lve = jr(r4)({
}), hB = Qn(function(t, n) {
  const r = Ba(), o = $t(), s = x.useRef(!1), a = x.useRef(0), c = x.useRef(null), f = x.useRef(null), h = Nve(o, t.position), g = Ze(r, vi), v = t.position === "vertical" ? "height" : "width", w = t.position === "vertical" ? "scrollTop" : "scrollLeft", C = t.position === "vertical" ? "top" : "left", T = t.position === "vertical" ? g.hasScrollX : g.hasScrollY, E = g.minimumSize[v] + (T ? g.scrollbarSize : 0), P = (t.position === "vertical" ? g.viewportInnerSize.height : g.viewportOuterSize.width) * (E / g.viewportOuterSize[v]), I = Fn(() => {
    const k = c.current, j = t.scrollPosition.current;
    if (!k || j[C] === a.current)
    if (a.current = j[C], s.current) {
    const B = j[C] / E;
    k[w] = B * P;
  }), M = Fn(() => {
    const k = r.current.virtualScrollerRef.current, j = c.current;
    if (!j)
    const B = j[w] / P;
    k[w] = B * E;
  HI(() => {
    const k = r.current.virtualScrollerRef.current, j = c.current, B = {
    return k.addEventListener("scroll", I, B), j.addEventListener("scroll", M, B), () => {
      k.removeEventListener("scroll", I, B), j.removeEventListener("scroll", M, B);
    f.current.style.setProperty(v, `${P}px`);
  }, [P, v]);
  const A = t.position === "vertical" ? $ve : Lve;
  return /* @__PURE__ */ $.jsx(A, {
    ref: Ir(n, c),
    className: h.root,
    onFocus: (k) => {
      k.target.blur();
      className: h.content
}), jve = (e) => {
  }, Bn, t);
}, Fve = jr("div", {
}), zve = (e) => e.dimensions.rightPinnedWidth > 0;
function Bve(e) {
  const t = kn(), n = $t(), r = Ze(t, uhe), o = Ze(t, lhe), s = Ze(t, zve), a = Ze(t, fhe), c = ove(), f = {
  }, h = jve(f), g = Zge(), {
    getContainerProps: v,
    getRows: P,
  } = g, M = P();
  return /* @__PURE__ */ $.jsxs(fve, J({
    className: h.root
  }, v(), {
    children: [/* @__PURE__ */ $.jsx(aT, J({
    }, I())), /* @__PURE__ */ $.jsx(aT, J({
    }, I())), /* @__PURE__ */ $.jsx(aT, J({
    }, I())), /* @__PURE__ */ $.jsx(aT, J({
    }, I())), /* @__PURE__ */ $.jsxs(Fve, J({
      className: h.scroller
      children: [/* @__PURE__ */ $.jsxs(mve, {
        children: [!n.unstable_listView && /* @__PURE__ */ $.jsx(uve, {}), /* @__PURE__ */ $.jsx(n.slots.pinnedRows, {
      }), /* @__PURE__ */ $.jsx(e4, J({}, c)), /* @__PURE__ */ $.jsx(Sve, J({}, C(), {
        children: /* @__PURE__ */ $.jsxs(Mve, J({}, T(), {
      })), a && /* @__PURE__ */ $.jsx(Ove, {
      }), /* @__PURE__ */ $.jsx(yve, {
    })), o && !n.unstable_listView && /* @__PURE__ */ $.jsx(hB, J({
    }, O())), r && /* @__PURE__ */ $.jsx(hB, J({
function Hve() {
  const e = $t();
let VP;
function Vve() {
  return VP === void 0 && document.createElement("div").focus({
      return VP = !0, !1;
  }), VP;
function Uve({
function Wve(e) {
function Gve(e) {
  return x.useMemo(() => Wve(e), [e]);
const qve = [(e) => e.autoPageSize && e.autoHeight && ["MUI X: `<DataGrid autoPageSize={true} autoHeight={true} />` are not valid props.", "You cannot use both the `autoPageSize` and `autoHeight` props at the same time because `autoHeight` scales the height of the Data Grid according to the `pageSize`.", "", "Please remove one of these two props."].join(`
`) || void 0, (e) => e.signature === $a.DataGrid && e.paginationMode === "client" && X5(e.rowCount) && ['MUI X: Usage of the `rowCount` prop with client side pagination (`paginationMode="client"`) has no effect.', '`rowCount` is only meant to be used with `paginationMode="server"`.'].join(`
function Kve(e, t) {
    r && Cl(r, "error");
const Yve = (e) => {
}, Xve = (e) => e === fW || Yve(e) !== null, o4 = (e, t) => {
      if (e === $n.LEFT)
      if (e === $n.RIGHT)
      if (e === $n.LEFT)
      if (e === $n.RIGHT)
function M1(e, t, n, r) {
  const o = o4(n, t);
const Qve = ["column", "row", "rowId", "rowNode", "align", "children", "colIndex", "width", "className", "style", "colSpan", "disableDragEvents", "isNotVisible", "pinnedOffset", "pinnedPosition", "showRightBorder", "showLeftBorder", "onClick", "onDoubleClick", "onMouseDown", "onMouseUp", "onMouseOver", "onKeyDown", "onKeyUp", "onDragEnter", "onDragOver"], Jve = ["changeReason", "unstable_updateValueOnRender"];
$n.LEFT + "", Lf.LEFT, $n.RIGHT + "", Lf.RIGHT, $n.NONE + "", $n.VIRTUAL + "";
const Zve = (e) => {
  } = e, h = {
    root: ["cell", `cell--text${He(t)}`, a && "selected", s && "cell--editable", n && "cell--withLeftBorder", r && "cell--withRightBorder", o === $n.LEFT && "cell--pinnedLeft", o === $n.RIGHT && "cell--pinnedRight", c && !s && "cell--selectionMode"]
  return mt(h, Bn, f);
let mB = !1;
const i4 = Qn(function(t, n) {
    width: h,
    style: v,
    showRightBorder: P,
    onDoubleClick: A,
    onMouseDown: k,
    onMouseUp: j,
    onMouseOver: B,
    onKeyDown: H,
    onKeyUp: F,
    onDragEnter: D,
  } = t, U = qt(t, Qve), K = Ba(), ee = $t(), G = _c(), Y = r.field, X = tC(K, Dve, {
    field: Y
  }), re = iA().hooks.useCellAggregationResult(s, Y), Q = X ? fr.Edit : fr.View, V = K.current.getCellParamsForRow(s, Y, o, {
    tabIndex: Ze(K, () => {
      const bt = QD(K);
      return bt && bt.field === Y && bt.id === s ? 0 : -1;
    hasFocus: Ze(K, () => {
      const bt = Ms(K);
      return (bt == null ? void 0 : bt.id) === s && bt.field === Y;
  V.api = K.current, re && (V.value = re.value, V.formattedValue = r.valueFormatter ? r.valueFormatter(V.value, o, r, K) : V.value);
  const ie = Ze(K, () => K.current.unstable_applyPipeProcessors("isCellSelected", !1, {
    field: Y
  })), de = Ze(K, YW), ue = Ze(K, Kge), {
  } = V, pe = r.type === "actions" && ((Ie = r.getActions) == null ? void 0 : Ie.call(r, K.current.getRowParams(s)).some((bt) => !bt.props.disabled)), be = (Q === "view" || !ge) && !pe ? V.tabIndex : -1, {
  } = ee, Ce = [Ze(K, () => K.current.unstable_applyPipeProcessors("cellClassName", [], {
    field: Y
  r.cellClassName && Ce.push(typeof r.cellClassName == "function" ? r.cellClassName(V) : r.cellClassName), r.display === "flex" && Ce.push(se["cell--flex"]), _e && Ce.push(_e(V));
  const Ne = V.formattedValue ?? fe, Be = x.useRef(null), tt = Ir(n, Be), Le = x.useRef(null), rt = ee.cellSelection ?? !1, ot = {
    showRightBorder: P,
  }, wt = Zve(ot), gt = x.useCallback((bt) => (We) => {
    const St = K.current.getCellParams(s, Y || "");
    K.current.publishEvent(bt, St, We), j && j(We);
  }, [K, Y, j, s]), nt = x.useCallback((bt) => (We) => {
    const St = K.current.getCellParams(s, Y || "");
    K.current.publishEvent(bt, St, We), k && k(We);
  }, [K, Y, k, s]), Ft = x.useCallback((bt, We) => (St) => {
    if (!K.current.getRow(s))
    const Lt = K.current.getCellParams(s, Y || "");
    K.current.publishEvent(bt, Lt, St), We && We(St);
  }, [K, Y, s]), ut = ((pt = de[s]) == null ? void 0 : pt[Y]) ?? !1, Et = ((yt = ue[s]) == null ? void 0 : yt[Y]) ?? 1, Tt = x.useMemo(() => {
    const bt = M1(J({
      "--width": `${h}px`
    }, v), G, O, E), We = O === $n.LEFT, St = O === $n.RIGHT;
  }, [h, T, v, E, O, G, Et]);
    if (!he || Q === fr.Edit)
    const bt = go(K.current.rootElementRef.current);
      const We = Be.current.querySelector('[tabindex="0"]'), St = Le.current || We || Be.current;
      if (Vve())
        const Lt = K.current.getScrollPosition();
        St.focus(), K.current.scroll(Lt);
  }, [he, Q, K]), ut)
  let At = U.onFocus;
    const We = Ms(K);
    if ((We == null ? void 0 : We.id) === s && We.field === Y) {
      typeof U.onFocus == "function" && U.onFocus(bt);
    mB || (console.warn([`MUI X: The cell with id=${s} and field=${Y} received focus.`, `According to the state, the focus should be at id=${We == null ? void 0 : We.id}, field=${We == null ? void 0 : We.field}.`, "Not syncing the state may cause unwanted behaviors since the `cellFocusIn` event won't be fired.", "Call `fireEvent.mouseUp` before the `fireEvent.click` to sync the focus with the state."].join(`
`)), mB = !0);
  if (X === null && r.renderCell && (vt = r.renderCell(V)), X !== null && r.renderEditCell) {
    const bt = K.current.getRowWithUpdatedValues(s, r.field), We = qt(X, Jve), St = r.valueFormatter ? r.valueFormatter(X.value, bt, r, K) : V.formattedValue, Lt = J({}, V, {
    vt = r.renderEditCell(Lt), Ce.push(se["cell--editing"]), Ce.push(we == null ? void 0 : we["cell--editing"]);
    focusElementRef: Le
    onDragEnter: Ft("cellDragEnter", D),
    "data-field": Y,
    onDoubleClick: Ft("cellDoubleClick", A),
    onMouseOver: Ft("cellMouseOver", B),
    onKeyDown: Ft("cellKeyDown", H),
    onKeyUp: Ft("cellKeyUp", F)
  }, Oe, U, {
process.env.NODE_ENV !== "production" && (i4.propTypes = {
const eye = Id(i4), tye = ["field", "type", "align", "width", "height", "empty", "style", "className"], gB = "1.3em", nye = "1.2em", vB = [40, 80], rye = {
}, oye = (e) => {
  return mt(o, Bn, n);
}, iye = Hhe(12345);
function s4(e) {
  } = e, h = qt(e, tye), v = {
    classes: $t().classes,
  }, w = oye(v), C = x.useMemo(() => {
        width: gB,
        height: gB
    const [E, O] = n ? rye[n] ?? vB : vB;
      width: `${Math.round(iye(E, O))}%`,
      height: nye
  }, h, {
    children: !a && /* @__PURE__ */ $.jsx(rU, J({}, C))
process.env.NODE_ENV !== "production" && (s4.propTypes = {
const sye = Id(s4);
function aye(e) {
  return e.vars ? e.vars.palette.TableCell.border : e.palette.mode === "light" ? tp(rn(e.palette.divider, 1), 0.88) : ep(rn(e.palette.divider, 1), 0.68);
const lye = 10, lT = -5, Cv = 1, yB = {
}, uye = "/* emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason */", cye = (e) => e.dimensions.hasScrollX && (!e.dimensions.hasScrollY || e.dimensions.scrollbarSize === 0), dye = Ue("div", {
  var H, F;
  const t = Ba(), n = Ze(t, cye), r = aye(e), o = e.shape.borderRadius, s = e.vars ? e.vars.palette.background.default : ((H = e.mixins.MuiDataGrid) == null ? void 0 : H.containerBackground) ?? e.palette.background.default, a = ((F = e.mixins.MuiDataGrid) == null ? void 0 : F.pinnedBackground) ?? s, c = e.vars ? `rgba(${e.vars.palette.background.defaultChannel} / ${e.vars.palette.action.disabledOpacity})` : rn(e.palette.background.default, e.palette.action.disabledOpacity), f = (e.vars || e).palette.action.hoverOpacity, h = (e.vars || e).palette.action.hover, g = (e.vars || e).palette.action.selectedOpacity, v = e.vars ? `calc(${f} + ${g})` : f + g, w = e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${g})` : rn(e.palette.primary.main, g), C = e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${v})` : rn(e.palette.primary.main, v), T = e.vars ? hye : fye, E = (D) => ({
      backgroundColor: D,
        backgroundColor: T(D, w, g),
          backgroundColor: T(D, w, v)
  }), O = T(a, h, f), P = E(O), I = T(a, w, g), M = E(I), A = T(a, C, v), k = E(A), j = {
    [`.${se.main} > *:first-child${uye}`]: {
      outline: `solid ${e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / 0.5)` : rn(e.palette.primary.main, 0.5)} ${Cv}px`,
      outlineOffset: Cv * -1
      outline: `solid ${e.palette.primary.main} ${Cv}px`,
      outlineOffset: Cv * -1
      maxWidth: lye,
      left: lT
      right: lT
      left: lT - 0.5
      right: lT - 0.5
        [`& .${se.iconSeparator} rect`]: yB
          [`& .${se.iconSeparator} rect`]: yB
      "&.Mui-selected": j
      "&.Mui-selected": j
        outline: `${Cv}px solid ${(e.vars || e).palette.primary.main}`,
        outlineOffset: Cv * -1
      "&:hover": P,
      "&.Mui-selected:hover": k
function fye(e, t, n, r = 1) {
  const o = (f, h) => Math.round((f ** (1 / r) * (1 - n) + h ** (1 / r) * n) ** r), s = Sc(e), a = Sc(t), c = [o(s.values[0], a.values[0]), o(s.values[1], a.values[1]), o(s.values[2], a.values[2])];
  return gC({
const pye = (e) => `rgb(from ${e} r g b / 1)`;
function hye(e, t, n) {
  return `color-mix(in srgb,${e}, ${pye(t)} calc(${n} * 100%))`;
const mye = () => () => {
}, gye = () => !1, vye = () => !0, yye = () => FD.useSyncExternalStore(mye, gye, vye);
function bye() {
  const e = kn(), t = Ze(e, xl), n = $t(), r = Ze(e, oC), o = e.current.unstable_applyPipeProcessors("preferencePanel", null, r.openedPanelValue ?? hm.filters);
function wye() {
  const e = $t();
    children: [/* @__PURE__ */ $.jsx(bye, {}), e.slots.toolbar && /* @__PURE__ */ $.jsx(e.slots.toolbar, J({}, (t = e.slotProps) == null ? void 0 : t.toolbar))]
const Sye = ["className", "children"], Cye = (e, t) => {
  return mt(s, Bn, r);
}, a4 = Qn(function(t, n) {
  const r = $t(), {
  } = t, a = qt(t, Sye), c = Ba(), f = Ze(c, Mv), h = c.current.rootElementRef, g = x.useCallback((E) => {
  }, [c]), v = Ir(h, n, g), w = r, C = Cye(w, f);
  return yye() ? null : /* @__PURE__ */ $.jsxs(dye, J({
    ref: v,
    children: [/* @__PURE__ */ $.jsx(wye, {}), /* @__PURE__ */ $.jsx(Bve, {
    }), /* @__PURE__ */ $.jsx(Hve, {})]
process.env.NODE_ENV !== "production" && (a4.propTypes = {
const xye = Id(a4), Eye = ["className"], Tye = (e) => {
  }, Bn, t);
}, _ye = jr("div", {
}), l4 = Qn(function(t, n) {
  } = t, o = qt(t, Eye), s = $t(), a = Tye(s);
  return /* @__PURE__ */ $.jsx(_ye, J({
process.env.NODE_ENV !== "production" && (l4.propTypes = {
const Oye = ["className"], Rye = (e) => {
  }, Bn, t);
}, kye = jr("div", {
}), I1 = Qn(function(t, n) {
  } = t, o = qt(t, Oye), s = $t(), a = Rye(s);
  return /* @__PURE__ */ $.jsx(kye, J({
process.env.NODE_ENV !== "production" && (I1.propTypes = {
const Pye = (e) => {
  }, Bn, t);
}, Mye = /* @__PURE__ */ x.memo((e) => {
  } = e, a = kn(), c = $t(), f = J({}, e, {
  }), h = Pye(f), g = x.useCallback((T) => {
  }, [a, t.field]), v = t.headerName ?? t.field;
    className: h.root,
        className: h.button,
        "aria-label": a.current.getLocaleText("columnMenuAriaLabel")(v),
function u4({
  const f = kn(), h = f.current.getColumn(o), g = Fn((v) => {
    v && (v.stopPropagation(), a != null && a.contains(v.target)) || f.current.hideColumnMenu();
  return !a || !h ? null : /* @__PURE__ */ $.jsx(S1, {
    placement: `bottom-${h.align === "right" ? "start" : "end"}`,
      colDef: h,
process.env.NODE_ENV !== "production" && (u4.propTypes = {
  target: Tl
function Iye(e) {
function v_(e, t) {
function Ad(e) {
function Dye(e, t) {
  return e.querySelector(`[role="columnheader"][data-field="${Ad(t)}"]`);
function c4(e) {
  return `.${se.row}[data-id="${Ad(String(e))}"]`;
function Aye(e, t) {
  return e.querySelector(c4(t));
function Nye(e, {
  const r = c4(t), o = `.${se.cell}[data-field="${Ad(n)}"]`, s = `${r} ${o}`;
function $C(e) {
function $ye(e) {
function Lye(e, t) {
  return e.querySelector(`[data-field="${Ad(t)}"]`);
function jye(e) {
function Fye(e, t) {
  return Array.from(e.querySelectorAll(`[data-fields*="|-${Ad(t)}-|"]`) ?? []);
function zye(e, t) {
  if (!v_(e, se.root))
  return (a = t.virtualScrollerRef) != null && a.current ? (p4(t).forEach((c) => {
    let h = o;
    g && g.spannedByColSpan && (h = g.leftVisibleCellIndex);
    const v = c.querySelector(`[data-colindex="${h}"]`);
    v && s.push(v);
function bB(e, t) {
const d4 = ({
  return p4(e).forEach((s) => {
      const f = My(c);
function Bye(e, t, n) {
  const r = My(t);
  return d4({
function Hye(e, t, n) {
  const r = My(t);
  return d4({
const f4 = ({
    const c = My(a);
function Vye(e, t, n) {
  const r = My(t);
  return f4({
function Uye(e, t, n) {
  const r = My(t);
  return f4({
function Wye(e, t) {
  return e.columnHeadersContainerRef.current.querySelector(`:scope > div > [data-field="${Ad(t)}"][role="columnheader"]`);
function Gye(e, t) {
  return Array.from(n.querySelectorAll(`:scope > div > div > div > [data-field="${Ad(t)}"][role="gridcell"]`));
function p4(e) {
function My(e) {
const qye = ["className", "aria-label"], Kye = (e) => {
  }, Bn, t);
}, Yye = jr("div", {
}), Xye = Qn(function(t, n) {
  } = t, o = qt(t, qye), s = $t(), a = Kye(s);
  return /* @__PURE__ */ $.jsx(Yye, J({
function h4(e) {
  } = e, r = $t(), o = x.useRef(null), [s, a] = x.useState(""), c = x.useCallback(() => {
      const h = Iye(o.current);
      a(h ? t : "");
    children: /* @__PURE__ */ $.jsx(Xye, {
process.env.NODE_ENV !== "production" && (h4.propTypes = {
const Qye = ["resizable", "resizing", "height", "side"];
var sA = /* @__PURE__ */ function(e) {
}(sA || {});
const Jye = (e) => {
  return mt(s, Bn, r);
function m4(e) {
    side: n = sA.Right
  } = e, r = qt(e, Qye), o = $t(), s = J({}, e, {
  }), a = Jye(s), c = x.useCallback((f) => {
const Zye = /* @__PURE__ */ x.memo(m4);
process.env.NODE_ENV !== "production" && (m4.propTypes = {
const ebe = ["classes", "columnMenuOpen", "colIndex", "height", "isResizing", "sortDirection", "hasFocus", "tabIndex", "separatorSide", "isDraggable", "headerComponent", "description", "elementId", "width", "columnMenuIconButton", "columnMenu", "columnTitleIconButtons", "headerClassName", "label", "resizable", "draggableContainerProps", "columnHeaderSeparatorProps", "style"], g4 = Qn(function(t, n) {
    tabIndex: h,
    isDraggable: v,
    columnTitleIconButtons: P = null,
    resizable: A,
    draggableContainerProps: k,
    columnHeaderSeparatorProps: j,
    style: B
  } = t, H = qt(t, ebe), F = Ba(), D = $t(), q = x.useRef(null), U = Ir(q, n);
  let K = "none";
  return c != null && (K = c === "asc" ? "ascending" : "descending"), x.useLayoutEffect(() => {
    const ee = F.current.state.columnMenu;
      X == null || X.focus(), (G = F.current.columnHeadersContainerRef) != null && G.current && (F.current.columnHeadersContainerRef.current.scrollLeft = 0);
  }, [F, f]), /* @__PURE__ */ $.jsxs("div", J({
    style: J({}, B, {
    tabIndex: h,
    "aria-sort": K
  }, H, {
    ref: U,
      draggable: v,
    }, k, {
          children: w !== void 0 ? w : /* @__PURE__ */ $.jsx(h4, {
        }), P]
    })), /* @__PURE__ */ $.jsx(Zye, J({
      resizable: !D.disableColumnResize && !!A,
    }, j)), O]
}), tbe = (e) => {
    isLastUnpinned: h,
  } = e, v = o != null, w = c != null && c > 0, C = t.type === "number", T = {
      v && "columnHeader--sorted",
      f === $n.LEFT && "columnHeader--pinnedLeft",
      f === $n.RIGHT && "columnHeader--pinnedRight",
      h && "columnHeader--lastUnpinned",
  return mt(T, Bn, n);
function v4(e) {
    filterItemsCounter: h,
    tabIndex: v,
    pinnedOffset: P
  } = e, I = Ba(), M = $t(), A = _c(), k = x.useRef(null), j = mr(), B = mr(), H = x.useRef(null), [F, D] = x.useState(n), q = x.useMemo(() => !M.disableColumnReorder && !w && !t.disableReorder, [M.disableColumnReorder, w, t.disableReorder]);
  let U;
  t.renderHeader && (U = t.renderHeader(I.current.getColumnHeaderParams(t.field)));
  const K = J({}, e, {
  }), ee = tbe(K), G = x.useCallback((_e) => (ce) => {
    $C(ce) || I.current.publishEvent(_e, I.current.getColumnHeaderParams(t.field), ce);
  }, [I, t.field]), Y = x.useMemo(() => ({
    F || D(n);
  }, [F, n]);
    D(!1);
  }, []), Q = !M.disableColumnMenu && !t.disableColumnMenu && /* @__PURE__ */ $.jsx(Mye, {
    columnMenuId: j,
    columnMenuButtonId: B,
    open: F,
    iconButtonRef: H
  }), V = /* @__PURE__ */ $.jsx(u4, {
    columnMenuId: j,
    columnMenuButtonId: B,
    target: H.current,
      counter: h
      const Ne = k.current.querySelector('[tabindex="0"]') || k.current;
  }) : t.headerClassName, ge = t.headerName ?? t.field, fe = x.useMemo(() => M1(J({}, e.style), A, O, P), [O, P, e.style, A]);
  return /* @__PURE__ */ $.jsx(g4, J({
    ref: k,
    tabIndex: v,
    headerComponent: U,
    columnMenu: V,
  }, Y));
process.env.NODE_ENV !== "production" && (v4.propTypes = {
const nbe = Id(v4), rbe = ["className"], obe = (e) => {
  }, Bn, t);
}, ibe = jr("div", {
})), y4 = Qn(function(t, n) {
  } = t, o = qt(t, rbe), s = $t(), a = obe(s);
  return /* @__PURE__ */ $.jsx(ibe, J({
}), sbe = ["direction", "index", "sortingOrder", "disabled", "className"], abe = (e) => {
  }, Bn, t);
function lbe(e, t, n, r) {
function b4(e) {
  } = e, a = qt(e, sbe), c = kn(), f = $t(), h = J({}, e, {
  }), g = abe(h), v = lbe(f.slots, t, g.icon, r);
  if (!v)
    children: v
  return /* @__PURE__ */ $.jsxs(y4, {
const ube = /* @__PURE__ */ x.memo(b4);
process.env.NODE_ENV !== "production" && (b4.propTypes = {
const cbe = (e) => {
  }, Bn, t);
function w4(e) {
  return e.counter ? /* @__PURE__ */ $.jsx(S4, J({}, e)) : null;
process.env.NODE_ENV !== "production" && (w4.propTypes = {
function S4(e) {
  } = e, o = kn(), s = $t(), a = J({}, e, {
  }), c = cbe(a), f = mr(), h = tC(o, Ave, f), g = mr(), v = x.useCallback((E) => {
      openedPanelValue: P
    } = oC(o.current.state);
    O && P === hm.filters ? o.current.hideFilterPanel() : o.current.showFilterPanel(void 0, g, f), r && r(o.current.getColumnHeaderParams(n), E);
    onClick: v,
    "aria-expanded": h,
    "aria-controls": h ? g : void 0
    children: /* @__PURE__ */ $.jsxs(y4, {
process.env.NODE_ENV !== "production" && (S4.propTypes = {
const wB = Tn(/* @__PURE__ */ $.jsx("path", {
}), "ArrowUpward"), SB = Tn(/* @__PURE__ */ $.jsx("path", {
}), "ArrowDownward"), CB = Tn(/* @__PURE__ */ $.jsx("path", {
}), "KeyboardArrowRight"), xB = Tn(/* @__PURE__ */ $.jsx("path", {
}), "ExpandMore"), dbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "FilterList"), EB = Tn(/* @__PURE__ */ $.jsx("path", {
}), "FilterAlt"), fbe = Tn(/* @__PURE__ */ $.jsx("path", {
Tn(/* @__PURE__ */ $.jsx("path", {
Tn(/* @__PURE__ */ $.jsx("path", {
const pbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "ColumnIcon"), hbe = Tn(/* @__PURE__ */ $.jsx("rect", {
}), "Separator"), mbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "ViewHeadline"), gbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "TableRows"), vbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "ViewStream"), ybe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "TripleDotsVertical"), UP = Tn(/* @__PURE__ */ $.jsx("path", {
}), "Close"), TB = Tn(/* @__PURE__ */ $.jsx("path", {
}), "Add"), bbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "Remove"), wbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "Load"), _B = Tn(/* @__PURE__ */ $.jsx("path", {
}), "Drag"), Sbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "SaveAlt"), Cbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "Check"), xbe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "MoreVert"), Ebe = Tn(/* @__PURE__ */ $.jsx("path", {
}), "VisibilityOff"), Tbe = Tn(/* @__PURE__ */ $.jsx("g", {
}), "ViewColumn"), _be = Tn(/* @__PURE__ */ $.jsx("path", {
Tn(/* @__PURE__ */ $.jsx("path", {
const Obe = Tn(/* @__PURE__ */ $.jsx("path", {
function C4(e) {
const y_ = (e) => e.indexOf("Arrow") === 0 || e.indexOf("Page") === 0 || e === " " || e === "Home" || e === "End", Rbe = (e) => !!e.key, x4 = (e) => e === "Tab" || e === "Escape";
function E4(e) {
function kbe(e) {
const Pbe = ["hideMenu", "colDef", "id", "labelledby", "className", "children", "open"], Mbe = Ue(SC)(() => ({
})), T4 = Qn(function(t, n) {
  } = t, h = qt(t, Pbe), g = x.useCallback((v) => {
    v.key === "Tab" && v.preventDefault(), x4(v.key) && r(v);
  return /* @__PURE__ */ $.jsx(Mbe, J({
  }, h, {
process.env.NODE_ENV !== "production" && (T4.propTypes = {
const Ibe = ["displayOrder"], Dbe = (e) => {
  const t = Ba(), n = $t(), {
    addDividers: h = !0
  } = e, g = x.useMemo(() => J({}, r, s), [r, s]), v = x.useMemo(() => {
    const O = Array.from(/* @__PURE__ */ new Set([...w, ...C])).filter((P) => g[P] != null).sort((P, I) => {
      const M = v[P], A = v[I], k = Number.isFinite(M == null ? void 0 : M.displayOrder) ? M.displayOrder : 100, j = Number.isFinite(A == null ? void 0 : A.displayOrder) ? A.displayOrder : 100;
      return k - j;
    return O.reduce((P, I, M) => {
      let A = {
      const k = v[I];
      if (k) {
        const j = qt(k, Ibe);
        A = J({}, A, j);
      return h && M !== O.length - 1 ? [...P, [g[I], A], [n.slots.baseDivider, {}]] : [...P, [g[I], A]];
  }, [h, f, w, c, g, v, C, n.slots.baseDivider]);
function _4(e) {
  } = e, r = kn(), o = $t(), c = mo(r).filter((h) => h.disableColumnMenu !== !0).length === 1, f = x.useCallback((h) => {
    c || (r.current.setColumnVisibility(t.field, !1), n(h));
  return o.disableColumnSelector || t.hideable === !1 ? null : /* @__PURE__ */ $.jsxs(Sl, {
    children: [/* @__PURE__ */ $.jsx(om, {
    }), /* @__PURE__ */ $.jsx(im, {
process.env.NODE_ENV !== "production" && (_4.propTypes = {
function O4(e) {
  } = e, n = kn(), r = $t(), o = x.useCallback((s) => {
    t(s), n.current.showPreferences(hm.columns);
  return r.disableColumnSelector ? null : /* @__PURE__ */ $.jsxs(Sl, {
    children: [/* @__PURE__ */ $.jsx(om, {
    }), /* @__PURE__ */ $.jsx(im, {
process.env.NODE_ENV !== "production" && (O4.propTypes = {
function R4(e) {
    children: [/* @__PURE__ */ $.jsx(_4, J({}, e)), /* @__PURE__ */ $.jsx(O4, J({}, e))]
process.env.NODE_ENV !== "production" && (R4.propTypes = {
function k4(e) {
  } = e, r = kn(), o = $t(), s = x.useCallback((a) => {
  return o.disableColumnFilter || !t.filterable ? null : /* @__PURE__ */ $.jsxs(Sl, {
    children: [/* @__PURE__ */ $.jsx(om, {
    }), /* @__PURE__ */ $.jsx(im, {
process.env.NODE_ENV !== "production" && (k4.propTypes = {
function P4(e) {
  } = e, r = kn(), o = Ze(r, uu), s = $t(), a = x.useMemo(() => {
    const g = o.find((v) => v.field === t.field);
    const v = g.currentTarget.getAttribute("data-value") || null;
    r.current.sortColumn(t.field, v === a ? null : v);
  const h = (g) => {
    const v = r.current.getLocaleText(g);
    return typeof v == "function" ? v(t) : v;
    children: [c.includes("asc") && a !== "asc" ? /* @__PURE__ */ $.jsxs(Sl, {
      children: [/* @__PURE__ */ $.jsx(om, {
      }), /* @__PURE__ */ $.jsx(im, {
        children: h("columnMenuSortAsc")
    }) : null, c.includes("desc") && a !== "desc" ? /* @__PURE__ */ $.jsxs(Sl, {
      children: [/* @__PURE__ */ $.jsx(om, {
      }), /* @__PURE__ */ $.jsx(im, {
        children: h("columnMenuSortDesc")
    }) : null, c.includes(null) && a != null ? /* @__PURE__ */ $.jsxs(Sl, {
      children: [/* @__PURE__ */ $.jsx(om, {}), /* @__PURE__ */ $.jsx(im, {
process.env.NODE_ENV !== "production" && (P4.propTypes = {
const Abe = ["defaultSlots", "defaultSlotProps", "slots", "slotProps"], Nbe = {
  columnMenuSortItem: P4,
  columnMenuFilterItem: k4,
  columnMenuColumnsItem: R4
}, $be = {
}, M4 = Qn(function(t, n) {
  } = t, c = qt(t, Abe), f = Dbe(J({}, c, {
  return /* @__PURE__ */ $.jsx(T4, J({}, c, {
    children: f.map(([h, g], v) => /* @__PURE__ */ $.jsx(h, J({}, g), v))
process.env.NODE_ENV !== "production" && (M4.propTypes = {
const I4 = Qn(function(t, n) {
  return /* @__PURE__ */ $.jsx(M4, J({}, t, {
    defaultSlots: Nbe,
    defaultSlotProps: $be
process.env.NODE_ENV !== "production" && (I4.propTypes = {
const Lbe = ["className", "slotProps"], jbe = (e) => {
  }, Bn, t);
}, Fbe = Ue("div", {
}), zbe = () => !0, aA = Qn(function(t, n) {
  } = t, s = qt(t, Lbe), a = $t(), c = jbe(a);
  return /* @__PURE__ */ $.jsx(qS, J({
    isEnabled: zbe
    children: /* @__PURE__ */ $.jsx(Fbe, J({
process.env.NODE_ENV !== "production" && (aA.propTypes = {
function D4(e) {
  const t = $t();
  return /* @__PURE__ */ $.jsx(aA, J({}, e, {
process.env.NODE_ENV !== "production" && (D4.propTypes = {
const Bbe = ["children", "className", "classes"], Hbe = fn("MuiDataGrid", ["panel", "paper"]), Vbe = Ue(cp, {
})), Ube = Ue(la, {
})), A4 = Qn((e, t) => {
  } = e, o = qt(e, Bbe), s = kn(), a = $t(), c = Hbe, [f, h] = x.useState(!1), g = x.useCallback(() => {
  }, [s]), v = x.useCallback((E) => {
      h(!0);
      h(!1);
    var O, P;
    const E = (P = (O = s.current.rootElementRef) == null ? void 0 : O.current) == null ? void 0 : P.querySelector('[data-id="gridPanelAnchor"]');
  }, [s]), C ? /* @__PURE__ */ $.jsx(Vbe, J({
    children: /* @__PURE__ */ $.jsx(GS, {
      children: /* @__PURE__ */ $.jsx(Ube, {
        onKeyDown: v,
process.env.NODE_ENV !== "production" && (A4.propTypes = {
const Wbe = ["className"], Gbe = (e) => {
  }, Bn, t);
}, qbe = jr("div", {
function N4(e) {
  } = e, n = qt(e, Wbe), r = $t(), o = Gbe(r);
  return /* @__PURE__ */ $.jsx(qbe, J({
process.env.NODE_ENV !== "production" && (N4.propTypes = {
const Kbe = ["className"], Ybe = (e) => {
  }, Bn, t);
}, Xbe = jr("div", {
function $4(e) {
  } = e, n = qt(e, Kbe), r = $t(), o = Ybe(r);
  return /* @__PURE__ */ $.jsx(Xbe, J({
process.env.NODE_ENV !== "production" && ($4.propTypes = {
const Qbe = ["item", "hasMultipleFilters", "deleteFilter", "applyFilterChanges", "showMultiFilterOperators", "disableMultiFilterOperator", "applyMultiFilterOperatorChanges", "focusElementRef", "logicOperators", "columnsSort", "filterColumns", "deleteIconProps", "logicOperatorInputProps", "operatorInputProps", "columnInputProps", "valueInputProps", "readOnly", "children"], Jbe = ["InputComponentProps"], Zbe = (e) => {
  }, Bn, t);
}, ewe = Ue("div", {
})), twe = Ue("div", {
})), nwe = Ue("div", {
}), rwe = Ue("div", {
}), owe = Ue("div", {
}), iwe = Ue("div", {
}), swe = (e) => {
    case Is.And:
    case Is.Or:
}, nS = (e) => e.headerName || e.field, OB = new Intl.Collator(), uI = Qn(function(t, n) {
  var Be, tt, Le, rt, ot, wt, gt, nt, Ft;
    applyMultiFilterOperatorChanges: h,
    logicOperators: v = [Is.And, Is.Or],
    columnInputProps: P = {},
  } = t, A = qt(t, Qbe), k = kn(), j = Ze(k, Dd), B = Ze(k, oW), H = Ze(k, Ti), F = mr(), D = mr(), q = mr(), U = mr(), K = $t(), ee = Zbe(K), G = x.useRef(null), Y = x.useRef(null), X = H.logicOperator ?? Is.And, te = o && v.length > 0, re = ((Be = K.slotProps) == null ? void 0 : Be.baseFormControl) || {}, V = (((tt = K.slotProps) == null ? void 0 : tt.baseSelect) || {}).native ?? !1, ie = ((Le = K.slotProps) == null ? void 0 : Le.baseInputLabel) || {}, de = ((rt = K.slotProps) == null ? void 0 : rt.baseSelectOption) || {}, {
  } = I, he = qt(I, Jbe), {
    const Et = j[r.field].filterable === !1 ? j[r.field] : null;
        filteredColumns: B,
      columns: B,
      currentFilters: (H == null ? void 0 : H.items) || []
      filteredColumns: B.filter((At) => {
  }, [C, H == null ? void 0 : H.items, B, r.field, j]), pe = x.useMemo(() => {
        return ge.sort((ut, Et) => OB.compare(nS(ut), nS(Et)));
        return ge.sort((ut, Et) => -OB.compare(nS(ut), nS(Et)));
  }, [ge, w]), be = r.field ? k.current.getColumn(r.field) : null, we = x.useMemo(() => {
    const Et = ut.target.value, Tt = k.current.getColumn(Et);
      const Oe = Tt, Ie = pm(Oe);
        h_(pt, Ie, Oe == null ? void 0 : Oe.getOptionValue) !== void 0
      )) : h_(r.value, Ie, Oe == null ? void 0 : Oe.getOptionValue) === void 0 && (Xe = void 0);
  }, [k, a, r, be, we]), ce = x.useCallback((ut) => {
    const Et = ut.target.value === Is.And.toString() ? Is.And : Is.Or;
    h(Et);
  }, [h]), Ne = () => {
      we != null && we.InputComponent ? (ut = G == null ? void 0 : G.current) == null || ut.focus() : Y.current.focus();
  }), [we]), /* @__PURE__ */ $.jsxs(ewe, J({
    ownerState: K
  }, A, {
    children: [/* @__PURE__ */ $.jsx(twe, J({
      as: K.slots.baseFormControl
      ownerState: K,
      children: /* @__PURE__ */ $.jsx(K.slots.baseIconButton, J({
        "aria-label": k.current.getLocaleText("filterPanelDeleteIconLabel"),
        title: k.current.getLocaleText("filterPanelDeleteIconLabel"),
      }, (ot = K.slotProps) == null ? void 0 : ot.baseIconButton, {
        children: /* @__PURE__ */ $.jsx(K.slots.filterPanelDeleteIcon, {
    })), /* @__PURE__ */ $.jsx(nwe, J({
      as: K.slots.baseFormControl
      ownerState: K,
      children: /* @__PURE__ */ $.jsx(K.slots.baseSelect, J({
          "aria-label": k.current.getLocaleText("filterPanelLogicOperator")
        disabled: !!f || v.length === 1,
        native: V
      }, (wt = K.slotProps) == null ? void 0 : wt.baseSelect, {
        children: v.map((ut) => /* @__PURE__ */ x.createElement(K.slots.baseSelectOption, J({}, de, {
          native: V,
        }), k.current.getLocaleText(swe(ut))))
    })), /* @__PURE__ */ $.jsxs(rwe, J({
      as: K.slots.baseFormControl
    }, re, P, {
      className: et(ee.columnInput, re.className, P.className),
      ownerState: K,
      children: [/* @__PURE__ */ $.jsx(K.slots.baseInputLabel, J({}, ie, {
        htmlFor: F,
        id: D,
        children: k.current.getLocaleText("filterPanelColumns")
      })), /* @__PURE__ */ $.jsx(K.slots.baseSelect, J({
        labelId: D,
        id: F,
        label: k.current.getLocaleText("filterPanelColumns"),
        native: V,
      }, (gt = K.slotProps) == null ? void 0 : gt.baseSelect, {
        children: pe.map((ut) => /* @__PURE__ */ x.createElement(K.slots.baseSelectOption, J({}, de, {
          native: V,
        }), nS(ut)))
    })), /* @__PURE__ */ $.jsxs(owe, J({
      as: K.slots.baseFormControl
      ownerState: K,
      children: [/* @__PURE__ */ $.jsx(K.slots.baseInputLabel, J({}, ie, {
        id: U,
        children: k.current.getLocaleText("filterPanelOperator")
      })), /* @__PURE__ */ $.jsx(K.slots.baseSelect, J({
        labelId: U,
        label: k.current.getLocaleText("filterPanelOperator"),
        native: V,
        inputRef: Y,
      }, (nt = K.slotProps) == null ? void 0 : nt.baseSelect, {
        children: (Ft = be == null ? void 0 : be.filterOperators) == null ? void 0 : Ft.map((ut) => /* @__PURE__ */ x.createElement(K.slots.baseSelectOption, J({}, de, {
          native: V,
        }), ut.label || k.current.getLocaleText(`filterOperator${He(ut.value)}`)))
    })), /* @__PURE__ */ $.jsx(iwe, J({
      as: K.slots.baseFormControl
      ownerState: K,
        apiRef: k,
process.env.NODE_ENV !== "production" && (uI.propTypes = {
const awe = ["logicOperators", "columnsSort", "filterFormProps", "getColumnForNewFilter", "children", "disableAddFilterButton", "disableRemoveAllButton"], RB = (e) => ({
}), L4 = Qn(function(t, n) {
  var U, K;
  const r = kn(), o = $t(), s = Ze(r, Ti), a = Ze(r, oW), c = Ze(r, Whe), f = x.useRef(null), h = x.useRef(null), {
    logicOperators: g = [Is.And, Is.Or],
    columnsSort: v,
  } = t, O = qt(t, awe), P = r.current.upsertFilterItem, I = x.useCallback((ee) => {
        field: Y
      }) => Y === G);
        var Y;
        return (Y = G.filterOperators) == null ? void 0 : Y.length;
    return ee ? RB(ee) : null;
  }, [s == null ? void 0 : s.items, a, C]), A = x.useCallback(() => {
    const Y = a.find(({
    return Y ? RB(Y) : null;
  }, [s.items, a, C, M]), k = x.useMemo(() => s.items.length ? s.items : (h.current || (h.current = M()), h.current ? [h.current] : []), [s.items, M]), j = k.length > 1, {
    readOnlyFilters: B,
    validFilters: H
  } = x.useMemo(() => k.reduce((ee, G) => (c[G.field] ? ee.validFilters.push(G) : ee.readOnlyFilters.push(G), ee), {
  }), [k, c]), F = x.useCallback(() => {
    const ee = A();
    ee && r.current.upsertFilterItems([...k, ee]);
  }, [r, A, k]), D = x.useCallback((ee) => {
    const G = H.length === 1;
  }, [r, H.length]), q = x.useCallback(() => H.length === 1 && H[0].value === void 0 ? (r.current.deleteFilterItem(H[0]), r.current.hideFilterPanel()) : r.current.setFilterModel(J({}, s, {
    items: B
  }), "removeAllFilterItems"), [r, B, s, H]);
    H.length > 0 && f.current.focus();
  }, [H.length]), /* @__PURE__ */ $.jsxs(aA, J({}, O, {
    children: [/* @__PURE__ */ $.jsxs(N4, {
      children: [B.map((ee, G) => /* @__PURE__ */ $.jsx(uI, J({
        applyFilterChanges: P,
        deleteFilter: D,
        hasMultipleFilters: j,
        columnsSort: v
      }, w), ee.id == null ? G : ee.id)), H.map((ee, G) => /* @__PURE__ */ $.jsx(uI, J({
        applyFilterChanges: P,
        deleteFilter: D,
        hasMultipleFilters: j,
        showMultiFilterOperators: B.length + G > 0,
        disableMultiFilterOperator: B.length + G !== 1,
        focusElementRef: G === H.length - 1 ? f : null,
        columnsSort: v
      }, w), ee.id == null ? G + B.length : ee.id))]
    }), !o.disableMultipleColumnsFiltering && !(T && E) ? /* @__PURE__ */ $.jsxs($4, {
        onClick: F,
      }, (U = o.slotProps) == null ? void 0 : U.baseButton, {
      })), !E && H.length > 0 ? /* @__PURE__ */ $.jsx(o.slots.baseButton, J({
      }, (K = o.slotProps) == null ? void 0 : K.baseButton, {
process.env.NODE_ENV !== "production" && (L4.propTypes = {
const lwe = (e, t) => {
}, uwe = (e, t) => (e.headerName || e.field).toLowerCase().indexOf(t) > -1, cwe = (e) => {
  }, Bn, t);
}, kB = new Intl.Collator();
function j4(e) {
  var G, Y, X, te;
  const t = kn(), n = x.useRef(null), r = Ze(t, xl), o = Ml(() => bl(t)).current, s = Ze(t, bl), a = $t(), [c, f] = x.useState(""), h = cwe(a), {
    searchPredicate: v = uwe,
    searchInputProps: P
  } = e, I = x.useMemo(() => lwe(s, o), [s, o]), M = x.useMemo(() => {
        return [...r].sort((re, Q) => kB.compare(re.headerName || re.field, Q.headerName || Q.field));
        return [...r].sort((re, Q) => -kB.compare(re.headerName || re.field, Q.headerName || Q.field));
  }, [r, g]), A = (re) => {
  }, k = x.useMemo(() => {
      field: V
    }) => re.includes(V)) : M;
    return c ? Q.filter((V) => v(V, c.toLowerCase())) : Q;
  }, [M, c, v, O]), j = x.useCallback((re) => {
    const Q = bl(t), V = J({}, Q), ie = O ? O(r) : null;
    return (E === "filteredOnly" ? k : r).forEach((de) => {
      de.hideable && (ie == null || ie.includes(de.field)) && (re ? delete V[de.field] : V[de.field] = !1);
    }), t.current.setColumnVisibilityModel(V);
  }, [t, r, O, E, k]), B = x.useCallback((re) => {
  }, []), H = x.useMemo(() => k.filter((re) => re.hideable), [k]), F = x.useMemo(() => H.every((re) => s[re.field] == null || s[re.field] !== !1), [s, H]), D = x.useMemo(() => H.every((re) => s[re.field] === !1), [s, H]), q = x.useRef(null);
  let U = !1;
  const K = (re) => U === !1 && re.hideable !== !1 ? (U = !0, !0) : !1, ee = x.useCallback(() => {
    children: [/* @__PURE__ */ $.jsx(fwe, {
      className: h.header,
      children: /* @__PURE__ */ $.jsx(pwe, J({
        className: h.searchInput,
        onChange: B,
      }, (Y = a.slotProps) == null ? void 0 : Y.baseTextField, P))
    }), /* @__PURE__ */ $.jsxs(dwe, {
      className: h.root,
      children: [k.map((re) => {
        return /* @__PURE__ */ $.jsx(xM, {
          className: h.row,
            onClick: A,
            inputRef: K(re) ? q : void 0
      }), k.length === 0 && /* @__PURE__ */ $.jsx(mwe, {
    }), (!C || !T) && k.length > 0 ? /* @__PURE__ */ $.jsxs(hwe, {
      className: h.footer,
      children: [C ? /* @__PURE__ */ $.jsx("span", {}) : /* @__PURE__ */ $.jsx(xM, {
          disabled: H.length === 0,
          checked: F,
          indeterminate: !F && !D,
          onClick: () => j(!F),
process.env.NODE_ENV !== "production" && (j4.propTypes = {
const dwe = Ue("div", {
})), fwe = Ue("div", {
})), pwe = Ue(Xh, {
  [`& .${_i.root}`]: {
  [`& .${_i.input}::-webkit-search-decoration,
  & .${_i.input}::-webkit-search-cancel-button,
  & .${_i.input}::-webkit-search-results-button,
  & .${_i.input}::-webkit-search-results-decoration`]: {
})), hwe = Ue("div", {
})), mwe = Ue("div")(({
})), F4 = Qn(function(t, n) {
  } = t, s = o.button || {}, a = o.tooltip || {}, c = kn(), f = $t(), h = mr(), g = mr(), [v, w] = x.useState(!1), C = x.useRef(null), T = Ir(n, C), E = (A) => {
    var k;
    w((j) => !j), (k = s.onClick) == null || k.call(s, A);
  }, O = () => w(!1), P = (A) => {
    A.key === "Tab" && A.preventDefault(), x4(A.key) && O();
        "aria-expanded": v,
        "aria-controls": v ? g : void 0,
        id: h
    })), /* @__PURE__ */ $.jsx(S1, {
      open: v,
      children: /* @__PURE__ */ $.jsx(SC, {
        "aria-labelledby": h,
        onKeyDown: P,
        autoFocusItem: v,
        children: x.Children.map(r, (A) => /* @__PURE__ */ x.isValidElement(A) ? /* @__PURE__ */ x.cloneElement(A, {
        }) : A)
process.env.NODE_ENV !== "production" && (F4.propTypes = {
const gwe = ["hideMenu", "options"], vwe = ["hideMenu", "options"], ywe = ["csvOptions", "printOptions", "excelOptions"];
function z4(e) {
  const t = kn(), {
  } = e, o = qt(e, gwe);
  return /* @__PURE__ */ $.jsx(Sl, J({
process.env.NODE_ENV !== "production" && (z4.propTypes = {
function B4(e) {
  const t = kn(), {
  } = e, o = qt(e, vwe);
  return /* @__PURE__ */ $.jsx(Sl, J({
process.env.NODE_ENV !== "production" && (B4.propTypes = {
const bwe = Qn(function(t, n) {
  } = r, c = qt(r, ywe), h = kn().current.unstable_applyPipeProcessors("exportMenu", [], {
  }).sort((g, v) => g.componentName > v.componentName ? 1 : -1);
  return h.length === 0 ? null : /* @__PURE__ */ $.jsx(F4, J({}, c, {
    children: h.map((g, v) => /* @__PURE__ */ x.cloneElement(g.component, {
      key: v
process.env.NODE_ENV !== "production" && (bwe.propTypes = {
const wwe = ["className", "selectedRowCount"], Swe = (e) => {
  }, Bn, t);
}, Cwe = jr("div", {
})), H4 = Qn(function(t, n) {
  } = t, s = qt(t, wwe), a = kn(), c = $t(), f = Swe(c), h = a.current.getLocaleText("footerRowSelected")(o);
  return /* @__PURE__ */ $.jsx(Cwe, J({
    children: h
process.env.NODE_ENV !== "production" && (H4.propTypes = {
const V4 = Qn(function(t, n) {
  var v, w;
  const r = kn(), o = $t(), s = Ze(r, Rhe), a = Ze(r, Mme), c = Ze(r, YD), f = !o.hideFooterSelectedRowCount && a > 0 ? /* @__PURE__ */ $.jsx(H4, {
  }) : /* @__PURE__ */ $.jsx("div", {}), h = !o.hideFooterRowCount && !o.pagination ? /* @__PURE__ */ $.jsx(o.slots.footerRowCount, J({}, (v = o.slotProps) == null ? void 0 : v.footerRowCount, {
  return /* @__PURE__ */ $.jsxs(l4, J({}, t, {
    children: [f, h, g]
process.env.NODE_ENV !== "production" && (V4.propTypes = {
const DS = (e, t, n, r, o, s) => {
    case $n.LEFT:
    case $n.RIGHT:
}, b_ = (e, t, n, r, o) => {
  return e === $n.LEFT && s ? !0 : r ? e === $n.LEFT ? !0 : e === $n.RIGHT ? !s : !s || o : !1;
}, w_ = (e, t) => e === $n.RIGHT && t === 0, rS = {
function lA({
    className: et(rS.root, e && rS.header, t && rS.borderTop, n && rS.borderBottom, r && rS.pinnedRight)
const xwe = jr("div", {
}), Ewe = (e) => {
  }, Bn, t);
}, PB = (e) => parseInt(e.getAttribute("data-colindex"), 10), Twe = Qn(function(t, n) {
  const r = $t(), {
  } = r, s = _c(), a = Ewe({
  }), c = x.useRef(null), f = Ir(c, n), h = kn(), g = Ze(h, vi), v = (g == null ? void 0 : g.viewportInnerSize.height) ?? 0, w = Math.ceil(v / g.rowHeight), C = Ze(h, w1), T = Ze(h, pp), E = x.useMemo(() => T.filter((j) => j <= C).length, [C, T]), O = Ze(h, mo), P = x.useMemo(() => O.slice(0, E), [O, E]), I = Ze(h, _y), M = x.useCallback((j) => {
    if (I.left.findIndex((B) => B.field === j) !== -1)
      return $n.LEFT;
    if (I.right.findIndex((B) => B.field === j) !== -1)
      return $n.RIGHT;
  }, [I.left, I.right]), A = x.useMemo(() => {
    const j = [];
    for (let B = 0; B < w; B += 1) {
      const H = [];
      for (let F = 0; F < P.length; F += 1) {
        const D = P[F], q = M(D.field), U = q === $n.LEFT, K = q === $n.RIGHT, ee = o4(q, s), G = ee ? I[ee].length : P.length - I.left.length - I.right.length, Y = ee ? I[ee].findIndex((we) => we.field === D.field) : F - I.left.length, X = g.hasScrollY ? g.scrollbarSize : 0, te = M1({}, s, q, DS(q, D.computedWidth, F, T, g.columnsTotalWidth, X)), re = g.columnsTotalWidth < g.viewportOuterSize.width, Q = b_(q, Y, G, r.showCellVerticalBorder, re), V = w_(q, Y), ie = F === P.length - 1, de = K && Y === 0, ue = de && re, he = ie && !de && re, ge = g.viewportOuterSize.width - g.columnsTotalWidth, fe = Math.max(0, ge), pe = /* @__PURE__ */ $.jsx(o.skeletonCell, {
        }, `skeleton-filler-column-${B}`), be = ie && X !== 0;
        ue && H.push(pe), H.push(/* @__PURE__ */ $.jsx(o.skeletonCell, {
          field: D.field,
          type: D.type,
          align: D.align,
          "data-colindex": F,
          className: et(U && se["cell--pinnedLeft"], K && se["cell--pinnedRight"], Q && se["cell--withRightBorder"], V && se["cell--withLeftBorder"]),
            "--width": `${D.computedWidth}px`
        }, `skeleton-column-${B}-${D.field}`)), he && H.push(pe), be && H.push(/* @__PURE__ */ $.jsx(lA, {
        }, `skeleton-scrollbar-filler-${B}`));
      j.push(/* @__PURE__ */ $.jsx("div", {
        className: et(se.row, se.rowSkeleton, B === 0 && se["row--firstVisible"]),
        children: H
      }, `skeleton-row-${B}`));
    return j;
  }, [o, P, I, w, r.showCellVerticalBorder, g, T, M, s]);
  return Ot(h, "columnResize", (j) => {
    var Y, X, te;
      colDef: B,
      width: H
    } = j, F = (Y = c.current) == null ? void 0 : Y.querySelectorAll(`[data-field="${Ad(B.field)}"]`);
    if (!F)
    const D = P.findIndex((re) => re.field === B.field), q = M(B.field), U = q === $n.LEFT, K = q === $n.RIGHT, ee = getComputedStyle(F[0]).getPropertyValue("--width"), G = parseInt(ee, 10) - H;
    if (F && F.forEach((re) => {
      re.style.setProperty("--width", `${H}px`);
    }), U) {
        PB(Q) > D && (Q.style.left = `${parseInt(getComputedStyle(Q).left, 10) - G}px`);
    if (K) {
        PB(Q) < D && (Q.style.right = `${parseInt(getComputedStyle(Q).right, 10) + G}px`);
  }), /* @__PURE__ */ $.jsx(xwe, J({
    children: A
}), _we = ["variant", "noRowsVariant", "style"], Owe = {
    component: vy,
    component: WV,
    component: Twe,
}, U4 = Qn(function(t, n) {
  } = t, a = qt(t, _we), c = kn(), f = Ze(c, kC), h = Owe[f === 0 ? o : r];
  return /* @__PURE__ */ $.jsx(I1, J({
    style: J({}, h.style, s)
    children: /* @__PURE__ */ $.jsx(h.component, {})
process.env.NODE_ENV !== "production" && (U4.propTypes = {
const W4 = Qn(function(t, n) {
  const o = kn().current.getLocaleText("noRowsLabel");
  return /* @__PURE__ */ $.jsx(I1, J({}, t, {
process.env.NODE_ENV !== "production" && (W4.propTypes = {
const Rwe = Ue(aU)(({
  [`& .${sm.selectLabel}`]: {
  [`& .${sm.input}`]: {
})), kwe = (e, t) => ({
}), Pwe = ({
}) => r ? `${e}${t} of ${n !== -1 ? n : `more than ${r > t ? r : t}`}` : `${e}${t} of ${n !== -1 ? n : `more than ${t}`}`, G4 = Qn(function(t, n) {
  var A;
  const r = kn(), o = $t(), s = Ze(r, gs), a = Ze(r, Iv), c = Ze(r, MW), {
    loading: h,
  } = o, v = x.useMemo(() => a === -1 && f === "server" && h ? {
  } : {}, [h, f, a]), w = x.useMemo(() => Math.max(0, c - 1), [c]), C = x.useMemo(() => a === -1 || s.page <= w ? s.page : w, [w, s.page, a]), T = x.useCallback((k) => {
    const j = Number(k.target.value);
    r.current.setPageSize(j);
  }, [r]), E = x.useCallback((k, j) => {
    r.current.setPage(j);
  }, [r]), O = (k) => {
    for (let j = 0; j < o.pageSizeOptions.length; j += 1) {
      const B = o.pageSizeOptions[j];
      if (typeof B == "number") {
        if (B === k)
      } else if (B.value === k)
    const k = x.useRef(!1), j = ((A = o.paginationModel) == null ? void 0 : A.pageSize) ?? s.pageSize;
    !k.current && !o.autoPageSize && !O(j) && (console.warn([`MUI X: The page size \`${s.pageSize}\` is not present in the \`pageSizeOptions\`.`, "Add it to show the pagination select."].join(`
`)), k.current = !0);
  const P = O(s.pageSize) ? o.pageSizeOptions : [], I = r.current.getLocaleText("MuiTablePagination"), M = kwe(I.labelDisplayedRows || Pwe, g);
  return /* @__PURE__ */ $.jsx(Rwe, J({
    rowsPerPageOptions: P,
  }, v, I, {
process.env.NODE_ENV !== "production" && (G4.propTypes = {
const Mwe = ["className", "rowCount", "visibleRowCount"], Iwe = (e) => {
  }, Bn, t);
}, Dwe = jr("div", {
})), q4 = Qn(function(t, n) {
  } = t, a = qt(t, Mwe), c = kn(), f = $t(), h = Iwe(f);
  return /* @__PURE__ */ $.jsxs(Dwe, J({
    className: et(h.root, r),
process.env.NODE_ENV !== "production" && (q4.propTypes = {
function Awe(e) {
function Nwe(e, t) {
  return mt(t, Bn, e);
const $we = ["selected", "rowId", "row", "index", "style", "rowHeight", "className", "visibleColumns", "pinnedColumns", "offsetLeft", "columnsTotalWidth", "firstColumnIndex", "lastColumnIndex", "focusedColumnIndex", "isFirstVisible", "isLastVisible", "isNotVisible", "showBottomBorder", "scrollbarWidth", "gridHasFiller", "onClick", "onDoubleClick", "onMouseEnter", "onMouseLeave", "onMouseOut", "onMouseOver"], Lwe = RC(gi, (e, t) => t ? !!Awe(e) : !1), K4 = Qn(function(t, n) {
    className: h,
    pinnedColumns: v,
    isFirstVisible: P,
    showBottomBorder: A,
    scrollbarWidth: k,
    gridHasFiller: j,
    onClick: B,
    onDoubleClick: H,
    onMouseEnter: F,
    onMouseLeave: D,
    onMouseOver: U
  } = t, K = qt(t, $we), ee = Ba(), G = iA(), Y = x.useRef(null), X = $t(), te = nA(ee), re = Ze(ee, uu), Q = Ze(ee, Sm), V = Ze(ee, pp), ie = X.rowReordering, de = tC(ee, Lwe, ie), ue = Ir(Y, n), he = ee.current.getRowNode(o), ge = tC(ee, n4, {
  }), fe = X.editMode === xc.Row, pe = O !== void 0, be = pe && O >= v.left.length && O < T, we = pe && O < g.length - v.right.length && O >= E, _e = Nwe(X.classes, {
    root: ["row", r && "selected", fe && "row--editable", ge && "row--editing", P && "row--firstVisible", I && "row--lastVisible", A && "row--borderBottom", f === "auto" && "row--dynamicHeight"]
    if (Y.current && f === "auto")
      return ee.current.observeRowHeight(Y.current, o);
    $C(Ie) || ee.current.getRow(o) && (ee.current.publishEvent(Xe, ee.current.getRowParams(o), Ie), Oe && Oe(Ie));
    const Oe = v_(Xe.target, se.cell), Ie = Oe == null ? void 0 : Oe.getAttribute("data-field");
      if (Ie === ky.field || Ie === E1 || Ie === "__reorder__" || ee.current.getCellMode(o, Ie) === fr.Edit)
      if ((pt == null ? void 0 : pt.type) === C1)
    Ce("rowClick", B)(Xe);
  }, [ee, B, Ce, o]), {
    disableColumnReorder: Le
  } = X, rt = Ze(ee, () => J({}, ee.current.getRowHeightEntry(o)), zD), ot = x.useMemo(() => {
  const nt = (Xe, Oe, Ie, pt, yt = $n.NONE) => {
    const bt = (zt == null ? void 0 : zt.cellProps.width) ?? Xe.computedWidth, We = (zt == null ? void 0 : zt.cellProps.colSpan) ?? 1, St = DS(yt, Xe.computedWidth, Ie, V, C, k);
    const Lt = Xe.field === "__reorder__", Cn = !(Le || Xe.disableReorder), pn = de && !re.length && Q <= 1, Or = !(Cn || Lt && pn), lr = yt === $n.VIRTUAL, Fr = w_(yt, Oe), Rr = b_(yt, Oe, pt, X.showCellVerticalBorder, j);
      disableDragEvents: Or,
      isNotVisible: lr,
      showLeftBorder: Fr,
      showRightBorder: Rr,
  }, Ft = v.left.map((Xe, Oe) => nt(Xe, Oe, Oe, v.left.length, $n.LEFT)), ut = v.right.map((Xe, Oe) => {
    const Ie = g.length - v.right.length + Oe;
    return nt(Xe, Oe, Ie, v.right.length, $n.RIGHT);
  }), Et = g.length - v.left.length - v.right.length, Tt = [];
  be && Tt.push(nt(g[O], O - v.left.length, O, Et, $n.VIRTUAL));
    const Oe = g[Xe], Ie = Xe - v.left.length;
  we && Tt.push(nt(g[O], O - v.left.length, O, Et, $n.VIRTUAL));
    onDoubleClick: Ce("rowDoubleClick", H),
    onMouseEnter: Ce("rowMouseEnter", F),
    onMouseLeave: Ce("rowMouseLeave", D),
    onMouseOver: Ce("rowMouseOver", U)
    className: et(...wt, _e.root, h),
  }, gt, At, K, {
    }), ut, k !== 0 && /* @__PURE__ */ $.jsx(lA, {
      pinnedRight: v.right.length > 0,
      borderTop: !P
process.env.NODE_ENV !== "production" && (K4.propTypes = {
const jwe = Id(K4), Fwe = () => {
  const e = Ba(), t = $t(), n = Ze(e, mo), r = Ze(e, KD), o = Ze(e, AC), s = Ze(e, G5);
    "aria-multiselectable": XD(t)
}, zwe = () => {
  const e = Ba(), t = Ze(e, Xf), n = Ze(e, AC);
function Bwe({
  return /* @__PURE__ */ $.jsx(oA.Provider, {
    children: /* @__PURE__ */ $.jsx($D.Provider, {
      children: /* @__PURE__ */ $.jsx(tA.Provider, {
        children: /* @__PURE__ */ $.jsx(ND.Provider, {
const Hwe = (e) => {
}, Vwe = (e) => {
  const t = _c();
}, Uwe = zhe() && window.localStorage.getItem("DEBUG") != null, yS = () => {
}, Wwe = {
  debug: yS,
  info: yS,
  warn: yS,
  error: yS
}, MB = ["debug", "info", "warn", "error"];
function IB(e, t, n = console) {
  const r = MB.indexOf(t);
  return MB.reduce((s, a, c) => (c >= r ? s[a] = (...f) => {
    const [h, ...g] = f;
    n[a](`MUI X: ${e} - ${h}`, ...g);
  } : s[a] = yS, s), {});
}
const Gwe = (e, t) => {
  const n = x.useCallback((r) => Uwe ? IB(r, "debug", t.logger) : t.logLevel ? IB(r, t.logLevel.toString(), t.logger) : Wwe, [t.logLevel, t.logger]);
  On(e, {
class qwe {
class uA {
    return new uA(t);
const Y4 = Symbol("mui.api_private"), Kwe = (e) => e.isPropagationStopped !== void 0;
let DB = 0;
function Ywe(e) {
  const t = (o = e.current) == null ? void 0 : o[Y4];
    store: uA.create(n),
      id: DB
  return DB += 1, r.getPublicApi = () => e.current, r.register = (s, a) => {
      const f = a[c], h = r[c];
      if ((h == null ? void 0 : h.spying) === !0 ? h.target = f : r[c] = f, s === "public") {
        const g = e.current, v = g[c];
        (v == null ? void 0 : v.spying) === !0 ? v.target = f : g[c] = f;
    eventManager: new qwe()
function Xwe(e) {
    [Y4]: e.current
function Qwe(e, t) {
  r.current || (r.current = Ywe(n)), n.current || (n.current = Xwe(r));
    const [f, h, g = {}] = c;
    if (g.defaultMuiPrevented = !1, Kwe(g) && g.isPropagationStopped())
    const v = t.signature === $a.DataGridPro || t.signature === $a.DataGridPremium ? {
    r.current.eventManager.emit(f, h, g, v);
  }, [r, t.signature]), s = x.useCallback((c, f, h) => {
    r.current.eventManager.on(c, f, h);
  return On(r, {
const Jwe = (e, t) => {
function iC(e) {
  return iC = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
  }, iC(e);
function Zwe(e, t) {
  if (iC(e) != "object" || !e) return e;
    if (iC(r) != "object") return r;
function sC(e) {
  var t = Zwe(e, "string");
  return iC(t) == "symbol" ? t : t + "";
const eSe = (e) => {
    n.current || !g || (n.current = !0, Object.values(g.appliers).forEach((v) => {
      v();
  }, []), o = x.useCallback((g, v, w) => {
    return C.processors.get(v) !== w && (C.processors.set(v, w), C.processorsAsArray = Array.from(t.current[g].processors.values()).filter((E) => E !== null), r(C)), () => {
      t.current[g].processors.set(v, null), t.current[g].processorsAsArray = Array.from(t.current[g].processors.values()).filter((E) => E !== null);
  }, [r]), s = x.useCallback((g, v, w) => (t.current[g] || (t.current[g] = {
  }), t.current[g].appliers[v] = w, () => {
    const C = t.current[g].appliers, T = qt(C, [v].map(sC));
    const [v, w, C] = g;
    if (!t.current[v])
    const T = t.current[v].processorsAsArray;
  }, h = {
  On(e, f, "private"), On(e, h, "public");
}, ro = (e, t, n, r = !0) => {
  PC(() => {
}, cA = (e, t, n) => {
  PC(() => {
}, S_ = (e, t, n, r) => {
  PC(() => {
}, mm = "none", AB = {
}, tSe = (e) => {
  const t = x.useRef(/* @__PURE__ */ new Map()), n = x.useRef({}), r = x.useCallback((f, h, g) => {
    const v = () => {
      const T = n.current[h], E = qt(T, [f].map(sC));
      n.current[h] = E;
    n.current[h] || (n.current[h] = {});
    const w = n.current[h], C = w[f];
    return w[f] = g, !C || C === g || f === e.current.getActiveStrategy(AB[h]) && e.current.publishEvent("activeStrategyProcessorChange", h), v;
  }, [e]), o = x.useCallback((f, h) => {
    const g = e.current.getActiveStrategy(AB[f]);
    const v = n.current[f];
    if (!v || !v[g])
    const w = v[g];
    return w(h);
    const g = Array.from(t.current.entries()).find(([, v]) => v.group !== f ? !1 : v.isAvailable());
    return (g == null ? void 0 : g[0]) ?? mm;
  }, []), a = x.useCallback((f, h, g) => {
    t.current.set(h, {
  On(e, {
}, nSe = (e) => {
  }, []), r = x.useCallback((f, h) => {
    if (Fhe(f) ? g = f(e.current.state) : g = f, e.current.state === g)
    let v = !1;
      }), T.propModel !== void 0 && O !== T.propModel && (v = !0));
    if (v || (e.current.state = g, e.current.publishEvent("stateChange", g), e.current.store.update(g)), w.length === 1) {
        reason: h,
      }), v || e.current.publishEvent(E.changeEvent, O, {
        reason: h
    return !v;
  }, [e]), o = x.useCallback((f, h, g) => e.current.setState((v) => J({}, v, {
    [f]: h(v[f])
  On(e, a, "public"), On(e, c, "private");
}, rSe = (e, t) => J({}, e, {
}), oSe = (e, t) => {
}, iSe = (e, t) => {
  const n = Qwe(e, t);
  return Hwe(n), oSe(n, t), Vwe(n), Gwe(n, t), nSe(n), eSe(n), tSe(n), Jwe(n, t), n.current.register("private", {
}, hi = (e, t, n) => {
function cI(e, t) {
const X4 = (e, t) => {
  return cI(o, n);
class dI {
const sSe = ({
  const s = new dI({
    process.env.NODE_ENV !== "production" && String(c.formattedValue) === "[object Object]" && Cl(["MUI X: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.", "You can provide a `valueFormatter` with a string representation to be used."]), s.addValue(X4(c, {
function aSe(e) {
  } = e, a = n.reduce((v, w) => `${v}${sSe({
  const c = t.filter((v) => v.field !== ky.field), f = [];
    const v = s.current.getAllGroupDetails();
      const E = new dI({
        sanitizeCellValue: cI
        const P = (C[O.field] || [])[T], I = v[P];
  const h = new dI({
    sanitizeCellValue: cI
  return c.forEach((v) => {
    h.addValue(v.headerName || v.field);
  }), f.push(h), `${`${f.map((v) => v.getRowString()).join(`\r
function NB(e) {
function lSe(e) {
    NB(e);
  }) : NB(e);
function uSe(e) {
const cSe = (e, t) => {
    if (!kbe(a) || uSe(a.target))
      const h = Ms(e);
      if (h) {
        const g = e.current.getCellParams(h.id, h.field);
        c = X4(g, {
    c = e.current.unstable_applyPipeProcessors("clipboardCopy", c), c && (lSe(c), e.current.publishEvent("clipboardCopy", c));
  TW(e, () => e.current.rootElementRef.current, "keydown", s), hr(e, "clipboardCopy", t.onClipboardCopy);
}, dSe = (e) => J({}, e, {
}), fSe = (e) => {
  const t = yi(e, "useGridColumnMenu"), n = x.useCallback((a) => {
    const c = _T(e.current.state), f = {
    const a = _T(e.current.state);
      const h = Dd(e), g = bl(e), v = Rd(e);
      if (h[w] || (w = v[0]), g[w] === !1) {
        const C = v.filter((E) => E === w ? !0 : g[E] !== !1), T = C.indexOf(w);
    (c.open !== a.open || c.field !== a.field) && e.current.setState((h) => (t.debug("Hiding Column Menu"), J({}, h, {
    const c = _T(e.current.state);
  On(e, {
}, pSe = (e, t, n) => {
  const r = Ov({
    pinnedColumns: e.pinnedColumns ?? f_
function hSe(e, t) {
  var D, q;
  const n = yi(e, "useGridColumns"), r = x.useRef(t.columns);
    stateSelector: bl,
  const o = x.useCallback((U) => {
    n.debug("Updating columns state."), e.current.setState($B(U)), e.current.publishEvent("columnsChange", U.orderedFields);
  }, [n, e]), s = x.useCallback((U) => Dd(e)[U], [e]), a = x.useCallback(() => xl(e), [e]), c = x.useCallback(() => mo(e), [e]), f = x.useCallback((U, K = !0) => (K ? mo(e) : xl(e)).findIndex((G) => G.field === U), [e]), h = x.useCallback((U) => {
    const K = f(U);
    return pp(e)[K];
  }, [e, f]), g = x.useCallback((U) => {
    bl(e) !== U && (e.current.setState((Y) => J({}, Y, {
      columns: Ov({
        columnVisibilityModel: U,
  }, [e]), v = x.useCallback((U) => {
    const K = Ov({
      columnsToUpsert: U,
    o(K);
  }, [e, o]), w = x.useCallback((U, K) => {
    const ee = bl(e), G = ee[U] ?? !0;
    if (K !== G) {
      const Y = J({}, ee, {
        [U]: K
      e.current.setColumnVisibilityModel(Y);
  }, [e]), C = x.useCallback((U) => Rd(e).findIndex((ee) => ee === U), [e]), T = x.useCallback((U, K) => {
    const ee = Rd(e), G = C(U);
    if (G === K)
    n.debug(`Moving column ${U} to index ${K}`);
    const Y = [...ee], X = Y.splice(G, 1)[0];
    Y.splice(K, 0, X), o(J({}, bc(e.current.state), {
      orderedFields: Y
      column: e.current.getColumn(U),
      targetIndex: e.current.getColumnIndexRelativeToVisibleColumns(U),
  }, [e, n, o, C]), E = x.useCallback((U, K) => {
    n.debug(`Updating column ${U} width to ${K}`);
    const ee = bc(e.current.state), G = ee.lookup[U], Y = J({}, G, {
      width: K,
    o(sI(J({}, ee, {
        [U]: Y
      element: e.current.getColumnHeaderElement(U),
      colDef: Y,
      width: K
    getColumnPosition: h,
    updateColumns: v,
  }, P = {
  On(e, O, "public"), On(e, P, t.signature === $a.DataGrid ? "private" : "public");
  const I = x.useCallback((U, K) => {
    const ee = {}, G = bl(e);
    (!K.exportOnlyDirtyModels || // Always export if the model is controlled
    Object.keys(G).length > 0) && (ee.columnVisibilityModel = G), ee.orderedFields = Rd(e);
    const X = xl(e), te = {};
    return X.forEach((V) => {
      if (V.hasBeenResized) {
        HW.forEach((de) => {
          let ue = V[de];
        }), te[V.field] = ie;
    }), Object.keys(te).length > 0 && (ee.dimensions = te), J({}, U, {
  }, [e, t.columnVisibilityModel, (D = t.initialState) == null ? void 0 : D.columns]), M = x.useCallback((U, K) => {
    const ee = (X = K.stateToRestore.columns) == null ? void 0 : X.columnVisibilityModel, G = K.stateToRestore.columns;
      return U;
    const Y = Ov({
    return e.current.setState($B(Y)), G != null && e.current.publishEvent("columnsChange", Y.orderedFields), U;
  }, [e]), A = x.useCallback((U, K) => {
    if (K === hm.columns) {
    return U;
  }, [t.slots.columnsPanel, (q = t.slotProps) == null ? void 0 : q.columnsPanel]), k = x.useCallback((U) => t.disableColumnSelector ? U : [...U, "columnMenuColumnsItem"], [t.disableColumnSelector]);
  ro(e, "columnMenu", k), ro(e, "exportState", I), ro(e, "restoreState", M), ro(e, "preferencePanel", A);
  const j = x.useRef(null);
  Ot(e, "viewportInnerSizeChange", (U) => {
    if (j.current !== U.width) {
      if (j.current = U.width, !mo(e).some((ee) => ee.flex && ee.flex > 0))
      o(sI(bc(e.current.state), e.current.getRootDimensions()));
  const H = x.useCallback(() => {
    const U = Ov({
    o(U);
  cA(e, "hydrateColumns", H);
  const F = x.useRef(!0);
    if (F.current) {
      F.current = !1;
    const U = Ov({
    r.current = t.columns, o(U);
function $B(e) {
const mSe = (e, t) => {
}, gSe = (e, t) => {
  const n = yi(e, "useDensity");
    stateSelector: Mv,
    setDensity: Fn((f) => {
      Mv(e.current.state) !== f && (n.debug(`Set grid density to ${f}`), e.current.setState((g) => J({}, g, {
  On(e, o, "public");
  const s = x.useCallback((f, h) => {
    const g = Mv(e.current.state);
      !h.exportOnlyDirtyModels || // Always export if the `density` is controlled
  }, [e, t.density, (c = t.initialState) == null ? void 0 : c.density]), a = x.useCallback((f, h) => {
    var v;
    const g = (v = h.stateToRestore) != null && v.density ? h.stateToRestore.density : Mv(e.current.state);
  ro(e, "exportState", s), ro(e, "restoreState", a), x.useEffect(() => {
function vSe(e, t = "csv", n = document.title || "untitled") {
const Q4 = ({
  const n = xl(e);
  }, []) : (t.allColumns ? n : mo(e)).filter((o) => !o.disableExport);
}, J4 = ({
  var f, h;
  const t = bW(e), n = Xo(e), r = e.current.getSelectedRows(), o = t.filter((g) => n[g].type !== "footer"), s = Ey(e), a = ((f = s == null ? void 0 : s.top) == null ? void 0 : f.map((g) => g.id)) || [], c = ((h = s == null ? void 0 : s.bottom) == null ? void 0 : h.map((g) => g.id)) || [];
}, ySe = (e, t) => {
  const n = yi(e, "useGridCsvExport"), r = t.ignoreValueFormatterDuringExport, o = (typeof r == "object" ? r == null ? void 0 : r.csvExport : r) || !1, s = x.useCallback((h = {}) => {
    const g = Q4({
      options: h
    }), w = (h.getRowsToExport ?? J4)({
    return aSe({
        delimiter: h.delimiter || ",",
        shouldAppendQuotes: h.shouldAppendQuotes ?? !0,
        includeHeaders: h.includeHeaders ?? !0,
        includeColumnGroupsHeaders: h.includeColumnGroupsHeaders ?? !0,
        escapeFormulas: h.escapeFormulas ?? !0
  }, [n, e, o]), a = x.useCallback((h) => {
    const g = s(h), v = new Blob([h != null && h.utf8WithBom ? new Uint8Array([239, 187, 191]) : "", g], {
    vSe(v, "csv", h == null ? void 0 : h.fileName);
  On(e, {
  const f = x.useCallback((h, g) => {
    var v;
    return (v = g.csvOptions) != null && v.disableToolbarButton ? h : [...h, {
      component: /* @__PURE__ */ $.jsx(z4, {
  ro(e, "exportMenu", f);
}, OT = (e, t, n) => {
  const o = e.rowCount, s = (n == null ? void 0 : n.pageSize) ?? r.pageSize, a = (n == null ? void 0 : n.page) ?? r.page, c = _W(o, s, a);
  const f = s === -1 ? 0 : Wme(r.page, c);
  })), RW(r.pageSize, t), r;
}, bSe = (e, t) => {
  const n = yi(e, "useGridPaginationModel"), r = Ze(e, xy), o = x.useRef(Ti(e)), s = Math.floor(t.rowHeight * r);
    stateSelector: gs,
  const a = x.useCallback((A) => {
    const k = gs(e);
    A !== k.page && (n.debug(`Setting page to ${A}`), e.current.setPaginationModel({
      page: A,
      pageSize: k.pageSize
  }, [e, n]), c = x.useCallback((A) => {
    const k = gs(e);
    A !== k.pageSize && (n.debug(`Setting page size to ${A}`), e.current.setPaginationModel({
      pageSize: A,
      page: k.page
  }, [e, n]), f = x.useCallback((A) => {
    const k = gs(e);
    A !== k && (n.debug("Setting 'paginationModel' to", A), e.current.setState((j) => J({}, j, {
      pagination: J({}, j.pagination, {
        paginationModel: OT(j.pagination, t.signature, A)
  On(e, {
  const g = x.useCallback((A, k) => {
    var H, F;
    const j = gs(e);
      !k.exportOnlyDirtyModels || // Always export if the `paginationModel` is controlled
      ((F = (H = t.initialState) == null ? void 0 : H.pagination) == null ? void 0 : F.paginationModel) != null || // Export if `page` or `pageSize` is not equal to the default value
      j.page !== 0 && j.pageSize !== Ume(t.autoPageSize) ? J({}, A, {
        pagination: J({}, A.pagination, {
          paginationModel: j
      }) : A
  }, [e, t.paginationModel, (M = (I = t.initialState) == null ? void 0 : I.pagination) == null ? void 0 : M.paginationModel, t.autoPageSize]), v = x.useCallback((A, k) => {
    var B, H;
    const j = (B = k.stateToRestore.pagination) != null && B.paginationModel ? J({}, OW(t.autoPageSize), (H = k.stateToRestore.pagination) == null ? void 0 : H.paginationModel) : gs(e);
    return e.current.setState((F) => J({}, F, {
      pagination: J({}, F.pagination, {
        paginationModel: OT(F.pagination, t.signature, j)
    }), "stateRestorePreProcessing"), A;
  ro(e, "exportState", g), ro(e, "restoreState", v);
    var k;
    const A = gs(e);
    (k = e.current.virtualScrollerRef) != null && k.current && e.current.scrollToIndexes({
      rowIndex: A.page * A.pageSize
    const A = e.current.getRootDimensions(), k = Math.max(1, Math.floor(A.viewportInnerSize.height / s));
    e.current.setPageSize(k);
  }, [e, t.autoPageSize, s]), T = x.useCallback((A) => {
    if (A == null)
    const k = gs(e);
    if (k.page === 0)
    const j = MW(e);
    k.page > j - 1 && e.current.setPage(Math.max(0, j - 1));
    gs(e).page !== 0 && e.current.setPage(0), e.current.getScrollPosition().top !== 0 && e.current.scroll({
  }, [e]), O = x.useCallback((A) => {
    const k = J({}, A, {
      items: SW(e)
    Yf(k, o.current) || (o.current = k, E());
  Ot(e, "viewportInnerSizeChange", C), Ot(e, "paginationModelChange", w), Ot(e, "rowCountChange", T), Ot(e, "sortModelChange", qh(t.resetPageOnSortFilter, E)), Ot(e, "filterModelChange", qh(t.resetPageOnSortFilter, O));
  const P = x.useRef(!0);
    if (P.current) {
      P.current = !1;
    t.pagination && e.current.setState((A) => J({}, A, {
      pagination: J({}, A.pagination, {
        paginationModel: OT(A.pagination, t.signature, t.paginationModel)
    e.current.setState((A) => {
      const k = t.pagination === !0;
      return A.pagination.paginationMode === t.paginationMode || A.pagination.enabled === k ? A : J({}, A, {
        pagination: J({}, A.pagination, {
function wSe() {
function SSe(e) {
const CSe = (e, t) => {
  const n = e.current.rootElementRef.current !== null, r = yi(e, "useGridPrintExport"), o = x.useRef(null), s = x.useRef(null), a = x.useRef({}), c = x.useRef([]), f = x.useRef(null);
    o.current = go(e.current.rootElementRef.current);
  const h = x.useCallback((O, P, I) => new Promise((M) => {
    const A = Q4({
        allColumns: P
    }).map((B) => B.field), k = xl(e), j = {};
    k.forEach((B) => {
      j[B.field] = A.includes(B.field);
    }), I && (j[ky.field] = !0), e.current.setColumnVisibilityModel(j), M();
    }).reduce((M, A) => {
      const k = e.current.getRow(A);
      return k[sy] || M.push(k), M;
  }, [e]), v = x.useCallback((O, P) => {
    var G, Y, X;
    }, P), M = O.contentDocument;
    const A = Py(e.current.state), k = e.current.rootElementRef.current, j = k.cloneNode(!0), B = j.querySelector(`.${se.main}`);
    B.style.overflow = "visible", j.style.contain = "size";
    let H = ((G = k.querySelector(`.${se.toolbarContainer}`)) == null ? void 0 : G.offsetHeight) || 0, F = ((Y = k.querySelector(`.${se.footerContainer}`)) == null ? void 0 : Y.offsetHeight) || 0;
    const D = j.querySelector(`.${se.footerContainer}`);
    I.hideToolbar && ((X = j.querySelector(`.${se.toolbarContainer}`)) == null || X.remove(), H = 0), I.hideFooter && D && (D.remove(), F = 0);
    const q = A.currentPageTotalHeight + k1(e, t) + H + F;
    j.style.height = `${q}px`, j.style.boxSizing = "content-box", !I.hideFooter && D && (D.style.position = "absolute", D.style.width = "100%", D.style.top = `${q - F}px`);
    const U = document.createElement("div");
    U.appendChild(j), M.body.style.marginTop = "0px", M.body.innerHTML = U.innerHTML;
    const K = typeof I.pageStyle == "function" ? I.pageStyle() : I.pageStyle;
    if (typeof K == "string") {
      te.appendChild(M.createTextNode(K)), M.head.appendChild(te);
      const te = k.getRootNode(), Q = (te.constructor.name === "ShadowRoot" ? te : o.current).querySelectorAll("style, link[rel='stylesheet']");
      for (let V = 0; V < Q.length; V += 1) {
        const ie = Q[V];
    var P, I;
    o.current.body.removeChild(O), e.current.restoreState(s.current || {}), (I = (P = s.current) == null ? void 0 : P.columns) != null && I.columnVisibilityModel || e.current.setColumnVisibilityModel(a.current), e.current.setState((M) => J({}, M, {
      if (s.current = e.current.exportState(), a.current = bl(e), c.current = e.current.getSortedRows().filter((I) => !I[sy]), t.pagination) {
          pageSize: KD(e)
        e.current.setState((A) => J({}, A, {
          pagination: J({}, A.pagination, {
            paginationModel: OT(
              A.pagination,
      })), await h(O == null ? void 0 : O.fields, O == null ? void 0 : O.allColumns, O == null ? void 0 : O.includeCheckboxes), g((O == null ? void 0 : O.getRowsToExport) ?? J4), await wSe();
      const P = SSe(O == null ? void 0 : O.fileName);
      process.env.NODE_ENV === "test" ? (o.current.body.appendChild(P), v(P, O), w(P)) : (P.onload = () => {
        v(P, O), P.contentWindow.matchMedia("print").addEventListener("change", (M) => {
          M.matches === !1 && w(P);
      }, o.current.body.appendChild(P));
    }, [t, r, e, v, w, h, g])
  On(e, T, "public");
  const E = x.useCallback((O, P) => {
    return (I = P.printOptions) != null && I.disableToolbarButton ? O : [...O, {
      component: /* @__PURE__ */ $.jsx(B4, {
        options: P.printOptions
  ro(e, "exportMenu", E);
}, xSe = (e, t, n) => {
  const r = t.filterModel ?? ((s = (o = t.initialState) == null ? void 0 : o.filter) == null ? void 0 : s.filterModel) ?? nC();
      filterModel: WD(r, t.disableMultipleColumnsFiltering, n)
    }, Z5),
}, ESe = (e) => e.filteredRowsLookup;
function LB(e, t) {
function TSe() {
  return A5(Object.values);
const _Se = (e, t) => {
  var F, D, q;
  const n = yi(e, "useGridFilter");
    stateSelector: Ti,
    e.current.setState((U) => {
      const K = Ti(U, e.current.instanceId), ee = e.current.getFilterState(K), G = J({}, U, {
        filter: J({}, U.filter, ee)
      }), Y = LB(e, G);
        visibleRowsLookup: Y
  }, [e]), o = x.useCallback((U, K) => K == null || K.filterable === !1 || t.disableColumnFilter ? U : [...U, "columnMenuFilterItem"], [t.disableColumnFilter]), s = x.useCallback(() => {
  }, [e, r]), a = x.useCallback((U) => {
    const K = Ti(e), ee = [...K.items], G = ee.findIndex((Y) => Y.id === U.id);
    G === -1 ? ee.push(U) : ee[G] = U, e.current.setFilterModel(J({}, K, {
  }, [e]), c = x.useCallback((U) => {
    const K = Ti(e), ee = [...K.items];
    U.forEach((G) => {
      const Y = ee.findIndex((X) => X.id === G.id);
      Y === -1 ? ee.push(G) : ee[Y] = G;
    }), e.current.setFilterModel(J({}, K, {
  }, [e]), f = x.useCallback((U) => {
    const K = Ti(e), ee = K.items.filter((G) => G.id !== U.id);
    ee.length !== K.items.length && e.current.setFilterModel(J({}, K, {
  }, [e]), h = x.useCallback((U, K, ee) => {
    if (n.debug("Displaying filter panel"), U) {
      const G = Ti(e), Y = G.items.filter((Q) => {
      const te = Y.find((Q) => Q.field === U), re = e.current.getColumn(U);
      te ? X = Y : t.disableMultipleColumnsFiltering ? X = [oI({
        field: U,
      }, e)] : X = [...Y, oI({
        field: U,
    e.current.showPreferences(hm.filters, K, ee);
  }, [e, n]), v = x.useCallback((U) => {
    const K = Ti(e);
    K.logicOperator !== U && e.current.setFilterModel(J({}, K, {
      logicOperator: U
  }, [e]), w = x.useCallback((U) => {
    const K = Ti(e);
    Yf(K.quickFilterValues, U) || e.current.setFilterModel(J({}, K, {
      quickFilterValues: [...U]
  }, [e]), C = x.useCallback((U, K) => {
    Ti(e) !== U && (n.debug("Setting filter model"), e.current.updateControlState("filter", Qz(U, t.disableMultipleColumnsFiltering, e), K), e.current.unstable_applyFilters());
  }, [e, n, t.disableMultipleColumnsFiltering]), T = x.useCallback((U) => {
    const K = WD(U, t.disableMultipleColumnsFiltering, e), ee = t.filterMode === "client" ? Xhe(K, e, t.disableEval) : null, G = e.current.applyStrategyProcessor("filtering", {
      filterModel: K ?? nC()
      filterModel: K
    setFilterLogicOperator: v,
    showFilterPanel: h,
  On(e, E, "public");
  const O = x.useCallback((U, K) => {
    var Y, X;
    const ee = Ti(e);
    !K.exportOnlyDirtyModels || // Always export if the model is controlled
    ((X = (Y = t.initialState) == null ? void 0 : Y.filter) == null ? void 0 : X.filterModel) != null || // Export if the model is not equal to the default value
    !Yf(ee, nC()) ? J({}, U, {
    }) : U;
  }, [e, t.filterModel, (D = (F = t.initialState) == null ? void 0 : F.filter) == null ? void 0 : D.filterModel]), P = x.useCallback((U, K) => {
    const ee = (G = K.stateToRestore.filter) == null ? void 0 : G.filterModel;
    return ee == null ? U : (e.current.updateControlState("filter", Qz(ee, t.disableMultipleColumnsFiltering, e), "restoreState"), J({}, U, {
      callbacks: [...U.callbacks, e.current.unstable_applyFilters]
  }, [e, t.disableMultipleColumnsFiltering]), I = x.useCallback((U, K) => {
    if (K === hm.filters) {
    return U;
  } = t, A = Ml(TSe), k = x.useCallback((U) => {
    var V;
    if (t.filterMode !== "client" || !U.isRowMatchingFilters || !U.filterModel.items.length && !((V = U.filterModel.quickFilterValues) != null && V.length))
      return Z5;
    const K = yl(e), ee = {}, {
    } = U, Y = {}, X = {
    }, te = A.current(e.current.state.rows.dataRowIdToModelLookup);
      const he = Jhe([X.passingFilterItems], [X.passingQuickFilterValues], U.filterModel, e, Y);
    return K[re] && (ee[re] = !0), {
  }, [e, t.filterMode, M, A]);
  ro(e, "columnMenu", o), ro(e, "exportState", O), ro(e, "restoreState", P), ro(e, "preferencePanel", I), S_(e, mm, "filtering", k), S_(e, mm, "visibleRowsLookupCreation", ESe);
  const j = x.useCallback(() => {
    const U = Ti(e), K = Dd(e), ee = U.items.filter((G) => G.field && K[G.field]);
    ee.length < U.items.length && e.current.setFilterModel(J({}, U, {
  }, [e, n]), B = x.useCallback((U) => {
    U === "filtering" && e.current.unstable_applyFilters();
  }, [e]), H = x.useCallback(() => {
    e.current.setState((U) => J({}, U, {
      visibleRowsLookup: LB(e, U)
  Ot(e, "rowsSet", r), Ot(e, "columnsChange", j), Ot(e, "activeStrategyProcessorChange", B), Ot(e, "rowExpansionChange", H), Ot(e, "columnVisibilityModelChange", () => {
    const U = Ti(e);
    U.quickFilterValues && sW(U) && e.current.unstable_applyFilters();
  }), PC(() => {
  }), Lr(() => {
}, OSe = (e) => J({}, e, {
}), RSe = (e, t) => {
  const n = yi(e, "useGridFocus"), r = x.useRef(null), o = e.current.rootElementRef.current !== null, s = x.useCallback((H, F) => {
    H && e.current.getRow(H.id) && e.current.publishEvent("cellFocusOut", e.current.getCellParams(H.id, H.field), F);
  }, [e]), a = x.useCallback((H, F) => {
    const D = Ms(e);
    (D == null ? void 0 : D.id) === H && (D == null ? void 0 : D.field) === F || (e.current.setState((q) => (n.debug(`Focusing on cell with id=${H} and field=${F}`), J({}, q, {
          id: H,
          field: F
          id: H,
          field: F
    }))), e.current.forceUpdate(), e.current.getRow(H) && (D && s(D, {}), e.current.publishEvent("cellFocusIn", e.current.getCellParams(H, F))));
  }, [e, n, s]), c = x.useCallback((H, F = {}) => {
    const D = Ms(e);
    s(D, F), e.current.setState((q) => (n.debug(`Focusing on column header with colIndex=${H}`), J({}, q, {
          field: H
          field: H
  }, [e, n, s]), f = x.useCallback((H, F = {}) => {
    const D = Ms(e);
    s(D, F), e.current.setState((q) => (n.debug(`Focusing on column header filter with colIndex=${H}`), J({}, q, {
          field: H
          field: H
  }, [e, n, s]), h = x.useCallback((H, F, D = {}) => {
    const q = Ms(e);
    q && e.current.publishEvent("cellFocusOut", e.current.getCellParams(q.id, q.field), D), e.current.setState((U) => J({}, U, {
          field: H,
          depth: F
          field: H,
          depth: F
  }, [e]), g = x.useCallback(() => p_(e), [e]), v = x.useCallback((H, F, D) => {
    let q = e.current.getColumnIndex(F);
    const U = mo(e), K = Qf(e, {
    }), ee = Ey(e), G = [].concat(ee.top || [], K.rows, ee.bottom || []);
    let Y = G.findIndex((Q) => Q.id === H);
    D === "right" ? q += 1 : D === "left" ? q -= 1 : Y += 1, q >= U.length ? (Y += 1, Y < G.length && (q = 0)) : q < 0 && (Y -= 1, Y >= 0 && (q = U.length - 1)), Y = La(Y, 0, G.length - 1);
    const X = G[Y];
    te && te.spannedByColSpan && (D === "left" || D === "below" ? q = te.leftVisibleCellIndex : D === "right" && (q = te.rightVisibleCellIndex)), q = La(q, 0, U.length - 1);
    const re = U[q];
    id: H,
    field: F
    e.current.setCellFocus(H, F);
  }, [e]), C = x.useCallback((H, F) => {
    F.key === "Enter" || F.key === "Tab" || F.key === "Shift" || y_(F.key) || e.current.setCellFocus(H.id, H.field);
    field: H
  }, F) => {
    F.target === F.currentTarget && e.current.setColumnHeaderFocus(H, F);
    fields: H,
    depth: F
  }, D) => {
    if (D.target !== D.currentTarget)
    const q = p_(e);
    q !== null && q.depth === F && H.includes(q.field) || e.current.setColumnGroupHeaderFocus(H[0], F, D);
  }, [e]), O = x.useCallback((H, F) => {
    var D, q;
    (q = (D = F.relatedTarget) == null ? void 0 : D.getAttribute("class")) != null && q.includes(se.columnHeader) || (n.debug("Clearing focus"), e.current.setState((U) => J({}, U, {
  }, [n, e]), P = x.useCallback((H) => {
    r.current = H;
  }, []), I = x.useCallback((H) => {
    const F = r.current;
    const D = Ms(e);
      event: H,
      cell: F
    if (!D) {
      F && e.current.setCellFocus(F.id, F.field);
    if ((F == null ? void 0 : F.id) === D.id && (F == null ? void 0 : F.field) === D.field)
    const U = e.current.getCellElement(D.id, D.field);
    U != null && U.contains(H.target) || (F ? e.current.setCellFocus(F.id, F.field) : (e.current.setState((K) => J({}, K, {
    })), e.current.forceUpdate(), s(D, H)));
  }, [e, s]), M = x.useCallback((H) => {
    if (H.cellMode === "view")
    const F = Ms(e);
    ((F == null ? void 0 : F.id) !== H.id || (F == null ? void 0 : F.field) !== H.field) && e.current.setCellFocus(H.id, H.field);
  }, [e]), A = x.useCallback(() => {
    const H = Ms(e);
    if (H && !e.current.getRow(H.id)) {
      const F = H.id;
      let D = null;
      if (typeof F < "u") {
        const q = e.current.getRowElement(F), U = q != null && q.dataset.rowindex ? Number(q == null ? void 0 : q.dataset.rowindex) : 0, K = Qf(e, {
        }), ee = K.rows[La(U, 0, K.rows.length - 1)];
        D = (ee == null ? void 0 : ee.id) ?? null;
          cell: D === null ? null : {
            id: D,
            field: H.field
  }, [e, t.pagination, t.paginationMode]), k = Fn(() => {
    const H = Ms(e);
    if (!H)
    const F = Qf(e, {
    if (F.rows.find((U) => U.id === H.id))
    const q = mo(e);
    e.current.setState((U) => J({}, U, {
          id: F.rows[0].id,
  }), j = {
  }, B = {
    moveFocusToRelativeCell: v,
    setColumnGroupHeaderFocus: h,
  On(e, j, "public"), On(e, B, "private"), x.useEffect(() => {
    const H = go(e.current.rootElementRef.current);
    return H.addEventListener("mouseup", I), () => {
      H.removeEventListener("mouseup", I);
  }, [e, o, I]), Ot(e, "columnHeaderBlur", O), Ot(e, "cellDoubleClick", w), Ot(e, "cellMouseDown", P), Ot(e, "cellKeyDown", C), Ot(e, "cellModeChange", M), Ot(e, "columnHeaderFocus", T), Ot(e, "columnGroupHeaderFocus", E), Ot(e, "rowsSet", A), Ot(e, "paginationModelChange", k);
}, WP = ({
}, GP = ({
function kSe(e, t, n, r) {
  const o = YW(e);
  const s = bW(e);
    const h = s[a];
    if (!((f = o[h]) != null && f[n]))
      return h;
const PSe = ar(IC, Ey, (e, t) => (t.top || []).concat(e.rows, t.bottom || [])), MSe = (e, t) => {
  const n = yi(e, "useGridKeyboardNavigation"), r = _c(), o = t.unstable_listView, s = x.useCallback(() => PSe(e), [e]), a = t.signature !== "DataGrid" && t.headerFilters, c = x.useCallback((P, I, M = "left", A = "up") => {
    const k = hp(e), j = e.current.unstable_getCellColSpanInfo(I, P);
    j && j.spannedByColSpan && (M === "left" ? P = j.leftVisibleCellIndex : M === "right" && (P = j.rightVisibleCellIndex));
    const B = o ? uy(e.current.state).field : Ty(e)[P], H = kSe(e, I, B, A), F = k.findIndex((D) => D.id === H);
    n.debug(`Navigating to cell row ${F}, col ${P}`), e.current.scrollToIndexes({
      colIndex: P,
      rowIndex: F
    }), e.current.setCellFocus(H, B);
  }, [e, n, o]), f = x.useCallback((P, I) => {
    n.debug(`Navigating to header col ${P}`), e.current.scrollToIndexes({
      colIndex: P
    const M = e.current.getVisibleColumns()[P].field;
  }, [e, n]), h = x.useCallback((P, I) => {
    n.debug(`Navigating to header filter col ${P}`), e.current.scrollToIndexes({
      colIndex: P
    const M = e.current.getVisibleColumns()[P].field;
  }, [e, n]), g = x.useCallback((P, I, M) => {
    n.debug(`Navigating to header col ${P}`), e.current.scrollToIndexes({
      colIndex: P
      field: A
    } = e.current.getVisibleColumns()[P];
    e.current.setColumnGroupHeaderFocus(A, I, M);
  }, [e, n]), v = x.useCallback((P) => {
    return (I = s()[P]) == null ? void 0 : I.id;
  }, [s]), w = x.useCallback((P, I) => {
    if (!!M && M.contains(I.target) && P.field !== ky.field)
    const k = s(), j = e.current.getViewportPageSize(), B = P.field ? e.current.getColumnIndex(P.field) : 0, H = k.length > 0 ? 0 : null, F = k.length - 1, D = 0, q = mo(e).length - 1, U = AC(e);
    let K = !0;
        a ? h(B, I) : H !== null && c(B, v(H));
        const ee = GP({
          currentColIndex: B,
          firstColIndex: D,
        const ee = WP({
          currentColIndex: B,
          firstColIndex: D,
        U > 0 && g(B, U - 1, I);
        H !== null && F !== null && c(B, v(Math.min(H + j, F)));
        f(D, I);
        (I.ctrlKey || I.metaKey) && e.current.toggleColumnMenu(P.field);
        K = !1;
    K && I.preventDefault();
  }, [e, s, a, h, c, v, r, f, g]), C = x.useCallback((P, I) => {
    const M = _ge(e) === P.field, A = Oge(e) === P.field;
    if (M || A || !y_(I.key))
    const k = s(), j = e.current.getViewportPageSize(), B = P.field ? e.current.getColumnIndex(P.field) : 0, H = 0, F = k.length - 1, D = 0, q = mo(e).length - 1;
    let U = !0;
        const K = v(H);
        K != null && c(B, K);
        const K = GP({
          currentColIndex: B,
          firstColIndex: D,
        K !== null && h(K, I);
        const K = WP({
          currentColIndex: B,
          firstColIndex: D,
        K !== null ? h(K, I) : e.current.setColumnHeaderFilterFocus(P.field, I);
        f(B, I);
        F !== null && c(B, v(Math.min(H + j, F)));
        h(D, I);
        h(q, I);
        U = !1;
    U && I.preventDefault();
  }, [e, s, h, r, f, c, v]), T = x.useCallback((P, I) => {
    const M = p_(e);
      field: A,
      depth: k
      fields: j,
      depth: B,
      maxDepth: H
    } = P, F = s(), D = e.current.getViewportPageSize(), q = e.current.getColumnIndex(A), U = A ? e.current.getColumnIndex(A) : 0, K = 0, ee = F.length - 1, G = 0, Y = mo(e).length - 1;
        B === H - 1 ? f(q, I) : g(q, k + 1, I);
        B > 0 && g(q, k - 1, I);
        const te = j.length - j.indexOf(A) - 1;
        q + te + 1 <= Y && g(q + te + 1, k, I);
        const te = j.indexOf(A);
        q - te - 1 >= G && g(q - te - 1, k, I);
        ee !== null && c(U, v(Math.min(K + D, ee)));
        g(G, k, I);
        g(Y, k, I);
  }, [e, s, f, g, c, v]), E = x.useCallback((P, I) => {
    if ($C(I))
    const M = e.current.getCellParams(P.id, P.field);
    if (M.cellMode === fr.Edit || !y_(I.key) || !e.current.unstable_applyPipeProcessors("canUpdateFocus", !0, {
    const k = s();
    if (k.length === 0)
    const j = e.current.getViewportPageSize(), B = o ? () => 0 : e.current.getColumnIndex, H = P.field ? B(P.field) : 0, F = k.findIndex((Y) => Y.id === P.id), D = 0, q = k.length - 1, U = 0, ee = (o ? [uy(e.current.state)] : mo(e)).length - 1;
        F < q && c(H, v(F + 1), r ? "right" : "left", "down");
        F > D ? c(H, v(F - 1)) : a ? h(H, I) : f(H, I);
        const Y = GP({
          currentColIndex: H,
          firstColIndex: U,
        Y !== null && c(Y, v(F), r ? "left" : "right");
        const Y = WP({
          currentColIndex: H,
          firstColIndex: U,
        Y !== null && c(Y, v(F), r ? "right" : "left");
        I.shiftKey && H > U ? c(H - 1, v(F), "left") : !I.shiftKey && H < ee && c(H + 1, v(F), "right");
        if (P.field === E1)
        const X = P.colDef;
        if (X && (X.field === pme || Xve(X.field)))
        !I.shiftKey && F < q && c(H, v(Math.min(F + j, q)));
        F < q && c(H, v(Math.min(F + j, q)));
        const Y = Math.max(F - j, D);
        Y !== F && Y >= D ? c(H, v(Y)) : f(H, I);
        I.ctrlKey || I.metaKey || I.shiftKey ? c(U, v(D)) : c(U, v(F));
        I.ctrlKey || I.metaKey || I.shiftKey ? c(ee, v(q)) : c(ee, v(F));
  }, [e, s, r, c, v, a, h, f, o]), O = x.useCallback((P, {
  }) => I.key === " " ? !1 : P, []);
  ro(e, "canStartEditing", O), Ot(e, "columnHeaderKeyDown", w), Ot(e, "headerFilterKeyDown", C), Ot(e, "columnGroupHeaderKeyDown", T), Ot(e, "cellKeyDown", E);
}, ISe = (e, t) => {
  const n = yi(e, "useGridRowCount"), r = Ze(e, YD), o = Ze(e, Iv), s = Ze(e, vS), a = Ze(e, gs), c = Ml(() => gs(e).pageSize);
    stateSelector: Iv,
  const h = {
      o !== O && (n.debug("Setting 'rowCount' to", O), e.current.setState((P) => J({}, P, {
        pagination: J({}, P.pagination, {
  On(e, h, "public");
  const g = x.useCallback((O, P) => {
    var A, k;
    const I = Iv(e);
      !P.exportOnlyDirtyModels || // Always export if the `rowCount` is controlled
      ((k = (A = t.initialState) == null ? void 0 : A.pagination) == null ? void 0 : k.rowCount) != null ? J({}, O, {
  }, [e, t.rowCount, (E = (T = t.initialState) == null ? void 0 : T.pagination) == null ? void 0 : E.rowCount]), v = x.useCallback((O, P) => {
    const I = (M = P.stateToRestore.pagination) != null && M.rowCount ? P.stateToRestore.pagination.rowCount : Iv(e);
    return e.current.setState((A) => J({}, A, {
      pagination: J({}, A.pagination, {
  ro(e, "exportState", g), ro(e, "restoreState", v);
}, DSe = (e, t) => {
  var f, h;
  const n = yi(e, "useGridPaginationMeta"), r = Ze(e, vS);
    stateSelector: vS,
      r !== g && (n.debug("Setting 'paginationMeta' to", g), e.current.setState((v) => J({}, v, {
        pagination: J({}, v.pagination, {
  On(e, s, "public");
  const a = x.useCallback((g, v) => {
    const w = vS(e);
      !v.exportOnlyDirtyModels || // Always export if the `paginationMeta` is controlled
  }, [e, t.paginationMeta, (h = (f = t.initialState) == null ? void 0 : f.pagination) == null ? void 0 : h.meta]), c = x.useCallback((g, v) => {
    const w = (C = v.stateToRestore.pagination) != null && C.meta ? v.stateToRestore.pagination.meta : vS(e);
  ro(e, "exportState", a), ro(e, "restoreState", c), x.useEffect(() => {
}, ASe = (e, t) => {
  var s, a, c, f, h, g, v;
  const n = J({}, OW(t.autoPageSize), t.paginationModel ?? ((a = (s = t.initialState) == null ? void 0 : s.pagination) == null ? void 0 : a.paginationModel));
  RW(n.pageSize, t.signature);
  const r = t.rowCount ?? ((f = (c = t.initialState) == null ? void 0 : c.pagination) == null ? void 0 : f.rowCount) ?? (t.paginationMode === "client" ? (h = e.rows) == null ? void 0 : h.totalRowCount : void 0), o = t.paginationMeta ?? ((v = (g = t.initialState) == null ? void 0 : g.pagination) == null ? void 0 : v.meta) ?? {};
}, NSe = (e, t) => {
  DSe(e, t), bSe(e, t), ISe(e, t);
}, $Se = (e, t) => {
}, LSe = (e, t) => {
  const n = yi(e, "useGridPreferencesPanel"), r = x.useCallback(() => {
      const h = oC(f);
        openedPanelValue: h.openedPanelValue
  }, [e, n]), o = x.useCallback((f, h, g) => {
    n.debug("Opening Preferences Panel"), e.current.setState((v) => J({}, v, {
      preferencePanel: J({}, v.preferencePanel, {
        panelId: h,
  On(e, {
  const s = x.useCallback((f, h) => {
    const g = oC(e.current.state);
      !h.exportOnlyDirtyModels || // Always export if the panel was initialized
  }, [e, (c = t.initialState) == null ? void 0 : c.preferencePanel]), a = x.useCallback((f, h) => {
    const g = h.stateToRestore.preferencePanel;
    return g != null && e.current.setState((v) => J({}, v, {
  ro(e, "exportState", s), ro(e, "restoreState", a);
}, fI = (e) => {
}, jSe = ["id", "field"], FSe = ["id", "field"], zSe = (e, t) => {
    onCellModesModelChange: h
  } = t, g = (G) => (...Y) => {
    t.editMode === xc.Cell && G(...Y);
  }, v = x.useCallback((G, Y) => {
    const X = e.current.getCellParams(G, Y);
      throw new Error(`MUI X: The cell with id=${G} and field=${Y} is not editable.`);
  }, [e]), w = x.useCallback((G, Y, X) => {
    if (e.current.getCellMode(G, Y) !== X)
      throw new Error(`MUI X: The cell with id=${G} and field=${Y} is not in ${X} mode.`);
  }, [e]), C = x.useCallback((G, Y) => {
    if (!G.isEditable || G.cellMode === fr.Edit)
      reason: Sd.cellDoubleClick
    e.current.publishEvent("cellEditStart", X, Y);
  }, [e]), T = x.useCallback((G, Y) => {
    if (G.cellMode === fr.View || e.current.getCellMode(G.id, G.field) === fr.View)
      reason: lu.cellFocusOut
    e.current.publishEvent("cellEditStop", X, Y);
  }, [e]), E = x.useCallback((G, Y) => {
    if (G.cellMode === fr.Edit) {
      if (Y.which === 229)
      if (Y.key === "Escape" ? X = lu.escapeKeyDown : Y.key === "Enter" ? X = lu.enterKeyDown : Y.key === "Tab" && (X = Y.shiftKey ? lu.shiftTabKeyDown : lu.tabKeyDown, Y.preventDefault()), X) {
        e.current.publishEvent("cellEditStop", te, Y);
        event: Y,
      if (C4(Y) ? X = Sd.printableKeyDown : E4(Y) ? X = Sd.pasteKeyDown : Y.key === "Enter" ? X = Sd.enterKeyDown : (Y.key === "Backspace" || Y.key === "Delete") && (X = Sd.deleteKeyDown), X) {
          key: Y.key
        e.current.publishEvent("cellEditStart", re, Y);
      id: Y,
      id: Y,
    (te === Sd.printableKeyDown || te === Sd.deleteKeyDown || te === Sd.pasteKeyDown) && (re.deleteValue = !0), e.current.startCellEditMode(re);
  }, [e]), P = x.useCallback((G) => {
      id: Y,
    e.current.runPendingEditCellValueMutation(Y, X);
    te === lu.enterKeyDown ? re = "below" : te === lu.tabKeyDown ? re = "right" : te === lu.shiftTabKeyDown && (re = "left");
      id: Y,
  }, [e]), I = (G) => async (...Y) => {
      } = Y[0];
      ((X = e.current.state.editRows[te][re]) == null ? void 0 : X.error) || G(...Y);
  Ot(e, "cellDoubleClick", g(C)), Ot(e, "cellFocusOut", g(T)), Ot(e, "cellKeyDown", g(E)), Ot(e, "cellEditStart", g(O)), Ot(e, "cellEditStop", g(P)), hr(e, "cellEditStart", t.onCellEditStart), hr(e, "cellEditStop", I(t.onCellEditStop));
  const M = x.useCallback((G, Y) => {
    const X = gi(e.current.state);
    return X[G] && X[G][Y] ? fr.Edit : fr.View;
  }, [e]), A = Fn((G) => {
    const Y = G !== t.cellModesModel;
    h && Y && h(G, {
    }), !(t.cellModesModel && Y) && (r(G), o.current = G, e.current.publishEvent("cellModesModelChange", G));
  }), k = x.useCallback((G, Y, X) => {
        [Y]: J({}, X)
      const re = te[G], Q = qt(re, [Y].map(sC));
    A(te);
  }, [A]), j = x.useCallback((G, Y, X) => {
        [Y]: J({}, X)
      }) : (delete re[G][Y], Object.keys(re[G]).length === 0 && delete re[G]), J({}, te, {
  }, [e]), B = x.useCallback((G) => {
      id: Y,
    } = G, te = qt(G, jSe);
    v(Y, X), w(Y, X, fr.View), k(Y, X, J({
      mode: fr.Edit
  }, [v, w, k]), H = Fn(async (G) => {
      id: Y,
    } = G, Q = e.current.getCellValue(Y, X);
    let V = Q;
    te ? V = fI(e.current.getColumn(X)) : re && (V = re);
      value: V,
    if (j(Y, X, ue), e.current.setCellFocus(Y, X), de && (ue = await Promise.resolve(ie.preProcessEditCellProps({
      id: Y,
      row: e.current.getRow(Y),
      hasChanged: V !== Q
    })), e.current.getCellMode(Y, X) === fr.Edit)) {
      const he = gi(e.current.state);
      j(Y, X, J({}, ue, {
        value: he[Y][X].value,
  }), F = x.useCallback((G) => {
      id: Y,
    } = G, te = qt(G, FSe);
    w(Y, X, fr.Edit), k(Y, X, J({
      mode: fr.View
  }, [w, k]), D = Fn(async (G) => {
      id: Y,
    w(Y, X, fr.Edit), e.current.runPendingEditCellValueMutation(Y, X);
      j(Y, X, null), k(Y, X, null), re !== "none" && e.current.moveFocusToRelativeCell(Y, X, re);
    const V = gi(e.current.state), {
    } = V[Y][X];
      s.current[Y][X].mode = fr.Edit, k(Y, X, {
        mode: fr.Edit
    const ue = e.current.getRowWithUpdatedValuesFromCellEditing(Y, X);
        s.current[Y][X].mode = fr.Edit, k(Y, X, {
          mode: fr.Edit
        }), c ? c(ge) : process.env.NODE_ENV !== "production" && Cl(["MUI X: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.", "To handle the error pass a callback to the `onProcessRowUpdateError` prop, for example `<DataGrid onProcessRowUpdateError={(error) => ...} />`.", "For more detail, see https://mui.com/x/react-data-grid/editing/#server-side-persistence."], "error");
        const ge = e.current.getRow(Y);
          rowId: Y
      id: Y,
    v(Y, X), w(Y, X, fr.Edit);
    const V = e.current.getColumn(X), ie = e.current.getRow(Y);
    V.valueParser && !Q && (de = V.valueParser(te, ie, V, e));
    let ue = gi(e.current.state), he = J({}, ue[Y][X], {
    if (V.preProcessEditCellProps) {
      const pe = te !== ue[Y][X].value;
      }), j(Y, X, he), he = await Promise.resolve(V.preProcessEditCellProps({
        id: Y,
    return e.current.getCellMode(Y, X) === fr.View ? !1 : (ue = gi(e.current.state), he = J({}, he, {
    }), he.value = V.preProcessEditCellProps ? ue[Y][X].value : de, j(Y, X, he), ue = gi(e.current.state), !((fe = (ge = ue[Y]) == null ? void 0 : ge[X]) != null && fe.error));
  }, [e, v, w, j]), U = x.useCallback((G, Y) => {
    const X = e.current.getColumn(Y), te = gi(e.current.state), re = e.current.getRow(G);
    if (!te[G] || !te[G][Y])
    } = te[G][Y];
      [Y]: Q
  }, [e]), K = {
    startCellEditMode: B,
    stopCellEditMode: F
    getRowWithUpdatedValuesFromCellEditing: U
  On(e, K, "public"), On(e, ee, "private"), x.useEffect(() => {
    f && A(f);
  }, [f, A]), Lr(() => {
    const G = yl(e), Y = s.current;
    s.current = Q5(n), Object.entries(n).forEach(([X, te]) => {
        const V = ((ue = (de = Y[X]) == null ? void 0 : de[re]) == null ? void 0 : ue.mode) || fr.View, ie = G[X] ? e.current.getRowId(G[X]) : X;
        Q.mode === fr.Edit && V === fr.View ? H(J({
        }, Q)) : Q.mode === fr.View && V === fr.Edit && D(J({
  }, [e, n, H, D]);
}, BSe = ["id"], HSe = ["id"], VSe = (e, t) => {
    processRowUpdate: h,
    rowModesModel: v,
  } = t, C = (Q) => (...V) => {
    t.editMode === xc.Row && Q(...V);
  }, T = x.useCallback((Q, V) => {
    const ie = e.current.getCellParams(Q, V);
      throw new Error(`MUI X: The cell with id=${Q} and field=${V} is not editable.`);
  }, [e]), E = x.useCallback((Q, V) => {
    if (e.current.getRowMode(Q) !== V)
      throw new Error(`MUI X: The row with id=${Q} is not in ${V} mode.`);
    const V = gi(e.current.state);
    return Object.values(V[Q]).some((ie) => ie.error);
  }, [e]), P = x.useCallback((Q, V) => {
    if (!Q.isEditable || e.current.getRowMode(Q.id) === Gr.Edit)
      reason: $f.cellDoubleClick
    e.current.publishEvent("rowEditStart", de, V);
  }, []), M = x.useCallback((Q, V) => {
    Q.isEditable && e.current.getRowMode(Q.id) !== Gr.View && (f.current = null, c.current = setTimeout(() => {
        if (!e.current.getRow(Q.id) || e.current.getRowMode(Q.id) === Gr.View || O(Q.id))
          reason: lc.rowFocusOut
        e.current.publishEvent("rowEditStop", ue, V);
  const A = x.useCallback((Q, V) => {
    if (Q.cellMode === Gr.Edit) {
      if (V.which === 229)
      if (V.key === "Escape")
        ie = lc.escapeKeyDown;
      else if (V.key === "Enter")
        ie = lc.enterKeyDown;
      else if (V.key === "Tab") {
        const de = Ty(e).filter((ue) => e.current.getColumn(ue).type === C1 ? !0 : e.current.isCellEditable(e.current.getCellParams(Q.id, ue)));
        if (V.shiftKey ? Q.field === de[0] && (ie = lc.shiftTabKeyDown) : Q.field === de[de.length - 1] && (ie = lc.tabKeyDown), V.preventDefault(), !ie) {
          const ue = de.findIndex((ge) => ge === Q.field), he = de[V.shiftKey ? ue - 1 : ue + 1];
        if (ie !== lc.escapeKeyDown && O(Q.id))
        e.current.publishEvent("rowEditStop", de, V);
        event: V,
      if (C4(V) || E4(V) ? ie = $f.printableKeyDown : V.key === "Enter" ? ie = $f.enterKeyDown : (V.key === "Backspace" || V.key === "Delete") && (ie = $f.deleteKeyDown), ie) {
        e.current.publishEvent("rowEditStart", he, V);
  }, [e, O]), k = x.useCallback((Q) => {
      id: V,
      id: V,
    (de === $f.printableKeyDown || de === $f.deleteKeyDown) && (ue.deleteValue = !!ie), e.current.startRowEditMode(ue);
  }, [e]), j = x.useCallback((Q) => {
      id: V,
    e.current.runPendingEditCellValueMutation(V);
    ie === lc.enterKeyDown ? ue = "below" : ie === lc.tabKeyDown ? ue = "right" : ie === lc.shiftTabKeyDown && (ue = "left");
      id: V,
  Ot(e, "cellDoubleClick", C(P)), Ot(e, "cellFocusIn", C(I)), Ot(e, "cellFocusOut", C(M)), Ot(e, "cellKeyDown", C(A)), Ot(e, "rowEditStart", C(k)), Ot(e, "rowEditStop", C(j)), hr(e, "rowEditStart", t.onRowEditStart), hr(e, "rowEditStop", t.onRowEditStop);
  const B = x.useCallback((Q) => n4(e, {
  }) ? Gr.Edit : Gr.View, [e, t.editMode]), H = Fn((Q) => {
    const V = Q !== t.rowModesModel;
    w && V && w(Q, {
    }), !(t.rowModesModel && V) && (r(Q), o.current = Q, e.current.publishEvent("rowModesModelChange", Q));
  }), F = x.useCallback((Q, V) => {
    V !== null ? ie[Q] = J({}, V) : delete ie[Q], H(ie);
  }, [H]), D = x.useCallback((Q, V) => {
      return V !== null ? de[Q] = V : delete de[Q], J({}, ie, {
  }, [e]), q = x.useCallback((Q, V, ie) => {
        [V]: J({}, ie)
      }) : (delete ue[Q][V], Object.keys(ue[Q]).length === 0 && delete ue[Q]), J({}, de, {
  }, [e]), U = x.useCallback((Q) => {
      id: V
    } = Q, ie = qt(Q, BSe);
    E(V, Gr.View), F(V, J({
      mode: Gr.Edit
  }, [E, F]), K = Fn((Q) => {
      id: V,
    } = Q, he = e.current.getRow(V), ge = xl(e), fe = ge.reduce((pe, be) => {
      if (!e.current.getCellParams(V, we).isEditable)
      let Ce = e.current.getCellValue(V, we);
      return ie === we && (de || ue) && (de ? Ce = fI(ce) : ue && (Ce = ue)), pe[we] = {
    a.current[V] = he, D(V, fe), ie && e.current.setCellFocus(V, ie), ge.filter((pe) => e.current.getCellParams(V, pe.field).isEditable && pe.editable && !!pe.preProcessEditCellProps && de).forEach((pe) => {
      const be = pe.field, we = e.current.getCellValue(V, be), _e = de ? fI(pe) : ue ?? we;
        id: V,
        if (e.current.getRowMode(V) === Gr.Edit) {
          const Ce = gi(e.current.state);
          q(V, be, J({}, ce, {
            value: Ce[V][be].value,
      id: V
    } = Q, ie = qt(Q, HSe);
    E(V, Gr.Edit), F(V, J({
      mode: Gr.View
  }, [E, F]), G = Fn((Q) => {
      id: V,
    e.current.runPendingEditCellValueMutation(V);
      ue !== "none" && de && e.current.moveFocusToRelativeCell(V, de, ue), D(V, null), F(V, null), delete a.current[V];
    const ge = gi(e.current.state), fe = a.current[V];
    if (Object.values(ge[V]).some((we) => we.isProcessingProps)) {
      s.current[V].mode = Gr.Edit;
    if (O(V)) {
      s.current[V].mode = Gr.Edit, F(V, {
        mode: Gr.Edit
    const be = e.current.getRowWithUpdatedValuesFromRowEditing(V);
    if (h) {
        s.current[V] && (s.current[V].mode = Gr.Edit, F(V, {
          mode: Gr.Edit
        })), g ? g(_e) : process.env.NODE_ENV !== "production" && Cl(["MUI X: A call to `processRowUpdate` threw an error which was not handled because `onProcessRowUpdateError` is missing.", "To handle the error pass a callback to the `onProcessRowUpdateError` prop, for example `<DataGrid onProcessRowUpdateError={(error) => ...} />`.", "For more detail, see https://mui.com/x/react-data-grid/editing/#server-side-persistence."], "error");
        Promise.resolve(h(be, fe, {
          rowId: V
  }), Y = x.useCallback((Q) => {
      id: V,
    T(V, ie);
    const ge = e.current.getColumn(ie), fe = e.current.getRow(V);
    let be = gi(e.current.state), we = J({}, be[V][ie], {
    return ge.preProcessEditCellProps || q(V, ie, we), new Promise((_e) => {
        const Ce = we.value !== be[V][ie].value;
        }), q(V, ie, we);
        const Ne = be[V], Be = qt(Ne, [ie].map(sC)), tt = Promise.resolve(ge.preProcessEditCellProps({
          id: V,
        })).then((Le) => {
          if (e.current.getRowMode(V) === Gr.View) {
          be = gi(e.current.state), Le = J({}, Le, {
          }), Le.value = ge.preProcessEditCellProps ? be[V][ie].value : pe, q(V, ie, Le);
      Object.entries(be[V]).forEach(([Ce, Ne]) => {
        }), q(V, Ce, Ne), be = gi(e.current.state);
        const tt = be[V], Le = qt(tt, [Ce].map(sC)), rt = Promise.resolve(Be.preProcessEditCellProps({
          id: V,
          otherFieldsProps: Le
          if (e.current.getRowMode(V) === Gr.View) {
          }), q(V, Ce, ot);
        e.current.getRowMode(V) === Gr.Edit ? (be = gi(e.current.state), _e(!be[V][ie].error)) : _e(!1);
    const V = gi(e.current.state), ie = e.current.getRow(Q);
    if (!V[Q])
    return Object.entries(V[Q]).forEach(([ue, he]) => {
    getRowMode: B,
    startRowEditMode: U,
    setRowEditingEditCellValue: Y,
  On(e, te, "public"), On(e, re, "private"), x.useEffect(() => {
    v && H(v);
  }, [v, H]), Lr(() => {
    const Q = yl(e), V = s.current;
    s.current = Q5(n);
    const ie = /* @__PURE__ */ new Set([...Object.keys(n), ...Object.keys(V)]);
        mode: Gr.View
      }, he = ((fe = V[de]) == null ? void 0 : fe.mode) || Gr.View, ge = Q[de] ? e.current.getRowId(Q[de]) : de;
      ue.mode === Gr.Edit && he === Gr.View ? K(J({
      }, ue)) : ue.mode === Gr.View && he === Gr.Edit && G(J({
  }, [e, n, K, G]);
}, USe = (e) => J({}, e, {
}), WSe = (e, t) => {
  zSe(e, t), VSe(e, t);
  } = t, o = x.useCallback((w) => ay(w.rowNode) || !w.colDef.editable || !w.colDef.renderEditCell ? !1 : r ? r(w) : !0, [r]), s = (w, C, T, E) => {
    }, P = setTimeout(() => {
    n.current[w][C] = [P, O];
        const P = t.editMode === xc.Row ? e.current.setRowEditingEditCellValue : e.current.setCellEditingEditCellValue;
        if (e.current.getCellMode(C, T) === fr.Edit) {
          const I = await P(w);
  }, [e, t.editMode]), f = x.useCallback((w, C) => t.editMode === xc.Cell ? e.current.getRowWithUpdatedValuesFromCellEditing(w, C) : e.current.getRowWithUpdatedValuesFromRowEditing(w), [e, t.editMode]), h = x.useCallback((w, C) => {
    return ((E = gi(e.current.state)[w]) == null ? void 0 : E[C]) ?? null;
    unstable_getEditCellMeta: h
  }, v = {
  On(e, g, "public"), On(e, v, "private");
}, GSe = (e, t, n) => {
  return n.current.caches.rows = ET({
    rows: uW({
}, qSe = (e, t) => {
  const n = yi(e, "useGridRows"), r = x.useRef(Date.now()), o = x.useRef(t.rowCount), s = Aa(), a = x.useCallback((G) => {
    const Y = yl(e)[G];
    if (Y)
      return Y;
    return X && ay(X) ? {
      [sy]: G
  }, [e]), c = x.useCallback((G) => DC(e.current.state, G), [e]), f = x.useCallback(({
    throttle: Y
        rows: uW({
          previousTree: Xo(e),
          previousTreeDepths: qz(e),
          previousGroupsToFetch: khe(e)
    if (s.clear(), e.current.caches.rows = G, !Y) {
  }, [t.throttleRowsMs, t.rowCount, t.loading, e, s]), h = x.useCallback((G) => {
    const Y = ET({
    Y.rowsBeforePartialUpdates = X.rowsBeforePartialUpdates, f({
      cache: Y,
    if (t.signature === $a.DataGrid && G.length > 1)
    const Y = oB(e, G, t.getRowId), X = rB({
      updates: Y,
  }, [t.signature, t.getRowId, f, e]), v = x.useCallback((G, Y) => {
    const X = oB(e, G, t.getRowId), te = rB({
      groupKeys: Y ?? []
    G !== t.loading && (n.debug(`Setting loading to ${G}`), e.current.setState((Y) => J({}, Y, {
      rows: J({}, Y.rows, {
    const G = gS(e), Y = yl(e);
    return new Map(G.map((X) => [X, Y[X] ?? {}]));
  }, [e]), T = x.useCallback(() => kC(e), [e]), E = x.useCallback(() => gS(e), [e]), O = x.useCallback((G) => {
    const Y = e.current.getRow(G), {
    } = Qf(e);
    return X.get(Y);
  }, [e]), P = x.useCallback((G, Y) => {
      childrenExpanded: Y
  }, [e]), I = x.useCallback((G) => Xo(e)[G] ?? null, [e]), M = x.useCallback(({
    groupId: Y,
    const re = Xo(e);
      const V = re[Y];
      if (!V)
      const ie = Oy(e);
      const de = ie.findIndex((ue) => ue === Y) + 1;
      for (let ue = de; ue < ie.length && re[ie[ue]].depth > V.depth; ue += 1) {
        (!G || !ay(re[he])) && Q.push(he);
      Q = GD(re, Y, G);
      const V = Ry(e);
      Q = Q.filter((ie) => V[ie] !== !1);
  }, [e]), A = x.useCallback((G, Y) => {
    if (X.parent !== Ki)
      const re = Xo(te, e.current.instanceId)[Ki], Q = re.children, V = Q.findIndex((de) => de === G);
      if (V === -1 || V === Y)
      n.debug(`Moving row ${G} to index ${Y}`);
      return ie.splice(Y, 0, ie.splice(V, 1)[0]), J({}, te, {
            [Ki]: J({}, re, {
  }, [e, n]), k = x.useCallback((G, Y) => {
    if (t.signature === $a.DataGrid && Y.length > 1)
    if (Y.length === 0)
    if (Sm(e) > 1)
    const te = J({}, Xo(e)), re = J({}, yl(e)), Q = J({}, Gz(e)), V = te[Ki], ie = [...V.children], de = /* @__PURE__ */ new Set();
    for (let he = 0; he < Y.length; he += 1) {
      const ge = Y[he], fe = x1(ge, t.getRowId, "A row was provided without id when calling replaceRows()."), [pe] = ie.splice(G + he, 1, fe);
        parent: Ki,
    te[Ki] = J({}, V, {
  }, [e, t.signature, t.getRowId]), j = {
    setRows: h,
    unstable_replaceRows: k
  }, B = {
    setRowIndex: A,
    setRowChildrenExpansion: P,
  }, H = {
    updateServerRows: v
  }, F = x.useCallback(() => {
        rows: gS(e)
    }) : G = ET({
  }, [n, e, t.rows, t.getRowId, t.loading, t.rowCount, f]), D = Ml(() => t.unstable_dataSource), q = x.useCallback((G) => {
    if (t.unstable_dataSource && t.unstable_dataSource !== D.current) {
      D.current = t.unstable_dataSource;
    G === "rowTreeCreation" && F();
  }, [F, D, t.unstable_dataSource]), U = x.useCallback(() => {
    e.current.getActiveStrategy("rowTree") !== Phe(e) && F();
  }, [e, F]);
  Ot(e, "activeStrategyProcessorChange", q), Ot(e, "strategyAvailabilityChange", U);
  const K = x.useCallback(() => {
      const Y = e.current.unstable_applyPipeProcessors("hydrateRows", {
        tree: Xo(G, e.current.instanceId),
        treeDepths: qz(G, e.current.instanceId),
        dataRowIds: gS(G, e.current.instanceId),
        dataRowIdToModelLookup: yl(G, e.current.instanceId),
        dataRowIdToIdLookup: Gz(G, e.current.instanceId)
        rows: J({}, G.rows, Y, {
          totalTopLevelRowCount: lW({
            tree: Y.tree,
  cA(e, "hydrateRows", K), On(e, j, "public"), On(e, B, t.signature === $a.DataGrid ? "private" : "public"), On(e, H, "private");
    const Y = e.current.caches.rows.rowsBeforePartialUpdates === t.rows, X = e.current.caches.rows.loadingPropBeforePartialUpdates === t.loading, te = e.current.caches.rows.rowCountPropBeforePartialUpdates === t.rowCount;
    Y && (X || (e.current.setState((Q) => J({}, Q, {
      cache: ET({
}, KSe = (e) => {
    [Ki]: J({}, ume(), {
      parent: Ki,
    groupingName: mm,
}, YSe = ({
      parent: Ki,
  const o = n[Ki];
  return Object.values(r).length && (s = s.filter((a) => !r[a])), n[Ki] = J({}, o, {
    groupingName: mm,
}, XSe = (e) => e.updates.type === "full" ? KSe(e.updates.rows) : YSe({
}), QSe = (e) => {
  S_(e, mm, "rowTreeCreation", XSe);
class qP extends Error {
function JSe(e, t) {
      throw new qP(`No row with id #${E} found`);
  }, [e]), o = x.useCallback((E, O, P, {
    hasFocus: A,
    rowNode: k,
    tabIndex: j
    const B = P[O], H = M != null && M.valueGetter ? M.valueGetter(B, P, M, e) : B, F = {
      row: P,
      rowNode: k,
      hasFocus: A,
      tabIndex: j,
      value: H,
      formattedValue: H,
    return M && M.valueFormatter && (F.formattedValue = M.valueFormatter(H, P, M, e)), F.isEditable = M && e.current.isCellEditable(F), F;
    var j;
    const P = e.current.getRow(E), I = e.current.getRowNode(E);
    if (!P || !I)
      throw new qP(`No row with id #${E} found`);
    const M = Ms(e), A = QD(e), k = e.current.getCellMode(E, O);
    return e.current.getCellParamsForRow(E, O, P, {
      colDef: t.unstable_listView && ((j = t.unstable_listColumn) == null ? void 0 : j.field) === O ? uy(e.current.state) : e.current.getColumn(O),
      tabIndex: A && A.field === O && A.id === E ? 0 : -1,
      cellMode: k
    const P = e.current.getColumn(O), I = e.current.getRow(E);
      throw new qP(`No row with id #${E} found`);
    return !P || !P.valueGetter ? I[O] : P.valueGetter(I[P.field], I, P, e);
    const P = O.field;
      return E[P];
    const P = c(E, O);
    return !O || !O.valueFormatter ? P : O.valueFormatter(P, E, O, e);
  }, [e, c]), h = x.useCallback((E) => e.current.rootElementRef.current ? Dye(e.current.rootElementRef.current, E) : null, [e]), g = x.useCallback((E) => e.current.rootElementRef.current ? Aye(e.current.rootElementRef.current, E) : null, [e]), v = x.useCallback((E, O) => e.current.rootElementRef.current ? Nye(e.current.rootElementRef.current, {
    getCellElement: v,
    getColumnHeaderElement: h
  On(e, w, "public"), On(e, C, "private");
const Z4 = (e, t) => e == null || Array.isArray(e) ? e : t && t[0] === e ? t : [e], ZSe = (e, t) => J({}, e, {
  rowSelection: t.rowSelection ? Z4(t.rowSelectionModel) ?? [] : []
}), eCe = (e, t) => {
  var te, re, Q, V, ie, de, ue, he, ge;
  const n = yi(e, "useGridSelection"), r = x.useCallback((fe) => (...pe) => {
  }, [t.rowSelection]), o = t.signature !== $a.DataGrid && (((te = t.rowSelectionPropagation) == null ? void 0 : te.parents) || ((re = t.rowSelectionPropagation) == null ? void 0 : re.descendants)), s = x.useMemo(() => Z4(t.rowSelectionModel, ka(e.current.state)), [e, t.rowSelectionModel]), a = x.useRef(null);
    stateSelector: ka,
    isRowSelectable: h
  } = t, g = XD(t), v = Ze(e, Xo), w = Ze(e, Sm) > 1, C = x.useCallback((fe) => {
      const _e = Hv(e), ce = _e.findIndex((Ne) => Ne === be), Ce = _e.findIndex((Ne) => Ne === pe);
    if (t.signature === $a.DataGrid && !g && Array.isArray(fe) && fe.length > 1)
    ka(e.current.state) !== fe && (n.debug("Setting selection model"), e.current.setState((be) => J({}, be, {
  }, [e, n, t.rowSelection, t.signature, g]), E = x.useCallback((fe) => ka(e.current.state).includes(fe), [e]), O = x.useCallback((fe) => {
    if (t.rowSelection === !1 || h && !h(e.current.getRowParams(fe)))
    const pe = Xo(e)[fe];
  }, [e, t.rowSelection, h]), P = x.useCallback(() => Ime(e), [e]), I = x.useCallback((fe, pe = !0, be = !1) => {
        const tt = [], Le = (rt) => {
        pe && (Le(fe), o && tS(e, v, fe, ((we = t.rowSelectionPropagation) == null ? void 0 : we.descendants) ?? !1, ((_e = t.rowSelectionPropagation) == null ? void 0 : _e.parents) ?? !1, Le)), e.current.setRowSelectionModel(tt);
        const tt = ka(e.current.state), Le = new Set(tt);
        Le.delete(fe);
          Le.add(gt);
          Le.delete(gt);
        pe ? (rt(fe), o && tS(e, v, fe, ((ce = t.rowSelectionPropagation) == null ? void 0 : ce.descendants) ?? !1, ((Ce = t.rowSelectionPropagation) == null ? void 0 : Ce.parents) ?? !1, rt)) : o && sB(e, v, fe, ((Ne = t.rowSelectionPropagation) == null ? void 0 : Ne.descendants) ?? !1, ((Be = t.rowSelectionPropagation) == null ? void 0 : Be.parents) ?? !1, ot), (Le.size < 2 || g) && e.current.setRowSelectionModel(Array.from(Le));
  }, [e, n, o, v, (Q = t.rowSelectionPropagation) == null ? void 0 : Q.descendants, (V = t.rowSelectionPropagation) == null ? void 0 : V.parents, g]), M = x.useCallback((fe, pe = !0, be = !1) => {
            var tt, Le;
            tS(e, v, Be, ((tt = t.rowSelectionPropagation) == null ? void 0 : tt.descendants) ?? !1, ((Le = t.rowSelectionPropagation) == null ? void 0 : Le.parents) ?? !1, Ne);
      const Ce = Xf(e);
      _e = new Set(Object.values(Xf(e)));
        var tt, Le, rt, ot;
        pe ? (_e.add(Be), o && tS(e, v, Be, ((tt = t.rowSelectionPropagation) == null ? void 0 : tt.descendants) ?? !1, ((Le = t.rowSelectionPropagation) == null ? void 0 : Le.parents) ?? !1, Ce)) : (Ne(Be), o && sB(e, v, Be, ((rt = t.rowSelectionPropagation) == null ? void 0 : rt.descendants) ?? !1, ((ot = t.rowSelectionPropagation) == null ? void 0 : ot.parents) ?? !1, Ne));
  }, [n, o, g, e, v, (ie = t.rowSelectionPropagation) == null ? void 0 : ie.descendants, (de = t.rowSelectionPropagation) == null ? void 0 : de.parents]), A = x.useCallback((fe) => {
      tS(e, v, ce, ((we = t.rowSelectionPropagation) == null ? void 0 : we.descendants) ?? !1, ((_e = t.rowSelectionPropagation) == null ? void 0 : _e.parents) ?? !1, be, pe);
  }, [e, v, (ue = t.rowSelectionPropagation) == null ? void 0 : ue.descendants, (he = t.rowSelectionPropagation) == null ? void 0 : he.parents, w, o]), k = x.useCallback(({
    const _e = Hv(e), ce = _e.indexOf(fe), Ce = _e.indexOf(pe), [Ne, Be] = ce > Ce ? [Ce, ce] : [ce, Ce], tt = _e.slice(Ne, Be + 1);
  }, [e, n]), j = {
    getSelectedRows: P,
  }, B = {
    selectRowRange: k,
    getPropagatedRowSelectionModel: A
  On(e, j, "public"), On(e, B, t.signature === $a.DataGrid ? "private" : "public");
  const H = x.useRef(!0), F = x.useCallback((fe = !1) => {
    if (H.current)
    const pe = ka(e.current.state), be = yl(e), we = Ry(e), _e = J({}, Xf(e)), ce = (tt) => t.filterMode === "server" ? !be[tt] : !be[tt] || we[tt] === !1;
      const Le = v[tt];
      if (Le.type === "group") {
        if (Le.isAutoGenerated) {
        Le.children.every((wt) => we[wt] === !1) || (delete _e[tt], Ce = !0);
  }, [e, w, (ge = t.rowSelectionPropagation) == null ? void 0 : ge.parents, t.keepNonExistentRowsSelected, t.filterMode, v]), D = x.useCallback((fe, pe) => {
    const be = pe.metaKey || pe.ctrlKey, we = !c && !be && !Rbe(pe), _e = !g || we, ce = e.current.isRowSelected(fe);
    if (be === ky.field || be === E1)
      if ((ce == null ? void 0 : ce.type) === C1)
    Xo(e)[fe.id].type !== "pinnedRow" && (pe.shiftKey && g ? C(fe.id) : D(fe.id, pe));
  }, [f, g, e, C, D]), U = x.useCallback((fe, pe) => {
  }, [g]), K = x.useCallback((fe, pe) => {
    const pe = t.pagination && t.checkboxSelectionVisibleOnly && t.paginationMode === "client" ? IW(e) : Hv(e);
    if (e.current.getCellMode(fe.id, fe.field) !== fr.Edit && !$C(pe)) {
      if (y_(pe.key) && pe.shiftKey) {
        const be = Ms(e);
          const tt = Qf(e).rows.slice(Ce, Ne + 1).map((Le) => Le.id);
        pe.preventDefault(), D(fe.id, pe);
  }, [e, D, M, g]), Y = Fn(() => {
  Ot(e, "sortedRowsSet", r(() => F(!0))), Ot(e, "filteredRowsSet", r(() => F())), Ot(e, "rowClick", r(q)), Ot(e, "rowSelectionCheckboxChange", r(K)), Ot(e, "headerSelectionCheckboxChange", ee), Ot(e, "cellMouseDown", r(U)), Ot(e, "cellKeyDown", r(G)), x.useEffect(() => {
    Y();
  }, [e, s, t.rowSelection, Y]);
    const fe = ka(e.current.state);
    const fe = ka(e.current.state);
    r(F);
  }, [F, r]), x.useEffect(() => {
    H.current && (H.current = !1);
}, tCe = (e) => {
  }, Bn, t), [t]);
}, nCe = (e, t) => {
  }, r = tCe(n), o = x.useCallback((s) => {
    const a = J({}, ky, {
    }), c = t.checkboxSelection, f = s.lookup[hl] != null;
    return c && !f ? (s.lookup[hl] = a, s.orderedFields = [hl, ...s.orderedFields]) : !c && f ? (delete s.lookup[hl], s.orderedFields = s.orderedFields.filter((h) => h !== hl)) : c && f && (s.lookup[hl] = J({}, a, s.lookup[hl]), t.columns.some((h) => h.field === hl) || (s.orderedFields = [hl, ...s.orderedFields.filter((h) => h !== hl)])), s;
  ro(e, "hydrateColumns", o);
}, rCe = (e, t) => {
      sortModel: q5(n, t.disableMultipleColumnsSorting),
}, oCe = (e, t) => {
  var k, j;
  const n = yi(e, "useGridSorting");
    stateSelector: uu,
  const r = x.useCallback((B, H) => {
    const F = uu(e), D = F.findIndex((U) => U.field === B);
    let q = [...F];
    return D > -1 ? (H == null ? void 0 : H.sort) == null ? q.splice(D, 1) : q.splice(D, 1, H) : q = [...F, H], q;
  }, [e]), o = x.useCallback((B, H) => {
    const D = uu(e).find((q) => q.field === B.field);
    if (D) {
      const q = H === void 0 ? Yz(B.sortingOrder ?? t.sortingOrder, D.sort) : H;
      return q === void 0 ? void 0 : J({}, D, {
      field: B.field,
      sort: H === void 0 ? Yz(B.sortingOrder ?? t.sortingOrder) : H
  }, [e, t.sortingOrder]), s = x.useCallback((B, H) => H == null || H.sortable === !1 || t.disableColumnSorting ? B : (H.sortingOrder || t.sortingOrder).some((D) => !!D) ? [...B, "columnMenuSortItem"] : B, [t.sortingOrder, t.disableColumnSorting]), a = x.useCallback(() => {
    e.current.setState((B) => {
        return n.debug("Skipping sorting rows as sortingMode = server"), J({}, B, {
          sorting: J({}, B.sorting, {
            sortedRows: GD(Xo(e), Ki, !1)
      const H = uu(B, e.current.instanceId), F = Nhe(H, e), D = e.current.applyStrategyProcessor("sorting", {
        sortRowList: F
      return J({}, B, {
        sorting: J({}, B.sorting, {
          sortedRows: D
  }, [e, n, t.sortingMode]), c = x.useCallback((B) => {
    uu(e) !== B && (n.debug("Setting sort model"), e.current.setState(Kz(B, t.disableMultipleColumnsSorting)), e.current.forceUpdate(), e.current.applySorting());
  }, [e, n, t.disableMultipleColumnsSorting]), f = x.useCallback((B, H, F) => {
    const D = e.current.getColumn(B), q = o(D, H);
    let U;
    !F || t.disableMultipleColumnsSorting ? U = (q == null ? void 0 : q.sort) == null ? [] : [q] : U = r(D.field, q), e.current.setSortModel(U);
  }, [e, r, o, t.disableMultipleColumnsSorting]), h = x.useCallback(() => uu(e), [e]), g = x.useCallback(() => qD(e).map((H) => H.model), [e]), v = x.useCallback(() => Oy(e), [e]), w = x.useCallback((B) => e.current.getSortedRowIds()[B], [e]);
  On(e, {
    getSortModel: h,
    getSortedRowIds: v,
  const T = x.useCallback((B, H) => {
    var q, U;
    const F = uu(e);
      !H.exportOnlyDirtyModels || // Always export if the model is controlled
      ((U = (q = t.initialState) == null ? void 0 : q.sorting) == null ? void 0 : U.sortModel) != null || // Export if the model is not empty
      F.length > 0 ? J({}, B, {
          sortModel: F
      }) : B
  }, [e, t.sortModel, (j = (k = t.initialState) == null ? void 0 : k.sorting) == null ? void 0 : j.sortModel]), E = x.useCallback((B, H) => {
    var D;
    const F = (D = H.stateToRestore.sorting) == null ? void 0 : D.sortModel;
    return F == null ? B : (e.current.setState(Kz(F, t.disableMultipleColumnsSorting)), J({}, B, {
      callbacks: [...B.callbacks, e.current.applySorting]
  }, [e, t.disableMultipleColumnsSorting]), O = x.useCallback((B) => {
    const H = Xo(e), F = H[Ki], D = B.sortRowList ? B.sortRowList(F.children.map((q) => H[q])) : [...F.children];
    return F.footerId != null && D.push(F.footerId), D;
  ro(e, "exportState", T), ro(e, "restoreState", E), S_(e, mm, "sorting", O);
  const P = x.useCallback(({
    field: B,
    colDef: H
  }, F) => {
    if (!H.sortable || t.disableColumnSorting)
    const D = F.shiftKey || F.metaKey || F.ctrlKey;
    f(B, void 0, D);
    field: B,
    colDef: H
  }, F) => {
    !H.sortable || t.disableColumnSorting || F.key === "Enter" && !F.ctrlKey && !F.metaKey && f(B, void 0, F.shiftKey);
    const B = uu(e), H = Dd(e);
    if (B.length > 0) {
      const F = B.filter((D) => H[D.field]);
      F.length < B.length && e.current.setSortModel(F);
  }, [e]), A = x.useCallback((B) => {
    B === "sorting" && e.current.applySorting();
  ro(e, "columnMenu", s), Ot(e, "columnHeaderClick", P), Ot(e, "columnHeaderKeyDown", I), Ot(e, "rowsSet", e.current.applySorting), Ot(e, "columnsChange", M), Ot(e, "activeStrategyProcessorChange", A), PC(() => {
  }), Lr(() => {
function jB(e) {
const iCe = (e, t) => {
  const n = _c(), r = yi(e, "useGridScroll"), o = e.current.columnHeadersContainerRef, s = e.current.virtualScrollerRef, a = Ze(e, hp), c = x.useCallback((v) => {
    var P;
    const w = vi(e.current.state), C = kC(e), T = t.unstable_listView ? [uy(e.current.state)] : mo(e);
    if (!(v.rowIndex == null) && C === 0 || T.length === 0)
    r.debug(`Scrolling to cell at row ${v.rowIndex}, col: ${v.colIndex} `);
    if (v.colIndex !== void 0) {
      const I = pp(e);
      if (typeof v.rowIndex < "u") {
        const A = (P = a[v.rowIndex]) == null ? void 0 : P.id, k = e.current.unstable_getCellColSpanInfo(A, v.colIndex);
        k && !k.spannedByColSpan && (M = k.cellProps.width);
      typeof M > "u" && (M = T[v.colIndex].computedWidth), O.left = jB({
        elementOffset: I[v.colIndex]
    if (v.rowIndex !== void 0) {
      const I = Py(e.current.state), M = qme(e), A = PW(e), k = t.pagination ? v.rowIndex - M * A : v.rowIndex, j = I.positions[k + 1] ? I.positions[k + 1] - I.positions[k] : I.currentPageTotalHeight - I.positions[k];
      O.top = jB({
        elementSize: j,
        elementOffset: I.positions[k]
    return O = e.current.unstable_applyPipeProcessors("scrollToIndexes", O, v), typeof O.left !== void 0 || typeof O.top !== void 0 ? (e.current.scroll(O), !0) : !1;
  }, [r, e, s, t.pagination, a, t.unstable_listView]), f = x.useCallback((v) => {
    if (s.current && v.left !== void 0 && o.current) {
      o.current.scrollLeft = v.left, s.current.scrollLeft = w * v.left, r.debug(`Scrolling left: ${v.left}`);
    s.current && v.top !== void 0 && (s.current.scrollTop = v.top, r.debug(`Scrolling top: ${v.top}`)), r.debug("Scrolling, updating container, and viewport");
  }, [s, n, o, r]), h = x.useCallback(() => s != null && s.current ? {
  On(e, {
    getScrollPosition: h
function sCe(e, t) {
  hr(e, "columnHeaderClick", t.onColumnHeaderClick), hr(e, "columnHeaderContextMenu", t.onColumnHeaderContextMenu), hr(e, "columnHeaderDoubleClick", t.onColumnHeaderDoubleClick), hr(e, "columnHeaderOver", t.onColumnHeaderOver), hr(e, "columnHeaderOut", t.onColumnHeaderOut), hr(e, "columnHeaderEnter", t.onColumnHeaderEnter), hr(e, "columnHeaderLeave", t.onColumnHeaderLeave), hr(e, "cellClick", t.onCellClick), hr(e, "cellDoubleClick", t.onCellDoubleClick), hr(e, "cellKeyDown", t.onCellKeyDown), hr(e, "preferencePanelClose", t.onPreferencePanelClose), hr(e, "preferencePanelOpen", t.onPreferencePanelOpen), hr(e, "menuOpen", t.onMenuOpen), hr(e, "menuClose", t.onMenuClose), hr(e, "rowDoubleClick", t.onRowDoubleClick), hr(e, "rowClick", t.onRowClick), hr(e, "stateChange", t.onStateChange);
function aCe(e, t = 166) {
const pI = {
  editMode: xc.Cell,
}, Rv = {
}, lCe = {
  root: Rv,
  viewportOuterSize: Rv,
  viewportInnerSize: Rv,
  contentSize: Rv,
  minimumSize: Rv,
}, uCe = (e, t, n) => {
  const r = lCe, o = xy(n);
    dimensions: J({}, r, tG(t, n, o, _y(n)))
}, eG = en(mo, pp, (e, t) => {
  return n === 0 ? 0 : Dv(t[n - 1] + e[n - 1].computedWidth, 1);
function cCe(e, t) {
  const n = yi(e, "useResizeContainer"), r = x.useRef(!1), o = x.useRef(Rv), s = Ze(e, _y), a = Ze(e, xy), c = Ze(e, eG), f = x.useRef(!0), {
    rowHeight: h,
    groupHeaderHeight: v,
  } = tG(t, e, a, s), O = x.useRef(void 0), P = x.useCallback(() => vi(e.current.state), [e]), I = x.useCallback((U) => {
    e.current.setState((K) => J({}, K, {
      dimensions: U
    })), e.current.rootElementRef.current && FB(e.current.rootElementRef.current, vi(e.current.state));
    const U = e.current.mainElementRef.current;
    if (!U)
    const K = _l(U).getComputedStyle(U), ee = {
      width: parseFloat(K.width) || 0,
      height: parseFloat(K.height) || 0
    (!O.current || !BB(O.current, ee)) && (e.current.publishEvent("resize", ee), O.current = ee);
  }, [e]), A = x.useCallback(() => {
    const U = vi(e.current.state);
    if (!U.isReady)
    const K = Qf(e);
      const G = NC(e), Y = G.lastRowIndex - G.firstRowIndex;
      return Math.min(Y - 1, K.rows.length);
    const ee = Math.floor(U.viewportInnerSize.height / h);
    return Math.min(ee, K.rows.length);
  }, [e, t.getRowHeight, h]), k = x.useCallback(() => {
    const U = dCe(e.current.mainElementRef.current, t.scrollbarSize), K = Py(e.current.state), ee = C + K.pinnedTopRowsTotalHeight, G = K.pinnedBottomRowsTotalHeight, X = {
      height: Dv(K.currentPageTotalHeight, 1)
    let te, re, Q = !1, V = !1;
      V = !1, Q = Math.round(c) > Math.round(o.current.width), te = {
        width: Math.max(0, te.width - (V ? U : 0)),
        height: Math.max(0, te.height - (Q ? U : 0))
      (we || _e) && (V = _e, Q = pe.width + (V ? U : 0) > be.width, Q && (V = pe.height + U > be.height)), V && (re.width -= U), Q && (re.height -= U);
    const ie = Math.max(te.width, c + (V ? U : 0)), de = {
      hasScrollY: V,
      scrollbarSize: U,
      groupHeaderHeight: v,
      rowHeight: h,
    Yf(he, ue) || (I(ue), BB(ue.viewportInnerSize, he.viewportInnerSize) || e.current.publishEvent("viewportInnerSizeChange", ue.viewportInnerSize), (fe = (ge = e.current).updateRenderContext) == null || fe.call(ge));
  }, [e, I, t.scrollbarSize, t.autoHeight, h, g, v, w, c, C, T, E]), j = Fn(k), B = x.useMemo(() => t.resizeThrottleMs > 0 ? aCe(() => {
    j(), e.current.publishEvent("debouncedResize", o.current);
  }, t.resizeThrottleMs) : void 0, [e, t.resizeThrottleMs, j]);
  x.useEffect(() => B == null ? void 0 : B.clear, [B]);
  const H = {
    getRootDimensions: P
  }, F = {
    updateDimensions: k,
    getViewportPageSize: A
  Lr(k, [k]), On(e, H, "public"), On(e, F, "private");
  const D = x.useCallback((U) => {
    FB(U, vi(e.current.state));
  }, [e]), q = x.useCallback((U) => {
    if (o.current = U, U.height === 0 && !r.current && !t.autoHeight && !g_ && (n.error(["The parent DOM element of the Data Grid has an empty height.", "Please make sure that this element has an intrinsic height.", "The grid displays with a height of 0px.", "", "More details: https://mui.com/r/x-data-grid-no-dimensions."].join(`
`)), r.current = !0), U.width === 0 && !r.current && !g_ && (n.error(["The parent DOM element of the Data Grid has an empty width.", "Please make sure that this element has an intrinsic width.", "The grid displays with a width of 0px.", "", "More details: https://mui.com/r/x-data-grid-no-dimensions."].join(`
`)), r.current = !0), f.current || !B) {
      f.current = !1, k();
    B();
  }, [k, t.autoHeight, B, n]);
  hr(e, "rootMount", D), hr(e, "resize", q), hr(e, "debouncedResize", t.onResize);
function FB(e, t) {
function tG(e, t, n, r) {
  const o = dW(e.rowHeight, pI.rowHeight, dme);
    columnsTotalWidth: eG(t),
    headersTotalHeight: k1(t, e),
const zB = /* @__PURE__ */ new WeakMap();
function dCe(e, t) {
  const n = zB.get(e);
  const o = go(e).createElement("div");
  return e.removeChild(o), zB.set(e, s), s;
function BB(e, t) {
const fCe = typeof globalThis.ResizeObserver < "u" ? globalThis.ResizeObserver : class {
}, pCe = (e, t, n) => {
  const r = BD(n.current.state), o = kC(n), s = MC(n.current.state), a = Math.min(s.enabled ? s.paginationModel.pageSize : o, o);
}, hCe = (e, t) => {
  } = t, s = e.current.caches.rowsMeta.heights, a = x.useRef(-1), c = x.useRef(!1), f = x.useRef(!1), h = Ze(e, xy), g = nA(e), v = Ze(e, Ey), w = Ze(e, BD), C = (D) => {
    let q = s.get(D);
    }, s.set(D, q)), q;
  }, T = x.useCallback((D) => {
    const q = vi(e.current.state).rowHeight, U = e.current.getRowHeightEntry(D.id);
      U.content = q, U.needsFirstMeasurement = !1;
      const K = n(J({}, D, {
        densityFactor: h
      if (K === "auto") {
        if (U.needsFirstMeasurement) {
          const ee = o ? o(J({}, D, {
            densityFactor: h
          U.content = ee ?? q;
        c.current = !0, U.autoHeight = !0;
        U.content = dW(K, q, fme), U.needsFirstMeasurement = !1, U.autoHeight = !1;
      const K = e.current.getRowIndexRelativeToVisibleRows(D.id), ee = r(J({}, D, {
        isFirstVisible: K === 0,
        isLastVisible: K === g.rows.length - 1,
        indexRelativeToCurrentPage: K
      U.spacingTop = ee.top ?? 0, U.spacingBottom = ee.bottom ?? 0;
      U.spacingTop = 0, U.spacingBottom = 0;
    return e.current.unstable_applyPipeProcessors("rowHeight", U, D), U;
  }, [e, g.rows, n, o, w, r, h]), E = x.useCallback(() => {
    const D = v.top.reduce((Y, X) => {
      return Y + te.content + te.spacingTop + te.spacingBottom + te.detail;
    }, 0), q = v.bottom.reduce((Y, X) => {
      return Y + te.content + te.spacingTop + te.spacingBottom + te.detail;
    }, 0), U = [], K = g.rows.reduce((Y, X) => {
      U.push(Y);
      return Y + re;
    const ee = D !== e.current.state.rowsMeta.pinnedTopRowsTotalHeight || q !== e.current.state.rowsMeta.pinnedBottomRowsTotalHeight || K !== e.current.state.rowsMeta.currentPageTotalHeight, G = {
      currentPageTotalHeight: K,
      positions: U,
      pinnedTopRowsTotalHeight: D,
    e.current.setState((Y) => J({}, Y, {
  }, [e, v, g.rows, T]), O = (D) => {
    return ((q = s.get(D)) == null ? void 0 : q.content) ?? w;
  }, P = (D, q) => {
    const U = e.current.getRowHeightEntry(D), K = U.content !== q;
    U.needsFirstMeasurement = !1, U.content = q, f.current && (f.current = !K);
  }, I = (D) => {
    return ((q = s.get(D)) == null ? void 0 : q.autoHeight) ?? !1;
  }, M = () => a.current, A = (D) => {
    c.current && D > a.current && (a.current = D);
  }, k = () => {
  }, j = Ml(() => new fCe((D) => {
    for (let U = 0; U < D.length; U += 1) {
      const K = D[U], ee = K.borderBoxSize && K.borderBoxSize.length > 0 ? K.borderBoxSize[0].blockSize : K.contentRect.height, G = K.target.__mui_id;
      if (((q = XW(e)) == null ? void 0 : q.id) === G && ee === 0)
  })).current, B = (D, q) => (D.__mui_id = q, j.observe(D), () => j.unobserve(D));
  cA(e, "rowHeight", E), Lr(() => {
  const H = {
    unstable_setLastMeasuredRowIndex: A,
    unstable_storeRowHeightMeasurement: P,
    resetRowHeights: k
  }, F = {
    observeRowHeight: B,
  On(e, H, "public"), On(e, F, "private");
}, mCe = (e) => {
  On(e, {
}, gCe = (e) => {
    var h;
    return (h = t.current[c]) == null ? void 0 : h[f];
    maxLastColumn: h,
    for (let v = f; v < h; v += 1) {
      const w = vCe({
        columnIndex: v,
        maxLastColumnIndex: h,
      w.colSpan > 1 && (v += w.colSpan - 1);
  On(e, s, "public"), On(e, a, "private"), Ot(e, "columnOrderChange", r);
function vCe(e) {
  } = e, f = c.length, h = c[r], g = t.current.getRow(o), v = t.current.getRowValue(g, h), w = typeof h.colSpan == "function" ? h.colSpan(v, g, h, t) : h.colSpan;
    return KP(n, o, r, {
        width: h.computedWidth
  let C = h.computedWidth;
      C += O.computedWidth, KP(n, o, r + T, {
    KP(n, o, r, {
function KP(e, t, n, r) {
const nG = (e, t, n) => {
  if (J5(e)) {
    nG(s, [...t, r], n);
}, hI = (e) => {
    nG(n, [], t);
}, mI = (e, t, n) => {
  const r = (f) => t[f] ?? [], o = [], s = Math.max(...e.map((f) => r(f).length)), a = (f, h, g) => Yf(r(f).slice(0, g + 1), r(h).slice(0, g + 1)), c = (f, h) => !!(n != null && n.left && n.left.includes(f) && !n.left.includes(h) || n != null && n.right && !n.right.includes(f) && n.right.includes(h));
    const h = e.reduce((g, v) => {
      const w = r(v)[f] ?? null;
          columnFields: [v],
      return C.groupId !== w || !a(T, v, f) || // Fix for https://github.com/mui/mui-x/issues/7041
      c(T, v) ? [...g, {
        columnFields: [v],
        columnFields: [...C.columnFields, v],
    o.push(h);
}, yCe = ["groupId", "children"], dA = (e) => {
    if (J5(n))
    } = n, s = qt(n, yCe);
    }), c = dA(o);
}, bCe = (e, t, n) => {
  const r = Rd(n), o = Ty(n), s = dA(t.columnGroupingModel ?? []), a = hI(t.columnGroupingModel ?? []), c = mI(r, a, n.current.state.pinnedColumns ?? {}), f = o.length === 0 ? 0 : Math.max(...o.map((h) => {
    return ((g = a[h]) == null ? void 0 : g.length) ?? 0;
}, wCe = (e, t) => {
  const n = x.useCallback((c) => zW(e)[c] ?? [], [e]), r = x.useCallback(() => BW(e), [e]);
  On(e, {
    const c = hI(t.columnGroupingModel ?? []);
      const h = ((w = f.columns) == null ? void 0 : w.orderedFields) ?? [], g = f.pinnedColumns ?? {}, v = mI(h, c, g);
          headerStructure: v
    const f = ((O = (E = e.current).getPinnedColumns) == null ? void 0 : O.call(E)) ?? {}, h = Rd(e), g = Ty(e), v = dA(c ?? []), w = hI(c ?? []), C = mI(h, w, f), T = g.length === 0 ? 0 : Math.max(...g.map((P) => {
      return ((I = w[P]) == null ? void 0 : I.length) ?? 0;
    e.current.setState((P) => J({}, P, {
        lookup: v,
function SCe() {
function HB(e, t) {
function VB(e, t, n, r) {
function CCe(e, t, n) {
function xCe(e) {
function ECe(e, t) {
  return t ? xCe(n) : n;
function UB(e) {
function TCe(e) {
  const t = x.useRef(void 0), n = () => KW(e), r = Ze(e, n);
      t.current = SCe();
function _Ce(e, t) {
function OCe(e, t, n) {
    const c = Gye(e.current, s.field).map((T) => T.getBoundingClientRect().width ?? 0), f = t.includeOutliers ? c : _Ce(c, t.outliersFactor);
      const T = Wye(e.current, s.field);
        const E = T.querySelector(`.${se.columnHeaderTitle}`), O = T.querySelector(`.${se.columnHeaderTitleContainerContent}`), P = T.querySelector(`.${se.iconButtonContainer}`), I = T.querySelector(`.${se.menuIcon}`), M = E ?? O, A = window.getComputedStyle(T, null), k = parseInt(A.paddingLeft, 10) + parseInt(A.paddingRight, 10), B = M.scrollWidth + 1 + k + ((P == null ? void 0 : P.clientWidth) ?? 0) + ((I == null ? void 0 : I.clientWidth) ?? 0);
        f.push(B);
    const h = s.minWidth !== -1 / 0 && s.minWidth !== void 0, g = s.maxWidth !== 1 / 0 && s.maxWidth !== void 0, v = h ? s.minWidth : 0, w = g ? s.maxWidth : 1 / 0, C = f.length === 0 ? 0 : Math.max(...f);
    r[s.field] = La(C, v, w);
const RCe = (e) => J({}, e, {
function kCe() {
const PCe = (e, t) => {
  const n = _c(), r = yi(e, "useGridColumnResize"), o = Ml(kCe).current, s = x.useRef(null), a = x.useRef(null), c = Aa(), f = x.useRef(void 0), h = (F) => {
    var G, Y;
    r.debug(`Updating width to ${F} for col ${o.colDef.field}`);
    const D = o.columnHeaderElement.offsetWidth, q = F - D, U = F - o.initialColWidth;
    if (U > 0) {
      const X = o.initialTotalWidth + U;
      (Y = (G = e.current.rootElementRef) == null ? void 0 : G.current) == null || Y.style.setProperty("--DataGrid-rowWidth", `${X}px`);
    }
    o.colDef.computedWidth = F, o.colDef.width = F, o.colDef.flex = 0, o.columnHeaderElement.style.width = `${F}px`;
    const K = o.headerFilterElement;
    K && (K.style.width = `${F}px`), o.groupHeaderElements.forEach((X) => {
      te.getAttribute("aria-colspan") === "1" ? re = `${F}px` : re = `${te.offsetWidth + q}px`, te.style.width = re;
      te.getAttribute("aria-colspan") === "1" ? re = `${F}px` : re = `${te.offsetWidth + q}px`, te.style.setProperty("--width", re);
    ee === Lf.LEFT && (xv(o.fillerLeft, "width", q), o.leftPinnedCellsAfter.forEach((X) => {
      xv(X, "left", q);
      xv(X, "left", q);
    })), ee === Lf.RIGHT && (xv(o.fillerRight, "width", q), o.rightPinnedCellsBefore.forEach((X) => {
      xv(X, "right", q);
      xv(X, "right", q);
  }, g = (F) => {
    if (P(), o.previousMouseClickEvent) {
      const D = o.previousMouseClickEvent, q = D.timeStamp, U = D.clientX, K = D.clientY;
      if (F.timeStamp - q < 300 && F.clientX === U && F.clientY === K) {
        o.previousMouseClickEvent = void 0, e.current.publishEvent("columnResizeStop", null, F);
      const D = bc(e.current.state);
        const U = jye(q), K = q, G = `${U.reduce((Y, X) => D.columnVisibilityModel[X] !== !1 ? Y + D.lookup[X].computedWidth : Y, 0)}px`;
        K.style.width = G;
      e.current.publishEvent("columnResizeStop", null, F);
  }, v = (F, D, q) => {
    const U = e.current.rootElementRef.current;
    o.initialColWidth = F.computedWidth, o.initialTotalWidth = e.current.getRootDimensions().rowWidth, o.colDef = F, o.columnHeaderElement = Lye(e.current.columnHeadersContainerRef.current, F.field);
    const K = U.querySelector(`.${se.headerFilterRow} [data-field="${Ad(F.field)}"]`);
    K && (o.headerFilterElement = K), o.groupHeaderElements = Fye((G = e.current.columnHeadersContainerRef) == null ? void 0 : G.current, F.field), o.cellElements = zye(o.columnHeaderElement, e.current), o.fillerLeft = bB(e.current, n ? "filler--pinnedRight" : "filler--pinnedLeft"), o.fillerRight = bB(e.current, n ? "filler--pinnedLeft" : "filler--pinnedRight");
    o.leftPinnedCellsAfter = ee !== Lf.LEFT ? [] : Bye(e.current, o.columnHeaderElement, n), o.rightPinnedCellsBefore = ee !== Lf.RIGHT ? [] : Hye(e.current, o.columnHeaderElement, n), o.leftPinnedHeadersAfter = ee !== Lf.LEFT ? [] : Vye(e.current, o.columnHeaderElement, n), o.rightPinnedHeadersBefore = ee !== Lf.RIGHT ? [] : Uye(e.current, o.columnHeaderElement, n), a.current = ECe(D, n), s.current = CCe(q, o.columnHeaderElement.getBoundingClientRect(), a.current);
  }, w = Fn(g), C = Fn((F) => {
    if (F.buttons === 0) {
      w(F);
    let D = VB(s.current, F.clientX, o.columnHeaderElement.getBoundingClientRect(), a.current);
    D = La(D, o.colDef.minWidth, o.colDef.maxWidth), h(D);
      width: D
    e.current.publishEvent("columnResize", q, F);
  }), T = Fn((F) => {
    HB(F, f.current) && g(F);
  }), E = Fn((F) => {
    const D = HB(F, f.current);
    if (!D)
    if (F.type === "mousemove" && F.buttons === 0) {
      T(F);
    let q = VB(s.current, D.x, o.columnHeaderElement.getBoundingClientRect(), a.current);
    q = La(q, o.colDef.minWidth, o.colDef.maxWidth), h(q);
    const U = {
    e.current.publishEvent("columnResize", U, F);
  }), O = Fn((F) => {
    const D = v_(F.target, se["columnSeparator--resizable"]);
    if (!D)
    const q = F.changedTouches[0];
    const U = v_(F.target, se.columnHeader), K = $ye(U), ee = e.current.getColumn(K);
      field: K
    }, F), v(ee, D, q.clientX);
    const G = go(F.currentTarget);
  }), P = x.useCallback(() => {
    const F = go(e.current.rootElementRef.current);
    F.body.style.removeProperty("cursor"), F.removeEventListener("mousemove", C), F.removeEventListener("mouseup", w), F.removeEventListener("touchmove", E), F.removeEventListener("touchend", T), setTimeout(() => {
      F.removeEventListener("click", UB, !0);
    field: F
    e.current.setState((D) => J({}, D, {
      columnResize: J({}, D.columnResize, {
        resizingColumnField: F
    e.current.setState((F) => J({}, F, {
      columnResize: J({}, F.columnResize, {
  }, [e]), A = Fn(({
    colDef: F
  }, D) => {
    if (D.button !== 0 || !D.currentTarget.classList.contains(se["columnSeparator--resizable"]))
    D.preventDefault(), r.debug(`Start Resize on col ${F.field}`), e.current.publishEvent("columnResizeStart", {
      field: F.field
    }, D), v(F, D.currentTarget, D.clientX);
    const q = go(e.current.rootElementRef.current);
    q.body.style.cursor = "col-resize", o.previousMouseClickEvent = D.nativeEvent, q.addEventListener("mousemove", C), q.addEventListener("mouseup", w), q.addEventListener("click", UB, !0);
  }), k = Fn((F, D) => {
    if (t.disableAutosize || D.button !== 0)
    const q = e.current.state.columns.lookup[F.field];
  }), j = TCe(e), B = x.useRef(!1), H = x.useCallback(async (F) => {
    if (!((ee = e.current.rootElementRef) == null ? void 0 : ee.current) || B.current)
    B.current = !0;
    const q = bc(e.current.state), U = J({}, Ive, F, {
      columns: (F == null ? void 0 : F.columns) ?? q.orderedFields
    U.columns = U.columns.filter((G) => q.columnVisibilityModel[G] !== !1);
    const K = U.columns.map((G) => e.current.state.columns.lookup[G]);
      !t.disableVirtualization && U.disableColumnVirtualization && (e.current.unstable_setColumnVirtualization(!1), await j());
      const G = OCe(e, U, K), Y = K.map((X) => J({}, X, {
      if (U.expand) {
        const te = q.orderedFields.map((ie) => q.lookup[ie]).filter((ie) => q.columnVisibilityModel[ie.field] !== !1).reduce((ie, de) => ie + (G[de.field] ?? de.computedWidth ?? de.width), 0), V = e.current.getRootDimensions().viewportInnerSize.width - te;
        if (V > 0) {
          const ie = V / (Y.length || 1);
          Y.forEach((de) => {
      e.current.updateColumns(Y), Y.forEach((X, te) => {
        if (X.width !== K[te].width) {
      t.disableVirtualization || e.current.unstable_setColumnVirtualization(!0), B.current = !1;
  }, [e, j, t.disableVirtualization]);
  x.useEffect(() => P, [P]), HI(() => {
  }), TW(e, () => {
    var F;
    return (F = e.current.columnHeadersContainerRef) == null ? void 0 : F.current;
  }), On(e, {
    autosizeColumns: H
  }, "public"), Ot(e, "columnResizeStop", M), Ot(e, "columnResizeStart", I), Ot(e, "columnSeparatorMouseDown", A), Ot(e, "columnSeparatorDoubleClick", k), hr(e, "columnResize", t.onColumnResize), hr(e, "columnWidthChange", t.onColumnWidthChange);
function xv(e, t, n) {
function MCe(e, t) {
function WB(e) {
const YP = (e, t, n) => {
}, Av = {
}, C_ = {
}, ICe = /* @__PURE__ */ new Set([hl, "__reorder__", E1]), GB = 20, rG = (e, t, n, r, o, s, a) => {
  const c = s ? {} : J({}, e.current.state.rowSpanning.spannedCells), f = s ? {} : J({}, e.current.state.rowSpanning.hiddenCells), h = s ? {} : J({}, e.current.state.rowSpanning.hiddenCellOriginMap);
  return s && (a = C_), t.forEach((g) => {
    var v;
    if (!ICe.has(g.field)) {
        if ((v = f[C.id]) != null && v[g.field])
        const T = YP(C.model, g, e);
        let E = C.id, O = w, P = 0;
          let A = w - 1, k = n[A];
          for (; A >= r.firstRowIndex && k && YP(k.model, g, e) === T; ) {
            const j = n[A + 1];
            f[j.id] ? f[j.id][g.field] = !0 : f[j.id] = {
            }, I.push(w), P += 1, E = k.id, O = A, A -= 1, k = n[A];
        I.forEach((A) => {
          h[A] ? h[A][g.field] = O : h[A] = {
        for (; M <= r.lastRowIndex && n[M] && YP(n[M].model, g, e) === T; ) {
          const A = n[M];
          f[A.id] ? f[A.id][g.field] = !0 : f[A.id] = {
          }, h[M] ? h[M][g.field] = O : h[M] = {
          }, M += 1, P += 1;
        P > 0 && (c[E] ? c[E][g.field] = P + 1 : c[E] = {
          [g.field]: P + 1
    hiddenCellOriginMap: h,
}, oG = (e, t) => {
  const n = gS(t).length;
    const r = PW(t);
    let o = GB;
    lastRowIndex: Math.min(GB, n)
}, DCe = (e, t, n) => {
      rowSpanning: Av
      rowSpanning: Av
  const f = oG(t, n), h = r.map((E) => ({
    spannedCells: v,
  } = rG(n, g, h, f, f, !0, C_);
      spannedCells: v,
}, ACe = (e, t) => {
  const n = Ml(() => e.current.state.rowSpanning !== Av ? oG(t, e) : C_), r = x.useCallback((s, a = !1) => {
    } = Qf(e, {
    if (c === null || !WB(s))
    a && (n.current = C_);
    const h = MCe({
    if (h === null)
    const g = mo(e), {
      spannedCells: v,
    } = rG(e, g, f, c, h, a, n.current);
    const E = Object.keys(v).length, O = Object.keys(w).length, P = Object.keys(e.current.state.rowSpanning.spannedCells).length, I = Object.keys(e.current.state.rowSpanning.hiddenCells).length;
    !(a || E !== P || O !== I) || E === 0 && P === 0 || e.current.setState((k) => J({}, k, {
        spannedCells: v,
    const s = NC(e);
    WB(s) && r(s, !0);
  Ot(e, "renderedRowsIntervalChange", qh(t.unstable_rowSpanning, r)), Ot(e, "sortedRowsSet", qh(t.unstable_rowSpanning, o)), Ot(e, "paginationModelChange", qh(t.unstable_rowSpanning, o)), Ot(e, "filteredRowsSet", qh(t.unstable_rowSpanning, o)), Ot(e, "columnsChange", qh(t.unstable_rowSpanning, o)), x.useEffect(() => {
    t.unstable_rowSpanning ? e.current.state.rowSpanning === Av && o() : e.current.state.rowSpanning !== Av && e.current.setState((s) => J({}, s, {
      rowSpanning: Av
}, NCe = (e, t, n) => J({}, e, {
    computedWidth: gI(n)
function $Ce(e, t) {
        computedWidth: gI(e)
  }), Ot(e, "columnVisibilityModelChange", n), Lr(() => {
        computedWidth: gI(e)
    t.unstable_listView && !t.unstable_listColumn && Cl(["MUI X: The `unstable_listColumn` prop must be set if `unstable_listView` is enabled.", 'To fix, pass a column definition to the `unstable_listColumn` prop, e.g. `{ field: "example", renderCell: (params) => <div>{params.row.id}</div> }`.', "For more details, see https://mui.com/x/react-data-grid/list-view/"]);
function gI(e) {
  return vi(e.current.state).viewportInnerSize.width;
const LCe = (e, t) => {
  const n = iSe(e, t);
  return nCe(n, t), QSe(n), hi(rSe, n, t), hi(ZSe, n, t), hi(pSe, n, t), hi(GSe, n, t), hi(ASe, n, t), hi(USe, n, t), hi(OSe, n, t), hi(rCe, n, t), hi($Se, n, t), hi(xSe, n, t), hi(DCe, n, t), hi(mSe, n, t), hi(RCe, n, t), hi(dSe, n, t), hi(bCe, n, t), hi(Gge, n, t), hi(uCe, n, t), hi(pCe, n, t), hi(NCe, n, t), MSe(n, t), eCe(n, t), hSe(n, t), qSe(n, t), ACe(n, t), JSe(n, t), gCe(n), wCe(n, t), WSe(n, t), RSe(n, t), LSe(n, t), _Se(n, t), oCe(n, t), gSe(n, t), PCe(n, t), NSe(n, t), hCe(n, t), iCe(n, t), fSe(n), ySe(n, t), CSe(n, t), cSe(n, t), cCe(n, t), sCe(n, t), mCe(n), qge(n, t), $Ce(n, t), n;
}, jCe = (e) => {
  } = e, h = {
    root: ["columnHeader", n === "left" && "columnHeader--alignLeft", n === "center" && "columnHeader--alignCenter", n === "right" && "columnHeader--alignRight", r && "columnHeader--moving", a && "columnHeader--withRightBorder", s && "columnHeader--withLeftBorder", "withBorderColor", c === null ? "columnHeader--emptyGroup" : "columnHeader--filledGroup", f === $n.LEFT && "columnHeader--pinnedLeft", f === $n.RIGHT && "columnHeader--pinnedRight", o && "columnHeader--last"],
  return mt(h, Bn, t);
function FCe(e) {
    tabIndex: h,
    pinnedPosition: v,
  } = e, C = $t(), T = _c(), E = x.useRef(null), O = kn(), P = Ze(O, BW), I = t ? P[t] : {}, {
    description: A = "",
    headerAlign: k = void 0
  let j;
  const B = t && ((te = P[t]) == null ? void 0 : te.renderHeaderGroup), H = x.useMemo(() => ({
    description: A,
  }), [t, M, A, r, o, s, c, g]);
  t && B && (j = B(H));
  const F = J({}, e, {
    headerAlign: k,
  }), D = M ?? t, q = mr(), U = t === null ? `empty-group-cell-${q}` : t, K = jCe(F);
      $C(Q) || O.current.publishEvent(re, H, Q);
    [O, H]
  }), [ee]), Y = typeof I.headerClassName == "function" ? I.headerClassName(H) : I.headerClassName, X = x.useMemo(() => M1(J({}, e.style), T, v, w), [v, w, e.style, T]);
  return /* @__PURE__ */ $.jsx(g4, J({
    classes: K,
    tabIndex: h,
    headerComponent: j,
    headerClassName: Y,
    description: A,
    elementId: U,
    label: D,
const qB = Ue("div", {
}), zCe = (e) => {
    columnMenuState: h,
    columnGroupsHeaderStructure: v,
  } = e, [C, T] = x.useState(""), [E, O] = x.useState(""), P = Ba(), I = $t(), M = Ze(P, zW), A = Ze(P, pp), k = Ze(P, Wge), j = Ze(P, _y), B = Ze(P, Dd), H = QW(A, k, j.left.length), F = Ze(P, w1), D = Ze(P, V5), q = Ze(P, che), U = Ze(P, dhe), K = Ze(P, U5), ee = x.useCallback((ge) => O(ge.field), []), G = x.useCallback(() => O(""), []), Y = x.useCallback((ge) => T(ge.field), []), X = x.useCallback(() => T(""), []), te = x.useMemo(() => j.left.length ? {
    lastColumnIndex: j.left.length
  } : null, [j.left.length]), re = x.useMemo(() => j.right.length ? {
    firstColumnIndex: t.length - j.right.length,
  } : null, [j.right.length, t.length]);
  Ot(P, "columnResizeStart", ee), Ot(P, "columnResizeStop", G), Ot(P, "columnHeaderDragStart", Y), Ot(P, "columnHeaderDragEnd", X);
      renderContext: fe = k
  }, V = (ge, fe, pe, be = !1) => {
    const we = (ge == null ? void 0 : ge.position) === $n.RIGHT, _e = (ge == null ? void 0 : ge.position) === void 0, ce = j.right.length > 0 && we || j.right.length === 0 && _e, Ce = H - pe;
      }), ce && /* @__PURE__ */ $.jsx(lA, {
      const ce = pe[_e], Ce = be + _e, Ne = Ce === 0, Be = o !== null && o.field === ce.field || Ne && !w ? 0 : -1, tt = a !== null && a.field === ce.field, Le = h.open && h.field === ce.field, rt = ge == null ? void 0 : ge.position, ot = DS(rt, ce.computedWidth, Ce, A, F, K), wt = rt === $n.RIGHT ? pe[_e - 1] : pe[_e + 1], gt = wt ? a !== null && a.field === wt.field : !1, nt = Ce + 1 === A.length - j.right.length, Ft = _e, ut = pe.length, Et = w_(rt, Ft), Tt = b_(rt, Ft, ut, I.showColumnVerticalBorder, D);
      we.push(/* @__PURE__ */ $.jsx(nbe, J({}, n[ce.field], {
        columnMenuOpen: Le,
        isLast: Ce === A.length - 1,
    return V(ge, we, 0);
  }, de = () => /* @__PURE__ */ $.jsxs(qB, {
      position: $n.LEFT,
      renderContext: k
      position: $n.RIGHT,
      separatorSide: sA.Left
    } = pe, _e = v[ge], ce = t[be].field, Ce = ((ut = M[ce]) == null ? void 0 : ut[ge]) ?? null, Ne = _e.findIndex(({
    }) => Tt === Ce && At.includes(ce)), Be = t[we - 1].field, tt = ((Et = M[Be]) == null ? void 0 : Et[ge]) ?? null, Le = _e.findIndex(({
    }) => Tt === tt && At.includes(Be)), rt = _e.slice(Ne, Le + 1).map((Tt) => J({}, Tt, {
      const vt = B[At];
        width: At.reduce((bt, We) => bt + B[We].computedWidth, 0),
      }, pt = fe.position, yt = DS(pt, Ie.width, nt, A, F, K);
      return pt === $n.LEFT && (zt = nt - 1), /* @__PURE__ */ $.jsx(FCe, {
        height: U,
        showLeftBorder: w_(pt, zt),
        showRightBorder: b_(pt, zt, rt.length, I.showColumnVerticalBorder, D)
    return V(fe, Ft, gt);
    renderContext: k,
    pinnedColumns: j,
    columnPositions: A,
    getFillers: V,
        ge.push(/* @__PURE__ */ $.jsxs(qB, {
              position: $n.LEFT,
              renderContext: k
              position: $n.RIGHT,
    getPinnedCellOffset: DS,
}, BCe = ["className"], HCe = (e) => {
  }, Bn, t);
}, VCe = jr("div", {
}), UCe = Qn(function(t, n) {
  } = t, o = qt(t, BCe), s = $t(), a = HCe(s);
  return /* @__PURE__ */ $.jsx(VCe, J({
}), WCe = ["className", "visibleColumns", "sortColumnLookup", "filterColumnLookup", "columnHeaderTabIndexState", "columnGroupHeaderTabIndexState", "columnHeaderFocus", "columnGroupHeaderFocus", "headerGroupingMaxDepth", "columnMenuState", "columnVisibility", "columnGroupsHeaderStructure", "hasOtherElementInTabSequence"], iG = Qn(function(t, n) {
    columnGroupHeaderFocus: h,
    columnMenuState: v,
  } = t, E = qt(t, WCe), {
    getColumnHeadersRow: P,
  } = zCe({
    columnGroupHeaderFocus: h,
    columnMenuState: v,
  return /* @__PURE__ */ $.jsxs(UCe, J({}, E, O(), {
    children: [I(), P()]
process.env.NODE_ENV !== "production" && (iG.propTypes = {
const GCe = Id(iG);
function qCe(e) {
function KCe(e) {
const YCe = Qn(function(t, n) {
  const o = kn().current.getLocaleText("noResultsOverlayLabel");
  return /* @__PURE__ */ $.jsx(I1, J({}, t, {
}), XCe = ["sortingOrder"], QCe = /* @__PURE__ */ x.memo(function(t) {
  } = t, r = qt(t, XCe), o = $t(), [s] = n, a = s === "asc" ? o.slots.columnSortedAscendingIcon : o.slots.columnSortedDescendingIcon;
}), JCe = ["native"];
function ZCe(e) {
  } = e, n = qt(e, JCe);
  return t ? /* @__PURE__ */ $.jsx("option", J({}, n)) : /* @__PURE__ */ $.jsx(Sl, J({}, n));
}
const e0e = {
  booleanCellTrueIcon: Cbe,
  booleanCellFalseIcon: UP,
  columnMenuIcon: ybe,
  openFilterButtonIcon: dbe,
  filterPanelDeleteIcon: UP,
  columnFilteredIcon: EB,
  columnSelectorIcon: pbe,
  columnUnsortedIcon: QCe,
  columnSortedAscendingIcon: wB,
  columnSortedDescendingIcon: SB,
  columnResizeIcon: hbe,
  densityCompactIcon: mbe,
  densityStandardIcon: gbe,
  densityComfortableIcon: vbe,
  exportIcon: Sbe,
  moreActionsIcon: xbe,
  treeDataCollapseIcon: xB,
  treeDataExpandIcon: CB,
  groupingCriteriaCollapseIcon: xB,
  groupingCriteriaExpandIcon: CB,
  detailPanelExpandIcon: TB,
  detailPanelCollapseIcon: bbe,
  rowReorderIcon: _B,
  quickFilterIcon: fbe,
  quickFilterClearIcon: UP,
  columnMenuHideIcon: Ebe,
  columnMenuSortAscendingIcon: wB,
  columnMenuSortDescendingIcon: SB,
  columnMenuFilterIcon: EB,
  columnMenuManageColumnsIcon: Tbe,
  columnMenuClearIcon: _be,
  loadIcon: wbe,
  filterPanelAddIcon: TB,
  filterPanelRemoveAllIcon: Obe,
  columnReorderIcon: _B
}, t0e = J({}, e0e, {
  baseBadge: kV,
  baseCheckbox: AV,
  baseDivider: qf,
  baseTextField: Xh,
  baseFormControl: X_,
  baseSelect: yy,
  baseButton: Qv,
  baseIconButton: hu,
  baseInputAdornment: pD,
  baseTooltip: vD,
  basePopper: cp,
  baseInputLabel: J_,
  baseSelectOption: ZCe,
  baseChip: _d
}), n0e = J({}, t0e, {
  cell: eye,
  skeletonCell: sye,
  columnHeaderFilterIconButton: w4,
  columnHeaderSortIcon: ube,
  columnMenu: I4,
  columnHeaders: GCe,
  detailPanels: qCe,
  footer: V4,
  footerRowCount: q4,
  pinnedRows: KCe,
  loadingOverlay: U4,
  noResultsOverlay: YCe,
  noRowsOverlay: W4,
  pagination: G4,
  filterPanel: L4,
  columnsPanel: D4,
  columnsManagement: j4,
  panel: A4,
  row: jwe
}), r0e = {
}, o0e = n0e, i0e = (e) => {
  const t = za(), n = Gve(x.useMemo(() => Lpe({
  }), [t, e])), r = x.useMemo(() => J({}, phe, n.localeText), [n.localeText]), o = x.useMemo(() => Uve({
    defaultSlots: o0e,
  }), [n.slots]), s = x.useMemo(() => Object.keys(pI).reduce((a, c) => (a[c] = n[c] ?? pI[c], a), {}), [n]);
  }, r0e), [n, r, o, s]);
}, s0e = {
    useGridAriaAttributes: Fwe,
    useGridRowAriaAttributes: zwe,
}, sG = Qn(function(t, n) {
  const r = i0e(t), o = LCe(r.apiRef, r);
  return process.env.NODE_ENV !== "production" && Kve(r, qve), /* @__PURE__ */ $.jsx(Bwe, {
    configuration: s0e,
    children: /* @__PURE__ */ $.jsx(xye, J({
}), a0e = /* @__PURE__ */ x.memo(sG);
sG.propTypes = {
const l0e = Tn(/* @__PURE__ */ $.jsx("path", {
function aG({ products: e, loading: t, onEdit: n }) {
  const r = za(), o = rn(r.palette.primary.main, 0.12), s = rn(r.palette.primary.main, 0.08), a = rn(r.palette.primary.main, 0.04), c = x.useMemo(() => {
    const f = [
      { field: "name", headerName: "Product", flex: 1 },
      {
        field: "price",
        headerName: "Price",
        flex: 1,
        valueGetter: (h, g) => {
          var v;
          return (v = g.price) != null && v.unit_amount ? `$${(g.price.unit_amount / 100).toFixed(2)} ${g.price.currency.toUpperCase()}` : "";
      },
      {
        field: "interval",
        headerName: "Billing",
        flex: 1,
        valueGetter: (h, g) => {
          var v;
          return ((v = g.price) == null ? void 0 : v.interval) ?? "";
        },
        renderCell: (h) => h.value && h.value !== "one_time" ? /* @__PURE__ */ $.jsx(_d, { label: h.value, size: "small", color: "primary" }) : /* @__PURE__ */ $.jsx(_d, { label: h.value ?? "one time", size: "small", variant: "outlined" })
      },
      {
        field: "status",
        headerName: "Status",
        flex: 1,
        renderCell: (h) => /* @__PURE__ */ $.jsx(
          _d,
          {
            label: h.value === "active" ? "Active" : "Archived",
            color: h.value === "active" ? "success" : "default",
            size: "small"
          }
        )
      }
    ];
    return n && f.push({
      renderCell: (h) => /* @__PURE__ */ $.jsx(hu, { color: "primary", onClick: () => n(h.row), children: /* @__PURE__ */ $.jsx(l0e, {}) })
    }), f;
  }, [n]);
  return /* @__PURE__ */ $.jsx(
    ym,
      sx: {
        height: 520,
        bgcolor: rn(r.palette.background.paper, 0.9),
        borderRadius: 3,
        border: "1px solid",
        borderColor: o,
        overflow: "hidden",
        boxShadow: "0 20px 45px rgba(24, 39, 75, 0.08)",
        backdropFilter: "blur(8px)",
        "& .MuiDataGrid-columnHeaders": {
          bgcolor: s,
          color: r.palette.primary.main,
          fontWeight: 600
        },
        "& .MuiDataGrid-row:hover": {
          bgcolor: a
        },
        "& .MuiDataGrid-cell": {
          borderColor: rn(r.palette.primary.main, 0.06)
        }
      },
      children: /* @__PURE__ */ $.jsx(
        a0e,
        {
          rows: e,
          getRowId: (f) => f.id,
          columns: c,
          loading: t,
          disableRowSelectionOnClick: !0,
          disableColumnMenu: !0,
          hideFooter: !0
        }
      )
  );
const u0e = [
function c0e({ open: e, product: t, onClose: n, onUpdated: r }) {
  const [o, s] = x.useState(""), [a, c] = x.useState(""), [f, h] = x.useState(""), [g, v] = x.useState("one_time"), [w, C] = x.useState("usd"), [T, E] = x.useState(!1), [O, P] = x.useState(null), [I, M] = x.useState(null);
    var k, j, B;
    t ? (s(t.name), c(t.description ?? ""), (k = t.price) != null && k.unit_amount ? h((t.price.unit_amount / 100).toFixed(2)) : h(""), v(((j = t.price) == null ? void 0 : j.interval) ?? "one_time"), C(((B = t.price) == null ? void 0 : B.currency) ?? "usd")) : (s(""), c(""), h(""), v("one_time"), C("usd")), P(null), M(null);
  async function A(k) {
    var j;
    k.preventDefault(), E(!0), P(null), M(null);
      const B = Math.round(Number(f) * 100);
      if (Number.isNaN(B)) {
        P("Enter a valid price value.");
      t ? (await fle({
        priceId: (j = t.price) == null ? void 0 : j.id,
        price: B,
      }), M("Product updated successfully.")) : (await dle({
        price: B,
    } catch (B) {
      B instanceof Error ? P(B.message) : P("Something went wrong. Please try again.");
  return /* @__PURE__ */ $.jsx(BV, { anchor: "right", open: e, onClose: n, PaperProps: { sx: { width: 420, p: 3 } }, children: /* @__PURE__ */ $.jsxs(Vn, { component: "form", spacing: 3, onSubmit: A, children: [
      /* @__PURE__ */ $.jsx(un, { variant: "h5", fontWeight: 600, gutterBottom: !0, children: t ? "Edit product" : "Create new product" }),
      /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.secondary", children: "Sync updates across Supabase and Stripe instantly." })
    /* @__PURE__ */ $.jsx(qf, {}),
    /* @__PURE__ */ $.jsxs(Vn, { spacing: 2, children: [
      /* @__PURE__ */ $.jsx(Xh, { label: "Product name", value: o, onChange: (k) => s(k.target.value), required: !0 }),
        Xh,
          onChange: (k) => c(k.target.value)
        Xh,
          onChange: (k) => h(k.target.value),
          InputProps: { startAdornment: /* @__PURE__ */ $.jsx(pD, { position: "start", children: "$" }) },
      /* @__PURE__ */ $.jsxs(X_, { fullWidth: !0, children: [
        /* @__PURE__ */ $.jsx(J_, { id: "billing-label", children: "Billing" }),
          yy,
            onChange: (k) => v(k.target.value),
            children: u0e.map((k) => /* @__PURE__ */ $.jsx(Sl, { value: k.value, children: k.label }, k.value))
        Xh,
          onChange: (k) => C(k.target.value.toLowerCase()),
    O && /* @__PURE__ */ $.jsx(jv, { severity: "error", children: O }),
    I && /* @__PURE__ */ $.jsx(jv, { severity: "success", children: I }),
    /* @__PURE__ */ $.jsxs(Vn, { direction: "row", spacing: 2, children: [
      /* @__PURE__ */ $.jsx(Qv, { variant: "contained", type: "submit", disabled: T, fullWidth: !0, children: t ? "Save changes" : "Create product" }),
      /* @__PURE__ */ $.jsx(Qv, { variant: "outlined", onClick: n, fullWidth: !0, children: "Cancel" })
function lG() {
  const e = T_(), [t, n] = x.useState([]), [r, o] = x.useState(!0), [s, a] = x.useState(!1), [c, f] = x.useState(null), h = x.useMemo(
    v();
  async function v() {
      const C = await cle();
    await gu.auth.signOut(), e("/login");
  return /* @__PURE__ */ $.jsxs(ym, { sx: { minHeight: "100vh", bgcolor: "grey.100" }, children: [
    /* @__PURE__ */ $.jsx(pV, { position: "sticky", color: "primary", enableColorOnDark: !0, children: /* @__PURE__ */ $.jsxs(yD, { children: [
      /* @__PURE__ */ $.jsx(un, { variant: "h6", sx: { flexGrow: 1 }, children: "Harmony Sheets  Admin" }),
      /* @__PURE__ */ $.jsx(hu, { color: "inherit", onClick: w, children: /* @__PURE__ */ $.jsx(lle, {}) })
    /* @__PURE__ */ $.jsx(dD, { sx: { py: 4 }, children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 6, children: [
      /* @__PURE__ */ $.jsxs(Vn, { spacing: 3, children: [
        /* @__PURE__ */ $.jsxs(Vn, { spacing: 1, children: [
          /* @__PURE__ */ $.jsx(un, { variant: "h4", fontWeight: 600, children: "Business overview" }),
          /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.secondary", children: "Track sales performance and customer growth across Harmony Sheets." })
        /* @__PURE__ */ $.jsx(NU, { kpis: h }),
        /* @__PURE__ */ $.jsx(E5, { data: g })
      /* @__PURE__ */ $.jsxs(Vn, { spacing: 3, children: [
          Vn,
              /* @__PURE__ */ $.jsxs(Vn, { spacing: 1, children: [
                /* @__PURE__ */ $.jsx(un, { variant: "h4", fontWeight: 600, children: "Product catalog" }),
                /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.secondary", children: "Create, update, and archive products synced with Stripe." })
                Qv,
                  startIcon: /* @__PURE__ */ $.jsx(ule, {}),
          aG,
      c0e,
          a(!1), await v();
const d0e = [
  {
    id: "demo-product-1",
    name: "Harmony Sheets Starter",
    description: "Perfect for freelancers launching their first business templates.",
    status: "active",
    default_price_id: "demo-price-1",
    created_at: "2024-01-10T00:00:00.000Z",
    price: {
      id: "demo-price-1",
      product_id: "demo-product-1",
      nickname: "Monthly",
      unit_amount: 1900,
      currency: "usd",
      interval: "month",
      created_at: "2024-01-10T00:00:00.000Z"
    }
  },
  {
    id: "demo-product-2",
    name: "Harmony Sheets Pro",
    description: "Advanced automation bundles for established creators and teams.",
    status: "active",
    default_price_id: "demo-price-2",
    created_at: "2023-11-18T00:00:00.000Z",
    price: {
      id: "demo-price-2",
      product_id: "demo-product-2",
      nickname: "Annual",
      unit_amount: 14900,
      currency: "usd",
      interval: "year",
      created_at: "2023-11-18T00:00:00.000Z"
    }
  },
  {
    id: "demo-product-3",
    name: "Harmony Sheets Lifetime",
    description: "One-time access to every sheet, dashboard, and automation update.",
    status: "archived",
    default_price_id: "demo-price-3",
    created_at: "2023-08-05T00:00:00.000Z",
    price: {
      id: "demo-price-3",
      product_id: "demo-product-3",
      nickname: "Lifetime",
      unit_amount: 29900,
      currency: "usd",
      interval: "one_time",
      created_at: "2023-08-05T00:00:00.000Z"
    }
  }
];
function f0e() {
  const e = za(), t = rn(e.palette.primary.main, 0.08), n = rn(e.palette.secondary.main, 0.1), r = rn(e.palette.primary.main, 0.12), o = x.useMemo(
    () => [
      { label: "MRR (demo)", value: "$3,840", change: 12 },
      { label: "Active subscribers", value: "482", change: 8 },
      { label: "Conversion rate", value: "6.4%", change: -2 }
    ],
    []
  ), s = x.useMemo(
    () => Array.from({ length: 12 }).map((a, c) => ({
      date: `2024-${String(c + 1).padStart(2, "0")}-01`,
      amount: Math.round(2e3 + Math.random() * 1500)
    })),
    []
  );
  return /* @__PURE__ */ $.jsx(
    la,
    {
      elevation: 0,
      sx: {
        p: { xs: 4, md: 5 },
        height: "100%",
        borderRadius: 4,
        border: "1px solid",
        borderColor: r,
        background: `linear-gradient(135deg, ${t} 0%, ${n} 100%)`,
        color: e.palette.text.primary,
        backdropFilter: "blur(12px)"
      },
      children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 4, height: "100%", children: [
        /* @__PURE__ */ $.jsxs(Vn, { spacing: 1, children: [
          /* @__PURE__ */ $.jsx(un, { variant: "h5", fontWeight: 600, children: "Dashboard preview" }),
          /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.secondary", children: "This is a live preview using demo data. Sign in to replace it with your product catalog and customer metrics." })
        ] }),
        /* @__PURE__ */ $.jsx(NU, { kpis: o }),
        /* @__PURE__ */ $.jsx(E5, { data: s }),
        /* @__PURE__ */ $.jsxs(ym, { children: [
          /* @__PURE__ */ $.jsxs(
            Vn,
            {
              direction: { xs: "column", sm: "row" },
              justifyContent: "space-between",
              alignItems: { xs: "flex-start", sm: "center" },
              spacing: 2,
              mb: 2,
              children: [
                /* @__PURE__ */ $.jsxs(Vn, { spacing: 0.5, children: [
                  /* @__PURE__ */ $.jsx(un, { variant: "h6", fontWeight: 600, children: "Product catalog" }),
                  /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.secondary", children: "Browse the sample plans that mimic your Stripe-connected products." })
                ] }),
                /* @__PURE__ */ $.jsx(un, { variant: "caption", color: "text.secondary", children: "Editing is disabled in preview mode" })
              ]
            }
          ),
          /* @__PURE__ */ $.jsx(aG, { products: d0e, loading: !1 })
        ] }),
        /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.secondary", textAlign: "center", children: "Sign in with your admin account to see real orders, revenue, and catalog updates." })
      ] })
    }
  );
}
const p0e = /token|secret|key|password|credential|bearer|authorization/i;
function uG(e) {
  const t = e.length;
  if (!t) return "[empty]";
  if (t <= 8)
    return "".repeat(t);
  const n = e.slice(0, 4), r = e.slice(-4);
  return `${n}${r} (${t} chars)`;
}
function x_(e, t = 0) {
  if (e == null) return e;
  if (t > 4) return "[depth limit reached]";
  if (typeof e == "string")
    return e.length > 200 ? `${e.slice(0, 120)} (${e.length - 120} more chars)` : e;
  if (Array.isArray(e))
    return e.slice(0, 20).map((n) => x_(n, t + 1));
  if (e instanceof Date)
    return e.toISOString();
  if (typeof e == "object") {
    const n = e, r = {};
    for (const [o, s] of Object.entries(n))
      p0e.test(o) ? typeof s == "string" && s ? r[o] = uG(s) : s && typeof s == "object" ? r[o] = "[redacted object]" : r[o] = "[redacted]" : r[o] = x_(s, t + 1);
    return r;
  }
  return e;
}
function KB(e) {
  return !e && e !== 0 ? "" : e < 1 ? `${(e * 1e3).toFixed(0)} s` : e < 1e3 ? `${e.toFixed(1)} ms` : `${(e / 1e3).toFixed(2)} s`;
}
function YB(e) {
  try {
    return JSON.stringify(e, null, 2);
  } catch {
    return String(e);
  }
}
function XB() {
  if (typeof window > "u") return {};
  const e = window.HarmonySheetsAdminBoot;
  if (!e) return {};
  try {
    return JSON.parse(JSON.stringify(e));
  } catch {
    return e;
  }
}
function h0e() {
  return typeof window > "u" ? {
    host: "N/A",
    origin: "N/A",
    href: "N/A",
    referrer: "N/A",
    userAgent: "N/A"
  } : {
    host: window.location.host,
    origin: window.location.origin,
    href: window.location.href,
    referrer: document.referrer || "(empty)",
    userAgent: navigator.userAgent,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    language: navigator.language
  };
}
function m0e() {
  const [e, t] = x.useState(() => XB());
  return x.useEffect(() => {
    const n = window.setInterval(() => {
      t(XB());
    }, 1e3);
    return () => window.clearInterval(n);
  }, []), e;
}
function g0e({ sessionChecked: e, isAdmin: t, sessionError: n }) {
  var I, M, A;
  const r = m0e(), o = x.useMemo(() => h0e(), []), { url: s, anonKey: a } = x.useMemo(() => AU(), []), c = x.useMemo(() => ole(), []), f = x.useMemo(() => ile(), []), h = ((I = r.errors) == null ? void 0 : I.length) ?? 0, [g, v] = x.useState([]), [w, C] = x.useState(!1), [T, E] = x.useState(null), O = x.useCallback(async () => {
    const k = [
      { id: "session", label: "Retrieve current Supabase session", status: "pending" },
      { id: "user", label: "Fetch authenticated user profile", status: "pending" },
      { id: "products", label: "Query product table metadata", status: "pending" }
    ];
    v(k), C(!0);
    const j = [], B = async (H, F, D) => {
      const q = performance.now();
      try {
        const { summary: U, details: K } = await D();
        j.push({
          id: H,
          label: F,
          status: "success",
          durationMs: performance.now() - q,
          summary: U,
          details: K ? YB(x_(K)) : void 0
        });
      } catch (U) {
        const K = U instanceof Error ? U.message : String(U), ee = U instanceof Error ? { message: K, stack: U.stack } : { message: K };
        j.push({
          id: H,
          label: F,
          status: "error",
          durationMs: performance.now() - q,
          summary: K,
          details: YB(x_(ee))
        });
      }
      v((U) => [...U.filter((ee) => ee.id !== H), j[j.length - 1]].sort((ee, G) => k.findIndex((Y) => Y.id === ee.id) - k.findIndex((Y) => Y.id === G.id)));
    };
    await B("session", "Retrieve current Supabase session", async () => {
      const { data: H, error: F } = await gu.auth.getSession();
      if (F) throw F;
      const D = H == null ? void 0 : H.session;
      return {
        summary: D ? "Active session detected." : "No active session present.",
        details: D ? { expires_at: D.expires_at, user: D.user } : H
      };
    }), await B("user", "Fetch authenticated user profile", async () => {
      const { data: H, error: F } = await gu.auth.getUser();
      if (F) throw F;
      return {
        summary: H != null && H.user ? "User profile fetched." : "No authenticated user.",
        details: H
      };
    }), await B("products", "Query product table metadata", async () => {
      const { count: H, error: F } = await gu.from("products").select("*", { count: "estimated", head: !0 });
      if (F) throw F;
      return {
        summary: typeof H == "number" ? `Products table reachable (count  ${H}).` : "Products table reachable.",
        details: { count: H }
      };
    }), E(/* @__PURE__ */ new Date()), C(!1);
  }, []);
  x.useEffect(() => {
    O();
  }, [O]);
  const P = e ? t ? "Authenticated as admin user." : "No admin session detected." : "Checking existing session";
  return /* @__PURE__ */ $.jsx(la, { elevation: 6, sx: { p: { xs: 3, md: 4 }, height: "100%" }, children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 3, alignItems: "flex-start", children: [
    /* @__PURE__ */ $.jsxs(Vn, { spacing: 1, width: "100%", children: [
      /* @__PURE__ */ $.jsx(un, { variant: "h5", fontWeight: 600, gutterBottom: !0, children: "Admin diagnostics" }),
      /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.secondary", children: "Review the runtime environment, bootstrap attempts, and Supabase connectivity checks to troubleshoot why the admin dashboard is not loading as expected." }),
      /* @__PURE__ */ $.jsxs(jv, { severity: t ? "success" : e ? "warning" : "info", sx: { mt: 1 }, children: [
        P,
        n ? ` Last session error: ${n}` : ""
      ] })
    ] }),
    /* @__PURE__ */ $.jsxs(Vn, { spacing: 2, width: "100%", children: [
      /* @__PURE__ */ $.jsx(un, { variant: "subtitle1", fontWeight: 600, children: "Runtime environment" }),
      /* @__PURE__ */ $.jsx(oa, { container: !0, spacing: 1, children: Object.entries(o).map(([k, j]) => /* @__PURE__ */ $.jsx(oa, { item: !0, xs: 12, sm: 6, children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 0.25, children: [
        /* @__PURE__ */ $.jsx(un, { variant: "caption", color: "text.secondary", children: k }),
        /* @__PURE__ */ $.jsx(un, { variant: "body2", sx: { wordBreak: "break-all" }, children: String(j) })
      ] }) }, k)) })
    ] }),
    /* @__PURE__ */ $.jsx(qf, { flexItem: !0 }),
    /* @__PURE__ */ $.jsxs(Vn, { spacing: 2, width: "100%", children: [
      /* @__PURE__ */ $.jsx(un, { variant: "subtitle1", fontWeight: 600, children: "Admin configuration" }),
      /* @__PURE__ */ $.jsxs(oa, { container: !0, spacing: 1, children: [
        /* @__PURE__ */ $.jsx(oa, { item: !0, xs: 12, children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 0.25, children: [
          /* @__PURE__ */ $.jsx(un, { variant: "caption", color: "text.secondary", children: "Supabase URL" }),
          /* @__PURE__ */ $.jsx(un, { variant: "body2", sx: { wordBreak: "break-all" }, children: s })
        ] }) }),
        /* @__PURE__ */ $.jsx(oa, { item: !0, xs: 12, children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 0.25, children: [
          /* @__PURE__ */ $.jsx(un, { variant: "caption", color: "text.secondary", children: "Supabase anon key (masked)" }),
          /* @__PURE__ */ $.jsx(un, { variant: "body2", sx: { wordBreak: "break-all" }, children: uG(a) })
        ] }) }),
        /* @__PURE__ */ $.jsx(oa, { item: !0, xs: 12, sm: 6, children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 0.25, children: [
          /* @__PURE__ */ $.jsx(un, { variant: "caption", color: "text.secondary", children: "Configured admin email" }),
          /* @__PURE__ */ $.jsx(un, { variant: "body2", children: c ?? "(not configured)" })
        ] }) }),
        /* @__PURE__ */ $.jsx(oa, { item: !0, xs: 12, sm: 6, children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 0.25, children: [
          /* @__PURE__ */ $.jsx(un, { variant: "caption", color: "text.secondary", children: "Normalized admin email" }),
          /* @__PURE__ */ $.jsx(un, { variant: "body2", children: f ?? "(not configured)" })
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ $.jsx(qf, { flexItem: !0 }),
    /* @__PURE__ */ $.jsxs(Vn, { spacing: 1.5, width: "100%", children: [
      /* @__PURE__ */ $.jsxs(Vn, { direction: "row", spacing: 1, alignItems: "center", children: [
        /* @__PURE__ */ $.jsx(un, { variant: "subtitle1", fontWeight: 600, children: "Bootstrap attempts" }),
        /* @__PURE__ */ $.jsx(
          _d,
          {
            size: "small",
            label: `${((M = r.attempts) == null ? void 0 : M.length) ?? 0} attempt${(((A = r.attempts) == null ? void 0 : A.length) ?? 0) === 1 ? "" : "s"}`
          }
        )
      ] }),
      /* @__PURE__ */ $.jsx(Vn, { spacing: 1.5, width: "100%", children: (r.attempts ?? []).length === 0 ? /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.secondary", children: "No bootstrap attempts were recorded. The admin bundle may not have executed yet." }) : (r.attempts ?? []).map((k, j) => {
        var B, H;
        return /* @__PURE__ */ $.jsx(la, { variant: "outlined", sx: { p: 1.5 }, children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 0.5, children: [
          /* @__PURE__ */ $.jsxs(Vn, { direction: "row", justifyContent: "space-between", alignItems: "center", children: [
            /* @__PURE__ */ $.jsx(un, { variant: "subtitle2", fontWeight: 600, children: k.label ?? "Unknown module" }),
            /* @__PURE__ */ $.jsx(
              _d,
              {
                size: "small",
                color: k.status === "success" ? "success" : k.status === "error" ? "error" : "default",
                label: k.status ?? "pending"
              }
            )
          ] }),
          k.url && /* @__PURE__ */ $.jsx(un, { variant: "caption", sx: { wordBreak: "break-all" }, color: "text.secondary", children: k.url }),
          /* @__PURE__ */ $.jsxs(un, { variant: "caption", color: "text.secondary", children: [
            "Duration: ",
            KB(
              typeof k.startedAt == "number" && typeof k.finishedAt == "number" ? k.finishedAt - k.startedAt : void 0
            )
          ] }),
          ((B = k.error) == null ? void 0 : B.message) && /* @__PURE__ */ $.jsx(vD, { title: ((H = k.error) == null ? void 0 : H.stack) ?? "", placement: "top-start", children: /* @__PURE__ */ $.jsx(jv, { severity: "error", icon: !1, sx: { mt: 0.5 }, children: k.error.message }) })
        ] }) }, `${k.label}-${k.url}-${j}`);
      }) }),
      h > 0 && /* @__PURE__ */ $.jsxs(jv, { severity: "warning", children: [
        h,
        " error",
        h === 1 ? "" : "s",
        " recorded during bootstrap. Inspect",
        /* @__PURE__ */ $.jsx("code", { children: "window.HarmonySheetsAdminBoot" }),
        " in the console for full details."
      ] })
    ] }),
    /* @__PURE__ */ $.jsx(qf, { flexItem: !0 }),
    /* @__PURE__ */ $.jsxs(Vn, { spacing: 1.5, width: "100%", children: [
      /* @__PURE__ */ $.jsxs(Vn, { direction: "row", spacing: 1, alignItems: "center", children: [
        /* @__PURE__ */ $.jsx(un, { variant: "subtitle1", fontWeight: 600, children: "Supabase connectivity checks" }),
        w && /* @__PURE__ */ $.jsx(vy, { size: 16, thickness: 5 })
      ] }),
      /* @__PURE__ */ $.jsxs(Vn, { direction: { xs: "column", sm: "row" }, spacing: 1, alignItems: { xs: "stretch", sm: "center" }, children: [
        /* @__PURE__ */ $.jsx(Qv, { variant: "contained", onClick: () => void O(), disabled: w, children: w ? "Running diagnostics" : "Run diagnostics again" }),
        /* @__PURE__ */ $.jsx(un, { variant: "caption", color: "text.secondary", children: T ? `Last run: ${T.toLocaleString()}` : "Diagnostics have not been run yet." })
      ] }),
      /* @__PURE__ */ $.jsxs(Vn, { spacing: 1, width: "100%", children: [
        g.map((k) => /* @__PURE__ */ $.jsx(la, { variant: "outlined", sx: { p: 1.5 }, children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 0.5, children: [
          /* @__PURE__ */ $.jsxs(Vn, { direction: "row", justifyContent: "space-between", alignItems: "center", children: [
            /* @__PURE__ */ $.jsx(un, { variant: "subtitle2", fontWeight: 600, children: k.label }),
            /* @__PURE__ */ $.jsx(
              _d,
              {
                size: "small",
                color: k.status === "success" ? "success" : k.status === "error" ? "error" : "default",
                label: k.status
              }
            )
          ] }),
          /* @__PURE__ */ $.jsxs(un, { variant: "caption", color: "text.secondary", children: [
            "Duration: ",
            KB(k.durationMs)
          ] }),
          k.summary && /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.primary", children: k.summary }),
          k.details && /* @__PURE__ */ $.jsx(
            ym,
            {
              component: "pre",
              sx: {
                bgcolor: "grey.100",
                borderRadius: 1,
                p: 1,
                fontSize: "0.75rem",
                lineHeight: 1.4,
                overflow: "auto"
              },
              children: k.details
            }
          )
        ] }) }, k.id)),
        !w && g.length === 0 && /* @__PURE__ */ $.jsx(un, { variant: "body2", color: "text.secondary", children: "Diagnostics not yet available." })
      ] })
    ] })
  ] }) });
}
function v0e() {
  const [e, t] = x.useState(!1), [n, r] = x.useState(!1), [o, s] = x.useState(null);
  return x.useEffect(() => {
    let a = !0;
    async function c() {
      try {
        const {
          data: { session: h },
          error: g
        } = await gu.auth.getSession();
        if (!a) return;
        s(g ? g.message : null), t(YT(h == null ? void 0 : h.user));
      } catch (h) {
        if (!a) return;
        console.error("Failed to verify session", h), t(!1), s(h instanceof Error ? h.message : String(h));
      } finally {
        a && r(!0);
      }
    }
    c();
    const { data: f } = gu.auth.onAuthStateChange((h, g) => {
      a && (s(null), t(YT(g == null ? void 0 : g.user)));
    });
    return () => {
      a = !1, f.subscription.unsubscribe();
    };
  }, []), e && n ? /* @__PURE__ */ $.jsx(lG, {}) : /* @__PURE__ */ $.jsx(ym, { sx: { bgcolor: "grey.100", minHeight: "100vh", py: { xs: 6, md: 10 } }, children: /* @__PURE__ */ $.jsx(dD, { maxWidth: "lg", children: /* @__PURE__ */ $.jsxs(Vn, { spacing: 4, children: [
    /* @__PURE__ */ $.jsxs(Vn, { spacing: 1, textAlign: "center", children: [
      /* @__PURE__ */ $.jsx(un, { variant: "overline", color: "primary", fontWeight: 600, children: "Harmony Sheets Admin" }),
      /* @__PURE__ */ $.jsx(un, { variant: "h3", fontWeight: 700, children: "Review admin diagnostics to troubleshoot access issues" }),
      /* @__PURE__ */ $.jsx(un, { variant: "body1", color: "text.secondary", maxWidth: 720, mx: "auto", children: "Use the diagnostics panel to inspect configuration, bootstrap attempts, and Supabase connectivity. Once the blockers are resolved, sign in from the console or re-run the checks to verify access." })
    ] }),
    /* @__PURE__ */ $.jsxs(oa, { container: !0, spacing: 4, alignItems: "stretch", children: [
      /* @__PURE__ */ $.jsx(oa, { item: !0, xs: 12, md: 4, children: /* @__PURE__ */ $.jsx(
        g0e,
        {
          sessionChecked: n,
          isAdmin: e,
          sessionError: o
        }
      ) }),
      /* @__PURE__ */ $.jsx(oa, { item: !0, xs: 12, md: 8, children: /* @__PURE__ */ $.jsx(f0e, {}) })
    ] })
  ] }) }) });
}
function QB({ children: e }) {
  const t = T_(), n = op(), [r, o] = x.useState(!0), [s, a] = x.useState(!1);
        data: { session: h }
      } = await gu.auth.getSession(), g = YT(h == null ? void 0 : h.user);
    const { data: f } = gu.auth.onAuthStateChange((h, g) => {
      const v = YT(g == null ? void 0 : g.user);
      a(v), v || t("/login");
  }, [n.pathname, t]), r ? /* @__PURE__ */ $.jsx(ym, { sx: { display: "grid", placeItems: "center", height: "100vh" }, children: /* @__PURE__ */ $.jsx(vy, {}) }) : s ? /* @__PURE__ */ $.jsx($.Fragment, { children: e }) : null;
const y0e = H_({
function b0e() {
  return /* @__PURE__ */ $.jsxs(FJ, { theme: y0e, children: [
    /* @__PURE__ */ $.jsx($V, {}),
    /* @__PURE__ */ $.jsxs(JK, { children: [
      /* @__PURE__ */ $.jsx($h, { path: "/login", element: /* @__PURE__ */ $.jsx(v0e, {}) }),
        $h,
          element: /* @__PURE__ */ $.jsx(QB, { children: /* @__PURE__ */ $.jsx(ME, { to: "/dashboard", replace: !0 }) })
        $h,
          element: /* @__PURE__ */ $.jsx(QB, { children: /* @__PURE__ */ $.jsx(lG, {}) })
      /* @__PURE__ */ $.jsx($h, { path: "/products", element: /* @__PURE__ */ $.jsx(ME, { to: "/dashboard", replace: !0 }) }),
      /* @__PURE__ */ $.jsx($h, { path: "/analytics", element: /* @__PURE__ */ $.jsx(ME, { to: "/dashboard", replace: !0 }) }),
      /* @__PURE__ */ $.jsx($h, { path: "*", element: /* @__PURE__ */ $.jsx(ME, { to: "/login", replace: !0 }) })
const w0e = "/admin/".replace(/\/$/, "");
iS.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ $.jsx(pu.StrictMode, { children: /* @__PURE__ */ $.jsx(p7, { basename: w0e, children: /* @__PURE__ */ $.jsx(b0e, {}) }) })
